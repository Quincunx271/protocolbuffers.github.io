[{"body":" message Person { optional string name = 1; optional int32 id = 2; optional string email = 3; } A proto definition.\u003c/\u003e // Java code Person john = Person.newBuilder() .setId(1234) .setName(\"John Doe\") .setEmail(\"jdoe@example.com\") .build(); output = new FileOutputStream(args[0]); john.writeTo(output); Using a generated class to persist data.\n// C++ code Person john; fstream input(argv[1], ios::in | ios::binary); john.ParseFromIstream(\u0026input); id = john.id(); name = john.name(); email = john.email(); Using a generated class to parse persisted data.\nWhat Are Protocol Buffers? Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.\nPick Your Favorite Language Protocol buffers currently support generated code in Java, Python, Objective-C, and C++. With our new proto3 language version, you can also work with Kotlin, Dart, Go, Ruby, PHP, and C#, with more languages to come.\nHow Do I Start? Download and install the protocol buffer compiler. Read the overview. Try the tutorial for your chosen language. ","categories":"","description":"Protocol Buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.","excerpt":"Protocol Buffers are a language-neutral, platform-neutral extensible …","ref":"/","tags":"","title":"Protocol Buffers"},{"body":"Protocol buffers provide a language-neutral, platform-neutral, extensible mechanism for serializing structured data in a forward-compatible and backward-compatible way. It’s like JSON, except it’s smaller and faster, and it generates native language bindings. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.\nProtocol buffers are a combination of the definition language (created in .proto files), the code that the proto compiler generates to interface with data, language-specific runtime libraries, and the serialization format for data that is written to a file (or sent across a network connection).\nWhat Problems do Protocol Buffers Solve? Protocol buffers provide a serialization format for packets of typed, structured data that are up to a few megabytes in size. The format is suitable for both ephemeral network traffic and long-term data storage. Protocol buffers can be extended with new information without invalidating existing data or requiring code to be updated.\nProtocol buffers are the most commonly-used data format at Google. They are used extensively in inter-server communications as well as for archival storage of data on disk. Protocol buffer messages and services are described by engineer-authored .proto files. The following shows an example message:\nmessage Person { optional string name = 1; optional int32 id = 2; optional string email = 3; } The proto compiler is invoked at build time on .proto files to generate code in various programming languages (covered in Cross-language Compatibility later in this topic) to manipulate the corresponding protocol buffer. Each generated class contains simple accessors for each field and methods to serialize and parse the whole structure to and from raw bytes. The following shows you an example that uses those generated methods:\nPerson john = Person.newBuilder() .setId(1234) .setName(\"John Doe\") .setEmail(\"jdoe@example.com\") .build(); output = new FileOutputStream(args[0]); john.writeTo(output); Because protocol buffers are used extensively across all manner of services at Google and data within them may persist for some time, maintaining backwards compatibility is crucial. Protocol buffers allow for the seamless support of changes, including the addition of new fields and the deletion of existing fields, to any protocol buffer without breaking existing services. For more on this topic, see Updating Proto Definitions Without Updating Code, later in this topic.\nWhat are the Benefits of Using Protocol Buffers? Protocol buffers are ideal for any situation in which you need to serialize structured, record-like, typed data in a language-neutral, platform-neutral, extensible manner. They are most often used for defining communications protocols (together with gRPC) and for data storage.\nSome of the advantages of using protocol buffers include:\nCompact data storage Fast parsing Availability in many programming languages Optimized functionality through automatically-generated classes Cross-language Compatibility The same messages can be read by code written in any supported programming language. You can have a Java program on one platform capture data from one software system, serialize it based on a .proto definition, and then extract specific values from that serialized data in a separate Python application running on another platform.\nThe following languages are supported directly in the protocol buffers compiler, protoc:\nC++\nC#\nJava\nKotlin\nObjective-C\nPHP\nPython\nRuby\nThe following languages are supported by Google, but the projects’ source code resides in GitHub repositories. The protoc compiler uses plugins for these languages:\nDart Go Additional languages are not directly supported by Google, but rather by other GitHub projects. These languages are covered in Third-Party Add-ons for Protocol Buffers.\nCross-project Support You can use protocol buffers across projects by defining message types in .proto files that reside outside of a specific project’s code base. If you’re defining message types or enums that you anticipate will be widely used outside of your immediate team, you can put them in their own file with no dependencies.\nA couple of examples of proto definitions widely-used within Google are timestamp.proto and status.proto.\nUpdating Proto Definitions Without Updating Code It’s standard for software products to be backward compatible, but it is less common for them to be forward compatible. As long as you follow some simple practices when updating .proto definitions, old code will read new messages without issues, ignoring any newly added fields. To the old code, fields that were deleted will have their default value, and deleted repeated fields will be empty. For information on what “repeated” fields are, see Protocol Buffers Definition Syntax later in this topic.\nNew code will also transparently read old messages. New fields will not be present in old messages; in these cases protocol buffers provide a reasonable default value.\nWhen are Protocol Buffers not a Good Fit? Protocol buffers do not fit all data. In particular:\nProtocol buffers tend to assume that entire messages can be loaded into memory at once and are not larger than an object graph. For data that exceeds a few megabytes, consider a different solution; when working with larger data, you may effectively end up with several copies of the data due to serialized copies, which can cause surprising spikes in memory usage. When protocol buffers are serialized, the same data can have many different binary serializations. You cannot compare two messages for equality without fully parsing them. Messages are not compressed. While messages can be zipped or gzipped like any other file, special-purpose compression algorithms like the ones used by JPEG and PNG will produce much smaller files for data of the appropriate type. Protocol buffer messages are less than maximally efficient in both size and speed for many scientific and engineering uses that involve large, multi-dimensional arrays of floating point numbers. For these applications, FITS and similar formats have less overhead. Protocol buffers are not well supported in non-object-oriented languages popular in scientific computing, such as Fortran and IDL. Protocol buffer messages don’t inherently self-describe their data, but they have a fully reflective schema that you can use to implement self-description. That is, you cannot fully interpret one without access to its corresponding .proto file. Protocol buffers are not a formal standard of any organization. This makes them unsuitable for use in environments with legal or other requirements to build on top of standards. Who Uses Protocol Buffers? Many projects use protocol buffers, including the following:\ngRPC Google Cloud Envoy Proxy How do Protocol Buffers Work? The following diagram shows how you use protocol buffers to work with your data.\nFigure 1. Protocol buffers workflow\nThe code generated by protocol buffers provides utility methods to retrieve data from files and streams, extract individual values from the data, check if data exists, serialize data back to a file or stream, and other useful functions.\nThe following code samples show you an example of this flow in Java. As shown earlier, this is a .proto definition:\nmessage Person { optional string name = 1; optional int32 id = 2; optional string email = 3; } Compiling this .proto file creates a Builder class that you can use to create new instances, as in the following Java code:\nPerson john = Person.newBuilder() .setId(1234) .setName(\"John Doe\") .setEmail(\"jdoe@example.com\") .build(); output = new FileOutputStream(args[0]); john.writeTo(output); You can then deserialize data using the methods protocol buffers creates in other languages, like C++:\nPerson john; fstream input(argv[1], ios::in | ios::binary); john.ParseFromIstream(\u0026input); int id = john.id(); std::string name = john.name(); std::string email = john.email(); Protocol Buffers Definition Syntax When defining .proto files, you can specify that a field is either optional or repeated (proto2 and proto3) or singular (proto3). (The option to set a field to required is absent in proto3 and strongly discouraged in proto2. For more on this, see “Required is Forever” in Specifying Field Rules.)\nAfter setting the optionality/repeatability of a field, you specify the data type. Protocol buffers support the usual primitive data types, such as integers, booleans, and floats. For the full list, see Scalar Value Types.\nA field can also be of:\nA message type, so that you can nest parts of the definition, such as for repeating sets of data. An enum type, so you can specify a set of values to choose from. A oneof type, which you can use when a message has many optional fields and at most one field will be set at the same time. A map type, to add key-value pairs to your definition. In proto2, messages can allow extensions to define fields outside of the message, itself. For example, the protobuf library’s internal message schema allows extensions for custom, usage-specific options.\nFor more information about the options available, see the language guide for proto2 or proto3.\nAfter setting optionality and field type, you assign a field number. Field numbers cannot be repurposed or reused. If you delete a field, you should reserve its field number to prevent someone from accidentally reusing the number.\nAdditional Data Type Support Protocol buffers support many scalar value types, including integers that use both variable-length encoding and fixed sizes. You can also create your own composite data types by defining messages that are, themselves, data types that you can assign to a field. In addition to the simple and composite value types, several common types are published.\nCommon Types Duration is a signed, fixed-length span of time, such as 42s. Timestamp is a point in time independent of any time zone or calendar, such as 2017-01-15T01:30:15.01Z. Interval is a time interval independent of time zone or calendar, such as 2017-01-15T01:30:15.01Z - 2017-01-16T02:30:15.01Z. Date is a whole calendar date, such as 2025-09-19. DayOfWeek is a day of the week, such as Monday. TimeOfDay is a time of day, such as 10:42:23. LatLng is a latitude/longitude pair, such as 37.386051 latitude and -122.083855 longitude. Money is an amount of money with its currency type, such as 42 USD. PostalAddress is a postal address, such as 1600 Amphitheatre Parkway Mountain View, CA 94043 USA. Color is a color in the RGBA color space. Month is a month of the year, such as April. History To read about the history of the protocol buffers project, see History of Protocol Buffers.\nProtocol Buffers Open Source Philosophy Protocol buffers were open sourced in 2008 as a way to provide developers outside of Google with the same benefits that we derive from them internally. We support the open source community through regular updates to the language as we make those changes to support our internal requirements. While we accept select pull requests from external developers, we cannot always prioritize feature requests and bug fixes that don’t conform to Google’s specific needs.\nDeveloper Community To be alerted to upcoming changes in Protocol Buffers and to connect with protobuf developers and users, join the Google Group.\nAdditional Resources Protocol Buffers GitHub ","categories":"","description":"Protocol Buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data.","excerpt":"Protocol Buffers are a language-neutral, platform-neutral extensible …","ref":"/overview/","tags":"","title":"Overview"},{"body":"News topics provide information about past events and changes with Protocol Buffers, and plans for upcoming changes.\nAugust 3, 2022 - Platform Support Changes and Upcoming Changes in the C++ 22.x Line July 6, 2022 - Library Breaking Change Policy May 6, 2022 - Versioning, Python Updates, and JavaScript Support ","categories":"","description":"Get the latest news about Protocol Buffers.","excerpt":"Get the latest news about Protocol Buffers.","ref":"/news/","tags":"","title":"News"},{"body":"Versioning We changed our versioning scheme to enable more-nimble updates to language-specific parts of Protocol Buffers. In the new scheme, each language has its own major version that can be incremented independently of other languages, as covered later in this topic with the Python release. The minor and patch versions, however, will remain coupled. This allows us to introduce breaking changes into some languages without requiring a bump of the major version in languages that do not experience a breaking change.\nThe first instance of this new versioning scheme is the new version of the Python API, 4.21.0, which follows the preceding version, 3.20.1. Other language APIs will be released as 3.21.0.\nPython Updates We made some changes in Python language support in Protocol Buffers. Version 4.21.0 is a new major version, following 3.20.1. The new version is based on the upb library, and offers significantly better parsing performance than previous releases, especially for large payloads. It also includes prebuilt binary modules for Apple silicon for increased performance without a manual build.\nThe new release does contain some breaking changes. Specifically:\nThe UnknownFields() method, which relied on an implicitly created class, is replaced with the explicitly-created UnknownFieldSet class. Some non-core characteristics may have changed, such as the specific format of certain strings or error messages. These are not considered breaking changes, but may still impact your existing code base. Applications that rely on sharing messages between Python and C++ break in the new version. Most developers won’t be affected by this, but users of Nucleus and possibly other libraries may be. As a workaround, you can set an environment variable that forces the library to preserve compatibility. Python upb requires generated code that has been generated from protoc 3.19.0 or newer. JavaScript Support We moved some things around for Protocol Buffer support of JavaScript to allow JavaScript to evolve and release independently of the main repo. Specifically, we decoupled the language support from the main project and moved it into its own repository.\nIf you have created any pull requests related to JavaScript support in Protocol Buffers that you’d still like to merge, feel free to replicate those against the JavaScript repository. We will transfer GitHub issues automatically.\n","categories":"","description":"Changes made to Protocol Buffers on May 6, 2022.","excerpt":"Changes made to Protocol Buffers on May 6, 2022.","ref":"/news/2022-05-06/","tags":"","title":"Changes made on May 6, 2022"},{"body":"Library Breaking Change Policy Google released its OSS Library Breaking Change Policy, which some Google-sponsored open source projects have opted into. Protocol buffers has adopted this policy.\n","categories":"","description":"Changes made to Protocol Buffers on July 6, 2022.","excerpt":"Changes made to Protocol Buffers on July 6, 2022.","ref":"/news/2022-07-06/","tags":"","title":"Changes announced July 6, 2022"},{"body":"This topic covers two areas: general platform support changes, and C++-specific changes that are being considered for the 22.x release line.\nPlatform Support Changes We’ve added guidance about the platforms that we support in this section of the documentation. The section currently covers C++ and PHP, but may be expanded with information about other platforms in the future.\nOfficial C++ Support Matrix With the policy, mentioned earlier in this announcement, of using Google’s official foundational C++ support policy, our C++ compiler and toolchain support matrix will change.\nC++ Changes Following the announcement of our new major version and breaking changes policy, we are planning a major version bump for C++. We plan to make some changes to the assets that we release starting with our 22.x release line.\nThe following sections outline the set of breaking changes that we plan to include in the 22.0 release of protocol buffers. Note that plans can and do change. These are potential breaking changes to be aware of, but they may not happen in this particular release, or they may not happen at all.\nAdding C++20 Support Because of the addition of new keywords to the C++ language, adding support for C++20 is a breaking change for users even if they do not currently use C++20.\nMitigations for this to conditionally change names only in certain compiler modes would break projects that support multiple language standards.\nDropping C++11 Support Per our C++ support policy, we plan to drop C++11 support. This is a breaking change.\nDropping Autotools Support Per our build systems support policy, we plan to drop autotools support. This is a breaking change. After autotools support is dropped, protobuf will support only CMake and Bazel.\nDropping Support for PHP \u003c7.4 Per our PHP support policy, we plan to drop support for EOL versions of PHP. This is not considered a breaking change since these versions are already EOL in the broader ecosystem.\nAdding an Abseil Dependency In order to reduce the Google vs. OSS differences between protobuf and to simplify our own project, we plan to take a formal dependency on Abseil. In time, we plan to start using Abseil types in our public APIs, but simply adding the dependency is a breaking change.\nDropping Language-Specific Source Distributions To reduce dependence on autotools and minimize the number of artifacts we release, we plan to stop publishing language-specific source distributions on our GitHub release page. Instead, we advise users to download the source code distribution automatically generated by GitHub on the release page.\nChanging Maven Release Candidate Artifact Names to Be More Idiomatic In 22.0 we plan to rename Maven artifacts to use “RC” instead of “rc-” as the release candidate prefix.\n","categories":"","description":"Changes made to Protocol Buffers on August 3, 2022.","excerpt":"Changes made to Protocol Buffers on August 3, 2022.","ref":"/news/2022-08-03/","tags":"","title":"Changes announced August 3, 2022"},{"body":" Language Guide (proto2) Language Guide (proto3) Style Guide Encoding Techniques Add-ons ","categories":"","description":"Learn how to use Protocol Buffers in your projects.","excerpt":"Learn how to use Protocol Buffers in your projects.","ref":"/programming-guides/","tags":"","title":"Programming Guides"},{"body":"This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto2 version of the protocol buffers language: for information on proto3 syntax, see the Proto3 Language Guide.\nThis is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.\nDefining A Message Type First let’s look at a very simple example. Let’s say you want to define a search request message format, where each search request has a query string, the particular page of results you are interested in, and a number of results per page. Here’s the .proto file you use to define the message type.\nmessage SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3; } The SearchRequest message definition specifies three fields (name/value pairs), one for each piece of data that you want to include in this type of message. Each field has a name and a type.\nSpecifying Field Types In the above example, all the fields are scalar types: two integers (page_number and result_per_page) and a string (query). You can also specify enumerations and composite types like other message types for your field.\nAssigning Field Numbers As you can see, each field in the message definition has a unique number. These numbers are used to identify your fields in the message binary format, and should not be changed once your message type is in use. Field numbers in the range 1 through 15 take one byte to encode, including the field number and the field’s type (you can find out more about this in Protocol Buffer Encoding). Field numbers in the range 16 through 2047 take two bytes. So you should reserve the field numbers 1 through 15 for message elements that occur very frequently. Remember to leave some room for frequently occurring elements that might be added in the future.\nThe smallest field number you can specify is 1, and the largest is 229 - 1, or 536,870,911. You also cannot use the numbers 19000 through 19999 (FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber), as they are reserved for the Protocol Buffers implementation - the protocol buffer compiler will complain if you use one of these reserved numbers in your .proto. Similarly, you cannot use any previously reserved field numbers.\nSpecifying Field Rules You specify that message fields are one of the following:\nrequired: a well-formed message must have exactly one of this field. optional: a well-formed message can have zero or one of this field (but not more than one). repeated: this field can be repeated any number of times (including zero) in a well-formed message. The order of the repeated values will be preserved. For historical reasons, repeated fields of scalar numeric types (for example, int32, int64, enum) aren’t encoded as efficiently as they could be. New code should use the special option [packed = true] to get a more efficient encoding. For example:\nrepeated int32 samples = 4 [packed = true]; repeated ProtoEnum results = 5 [packed = true]; You can find out more about packed encoding in Protocol Buffer Encoding.\nImportant Required Is Forever You should be very careful about marking fields as required. If at some point you wish to stop writing or sending a required field, it will be problematic to change the field to an optional field – old readers will consider messages without this field to be incomplete and may reject or drop them unintentionally. You should consider writing application-specific custom validation routines for your buffers instead. A second issue with required fields appears when someone adds a value to an enum. In this case, the unrecognized enum value is treated as if it were missing, which also causes the required value check to fail.\nAdding More Message Types Multiple message types can be defined in a single .proto file. This is useful if you are defining multiple related messages – so, for example, if you wanted to define the reply message format that corresponds to your SearchResponse message type, you could add it to the same .proto:\nmessage SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3; } message SearchResponse { ... } Combining Messages leads to bloat While multiple message types (such as message, enum, and service) can be defined in a single .proto file, it can also lead to dependency bloat when large numbers of messages with varying dependencies are defined in a single file. It’s recommended to include as few message types per .proto file as possible.\nAdding Comments To add comments to your .proto files, use C/C++-style // and /* ... */ syntax.\n/* SearchRequest represents a search query, with pagination options to * indicate which results to include in the response. */ message SearchRequest { required string query = 1; optional int32 page_number = 2; // Which page number do we want? optional int32 result_per_page = 3; // Number of results to return per page. } Reserved Fields If you update a message type by entirely removing a field, or commenting it out, future users can reuse the field number when making their own updates to the type. This can cause severe issues if they later load old versions of the same .proto, including data corruption, privacy bugs, and so on. One way to make sure this doesn’t happen is to specify that the field numbers (and/or names, which can also cause issues for JSON serialization) of your deleted fields are reserved. The protocol buffer compiler will complain if any future users try to use these field identifiers.\nmessage Foo { reserved 2, 15, 9 to 11; reserved \"foo\", \"bar\"; } Reserved field number ranges are inclusive (9 to 11 is the same as 9, 10, 11). Note that you can’t mix field names and field numbers in the same reserved statement.\nWhat’s Generated From Your .proto? When you run the protocol buffer compiler on a .proto, the compiler generates the code in your chosen language you’ll need to work with the message types you’ve described in the file, including getting and setting field values, serializing your messages to an output stream, and parsing your messages from an input stream.\nFor C++, the compiler generates a .h and .cc file from each .proto, with a class for each message type described in your file. For Java, the compiler generates a .java file with a class for each message type, as well as special Builder classes for creating message class instances. Python is a little different – the Python compiler generates a module with a static descriptor of each message type in your .proto, which is then used with a metaclass to create the necessary Python data access class at runtime. For Go, the compiler generates a .pb.go file with a type for each message type in your file. You can find out more about using the APIs for each language by following the tutorial for your chosen language. For even more API details, see the relevant API reference.\nScalar Value Types A scalar message field can have one of the following types – the table shows the type specified in the .proto file, and the corresponding type in the automatically generated class:\n.proto Type Notes C++ Type Java Type Python Type[2] Go Type double double double float *float64 float float float float *float32 int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int int *int32 int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 long int/long[3] *int64 uint32 Uses variable-length encoding. uint32 int[1] int/long[3] *uint32 uint64 Uses variable-length encoding. uint64 long[1] int/long[3] *uint64 sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int *int32 sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long[3] *int64 fixed32 Always four bytes. More efficient than uint32 if values are often greater than 228. uint32 int[1] int/long[3] *uint32 fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 256. uint64 long[1] int/long[3] *uint64 sfixed32 Always four bytes. int32 int int *int32 sfixed64 Always eight bytes. int64 long int/long[3] *int64 bool bool boolean bool *bool string A string must always contain UTF-8 encoded text. string String unicode (Python 2) or str (Python 3) *string bytes May contain any arbitrary sequence of bytes. string ByteString bytes []byte You can find out more about how these types are encoded when you serialize your message in Protocol Buffer Encoding.\n[1] In Java, unsigned 32-bit and 64-bit integers are represented using their signed counterparts, with the top bit simply being stored in the sign bit.\n[2] In all cases, setting values to a field will perform type checking to make sure it is valid.\n[3] 64-bit or unsigned 32-bit integers are always represented as long when decoded, but can be an int if an int is given when setting the field. In all cases, the value must fit in the type represented when set. See [2].\nOptional Fields And Default Values As mentioned above, elements in a message description can be labeled optional. A well-formed message may or may not contain an optional element. When a message is parsed, if it does not contain an optional element, accessing the corresponding field in the parsed object returns the default value for that field. The default value can be specified as part of the message description. For example, let’s say you want to provide a default value of 10 for a SearchRequest’s result_per_page value.\noptional int32 result_per_page = 3 [default = 10]; If the default value is not specified for an optional element, a type-specific default value is used instead: for strings, the default value is the empty string. For bytes, the default value is the empty byte string. For bools, the default value is false. For numeric types, the default value is zero. For enums, the default value is the first value listed in the enum’s type definition. This means care must be taken when adding a value to the beginning of an enum value list. See the Updating A Message Type section for guidelines on how to safely change definitions.\nEnumerations When you’re defining a message type, you might want one of its fields to only have one of a pre-defined list of values. For example, let’s say you want to add a corpus field for each SearchRequest, where the corpus can be UNIVERSAL, WEB, IMAGES, LOCAL, NEWS, PRODUCTS or VIDEO. You can do this very simply by adding an enum to your message definition - a field with an enum type can only have one of a specified set of constants as its value (if you try to provide a different value, the parser will treat it like an unknown field). In the following example we’ve added an enum called Corpus with all the possible values, and a field of type Corpus:\nenum Corpus { CORPUS_UNSPECIFIED = 0; CORPUS_UNIVERSAL = 1; CORPUS_WEB = 2; CORPUS_IMAGES = 3; CORPUS_LOCAL = 4; CORPUS_NEWS = 5; CORPUS_PRODUCTS = 6; CORPUS_VIDEO = 7; } message SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3 [default = 10]; optional Corpus corpus = 4 [default = CORPUS_UNIVERSAL]; } You can define aliases by assigning the same value to different enum constants. To do this you need to set the allow_alias option to true. Otherwise, the protocol buffer compiler generates a warning message when aliases are found. Though all alias values are valid during deserialization, the first value is always used when serializing.\nenum EnumAllowingAlias { option allow_alias = true; EAA_UNSPECIFIED = 0; EAA_UNKNOWN = 1; EAA_STARTED = 1; EAA_RUNNING = 2; } enum EnumNotAllowingAlias { ENAA_UNSPECIFIED = 0; ENAA_STARTED = 1; // ENAA_RUNNING = 1; // Uncommenting this line will cause a warning message. ENAA_FINISHED = 2; } Enumerator constants must be in the range of a 32-bit integer. Since enum values use varint encoding on the wire, negative values are inefficient and thus not recommended. You can define enums within a message definition or outside – these enums can be reused in any message definition in your .proto file. You can also use an enum type declared in one message as the type of a field in a different message, using the syntax _MessageType_._EnumType_.\nWhen you run the protocol buffer compiler on a .proto that uses an enum, the generated code will have a corresponding enum for Java or C++, or a special EnumDescriptor class for Python that’s used to create a set of symbolic constants with integer values in the runtime-generated class.\nImportant The generated code may be subject to language-specific limitations on the number of enumerators (low thousands for one language). Review the limitations for the languages you plan to use. Important For information on how enums should work contrasted with how they currently work in different languages, see Enum Behavior. For more information about how to work with message enums in your applications, see the generated code guide for your chosen language.\nReserved Values If you update an enum type by entirely removing an enum entry, or commenting it out, future users can reuse the numeric value when making their own updates to the type. This can cause severe issues if they later load old versions of the same .proto, including data corruption, privacy bugs, and so on. One way to make sure this doesn’t happen is to specify that the numeric values (and/or names, which can also cause issues for JSON serialization) of your deleted entries are reserved. The protocol buffer compiler will complain if any future users try to use these identifiers. You can specify that your reserved numeric value range goes up to the maximum possible value using the max keyword.\nenum Foo { reserved 2, 15, 9 to 11, 40 to max; reserved \"FOO\", \"BAR\"; } Note that you can’t mix field names and numeric values in the same reserved statement.\nUsing Other Message Types You can use other message types as field types. For example, let’s say you wanted to include Result messages in each SearchResponse message – to do this, you can define a Result message type in the same .proto and then specify a field of type Result in SearchResponse:\nmessage SearchResponse { repeated Result result = 1; } message Result { required string url = 1; optional string title = 2; repeated string snippets = 3; } Importing Definitions In the above example, the Result message type is defined in the same file as SearchResponse – what if the message type you want to use as a field type is already defined in another .proto file?\nYou can use definitions from other .proto files by importing them. To import another .proto’s definitions, you add an import statement to the top of your file:\nimport \"myproject/other_protos.proto\"; By default, you can use definitions only from directly imported .proto files. However, sometimes you may need to move a .proto file to a new location. Instead of moving the .proto file directly and updating all the call sites in a single change, you can put a placeholder .proto file in the old location to forward all the imports to the new location using the import public notion.\nNote that the public import functionality is not available in Java.\nimport public dependencies can be transitively relied upon by any code importing the proto containing the import public statement. For example:\n// new.proto // All definitions are moved here // old.proto // This is the proto that all clients are importing. import public \"new.proto\"; import \"other.proto\"; // client.proto import \"old.proto\"; // You use definitions from old.proto and new.proto, but not other.proto The protocol compiler searches for imported files in a set of directories specified on the protocol compiler command line using the -I/--proto_path flag. If no flag was given, it looks in the directory in which the compiler was invoked. In general you should set the --proto_path flag to the root of your project and use fully qualified names for all imports.\nUsing proto3 Message Types It’s possible to import proto3 message types and use them in your proto2 messages, and vice versa. However, proto2 enums cannot be used in proto3 syntax.\nNested Types You can define and use message types inside other message types, as in the following example – here the Result message is defined inside the SearchResponse message:\nmessage SearchResponse { message Result { required string url = 1; optional string title = 2; repeated string snippets = 3; } repeated Result result = 1; } If you want to reuse this message type outside its parent message type, you refer to it as _Parent_._Type_:\nmessage SomeOtherMessage { optional SearchResponse.Result result = 1; } You can nest messages as deeply as you like. In the example below, note that the two nested types named Inner are entirely independent, since they are defined within different messages:\nmessage Outer { // Level 0 message MiddleAA { // Level 1 message Inner { // Level 2 optional int64 ival = 1; optional bool booly = 2; } } message MiddleBB { // Level 1 message Inner { // Level 2 optional string name = 1; optional bool flag = 2; } } } Groups Note that the groups feature is deprecated and should not be used when creating new message types. Use nested message types instead.\nGroups are another way to nest information in your message definitions. For example, another way to specify a SearchResponse containing a number of Results is as follows:\nmessage SearchResponse { repeated group Result = 1 { required string url = 2; optional string title = 3; repeated string snippets = 4; } } A group simply combines a nested message type and a field into a single declaration. In your code, you can treat this message just as if it had a Result type field called result (the latter name is converted to lower-case so that it does not conflict with the former). Therefore, this example is exactly equivalent to the SearchResponse above, except that the message has a different wire format.\nUpdating A Message Type If an existing message type no longer meets all your needs – for example, you’d like the message format to have an extra field – but you’d still like to use code created with the old format, don’t worry! It’s very simple to update message types without breaking any of your existing code when you use the binary wire format.\nNote If you use JSON or proto text format to store your protocol buffer messages, the changes that you can make in your proto definition are different. If your use case isn’t covered in the safe-or-not tool, check Proto Best Practices and the following rules:\nDon’t change the field numbers for any existing fields. Any new fields that you add should be optional or repeated. This means that any messages serialized by code using your “old” message format can be parsed by your new generated code, as they won’t be missing any required elements. You should set up sensible default values for these elements so that new code can properly interact with messages generated by old code. Similarly, messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing. However, the unknown fields are not discarded, and if the message is later serialized, the unknown fields are serialized along with it – so if the message is passed on to new code, the new fields are still available. Non-required fields can be removed, as long as the field number is not used again in your updated message type. You may want to rename the field instead, perhaps adding the prefix “OBSOLETE_”, or make the field number reserved, so that future users of your .proto can’t accidentally reuse the number. A non-required field can be converted to an extension and vice versa, as long as the type and number stay the same. int32, uint32, int64, uint64, and bool are all compatible – this means you can change a field from one of these types to another without breaking forwards- or backwards-compatibility. If a number is parsed from the wire which doesn’t fit in the corresponding type, you will get the same effect as if you had cast the number to that type in C++ (for example, if a 64-bit number is read as an int32, it will be truncated to 32 bits). sint32 and sint64 are compatible with each other but are not compatible with the other integer types. string and bytes are compatible as long as the bytes are valid UTF-8. Embedded messages are compatible with bytes if the bytes contain an encoded version of the message. fixed32 is compatible with sfixed32, and fixed64 with sfixed64. For string, bytes, and message fields, optional is compatible with repeated. Given serialized data of a repeated field as input, clients that expect this field to be optional will take the last input value if it’s a primitive type field or merge all input elements if it’s a message type field. Note that this is not generally safe for numeric types, including bools and enums. Repeated fields of numeric types can be serialized in the packed format, which will not be parsed correctly when an optional field is expected. Changing a default value is generally OK, as long as you remember that default values are never sent over the wire. Thus, if a program receives a message in which a particular field isn’t set, the program will see the default value as it was defined in that program’s version of the protocol. It will NOT see the default value that was defined in the sender’s code. enum is compatible with int32, uint32, int64, and uint64 in terms of wire format (note that values will be truncated if they don’t fit), but be aware that client code may treat them differently when the message is deserialized. Notably, unrecognized enum values are discarded when the message is deserialized, which makes the field’s has.. accessor return false and its getter return the first value listed in the enum definition, or the default value if one is specified. In the case of repeated enum fields, any unrecognized values are stripped out of the list. However, an integer field will always preserve its value. Because of this, you need to be very careful when upgrading an integer to an enum in terms of receiving out of bounds enum values on the wire. In the current Java and C++ implementations, when unrecognized enum values are stripped out, they are stored along with other unknown fields. Note that this can result in strange behavior if this data is serialized and then reparsed by a client that recognizes these values. In the case of optional fields, even if a new value was written after the original message was deserialized, the old value will be still read by clients that recognize it. In the case of repeated fields, the old values will appear after any recognized and newly-added values, which means that order will not be preserved. Changing a single optional field or extension into a member of a new oneof is binary compatible, however for some languages (notably, Go) the generated code’s API will change in incompatible ways. For this reason, Google does not make such changes in its public APIs, as documented in AIP-180. With the same caveat about source-compatibility, moving multiple fields into a new oneof may be safe if you are sure that no code sets more than one at a time. Moving fields into an existing oneof is not safe. Likewise, changing a single field oneof to an optional field or extension is safe. Changing a field between a map\u003cK, V\u003e and the corresponding repeated message field is binary compatible (see Maps, below, for the message layout and other restrictions). However, the safety of the change is application-dependent: when deserializing and reserializing a message, clients using the repeated field definition will produce a semantically identical result; however, clients using the map field definition may reorder entries and drop entries with duplicate keys. Extensions Extensions let you declare that a range of field numbers in a message are available for third-party extensions. An extension is a placeholder for a field whose type is not defined by the original .proto file. This allows other .proto files to add to your message definition by defining the types of some or all of the fields with those field numbers. Let’s look at an example:\nmessage Foo { // ... extensions 100 to 199; } This says that the range of field numbers [100, 199] in Foo is reserved for extensions. Other users can now add new fields to Foo in their own .proto files that import your .proto, using field numbers within your specified range – for example:\nextend Foo { optional int32 bar = 126; } This adds a field named bar with the field number 126 to the original definition of Foo.\nWhen your user’s Foo messages are encoded, the wire format is exactly the same as if the user defined the new field inside Foo. However, the way you access extension fields in your application code is slightly different to accessing regular fields – your generated data access code has special accessors for working with extensions. So, for example, here’s how you set the value of bar in C++:\nFoo foo; foo.SetExtension(bar, 15); Similarly, the Foo class defines templated accessors HasExtension(), ClearExtension(), GetExtension(), MutableExtension(), and AddExtension(). All have semantics matching the corresponding generated accessors for a normal field. For more information about working with extensions, see the generated code reference for your chosen language.\nNote that extensions can be of any field type, including message types, but cannot be oneofs or maps.\nNested Extensions You can declare extensions in the scope of another type:\nmessage Baz { extend Foo { optional int32 bar = 126; } ... } In this case, the C++ code to access this extension is:\nFoo foo; foo.SetExtension(Baz::bar, 15); In other words, the only effect is that bar is defined within the scope of Baz.\nThis is a common source of confusion: Declaring an extend block nested inside a message type does not imply any relationship between the outer type and the extended type. In particular, the above example does not mean that Baz is any sort of subclass of Foo. All it means is that the symbol bar is declared inside the scope of Baz; it’s simply a static member.\nA common pattern is to define extensions inside the scope of the extension’s field type – for example, here’s an extension to Foo of type Baz, where the extension is defined as part of Baz:\nmessage Baz { extend Foo { optional Baz foo_ext = 127; } ... } However, there is no requirement that an extension with a message type be defined inside that type. You can also do this:\nmessage Baz { ... } // This can even be in a different file. extend Foo { optional Baz foo_baz_ext = 127; } In fact, this syntax may be preferred to avoid confusion. As mentioned above, the nested syntax is often mistaken for subclassing by users who are not already familiar with extensions.\nChoosing Extension Numbers It’s very important to make sure that two users don’t add extensions to the same message type using the same field number – data corruption can result if an extension is accidentally interpreted as the wrong type. You may want to consider defining an extension numbering convention for your project to prevent this happening.\nIf your numbering convention might involve extensions having very large field numbers, you can specify that your extension range goes up to the maximum possible field number using the max keyword:\nmessage Foo { extensions 1000 to max; } max is 229 - 1, or 536,870,911.\nAs when choosing field numbers in general, your numbering convention also needs to avoid field numbers 19000 though 19999 (FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber), as they are reserved for the Protocol Buffers implementation. You can define an extension range that includes this range, but the protocol compiler will not allow you to define actual extensions with these numbers.\nOneof If you have a message with many optional fields and where at most one field will be set at the same time, you can enforce this behavior and save memory by using the oneof feature.\nOneof fields are like optional fields except all the fields in a oneof share memory, and at most one field can be set at the same time. Setting any member of the oneof automatically clears all the other members. You can check which value in a oneof is set (if any) using a special case() or WhichOneof() method, depending on your chosen language.\nUsing Oneof To define a oneof in your .proto you use the oneof keyword followed by your oneof name, in this case test_oneof:\nmessage SampleMessage { oneof test_oneof { string name = 4; SubMessage sub_message = 9; } } You then add your oneof fields to the oneof definition. You can add fields of any type, but cannot use the required, optional, or repeated keywords. If you need to add a repeated field to a oneof, you can use a message containing the repeated field.\nIn your generated code, oneof fields have the same getters and setters as regular optional methods. You also get a special method for checking which value (if any) in the oneof is set. You can find out more about the oneof API for your chosen language in the relevant API reference.\nOneof Features Setting a oneof field will automatically clear all other members of the oneof. So if you set several oneof fields, only the last field you set will still have a value.\nSampleMessage message; message.set_name(\"name\"); CHECK(message.has_name()); message.mutable_sub_message(); // Will clear name field. CHECK(!message.has_name()); If the parser encounters multiple members of the same oneof on the wire, only the last member seen is used in the parsed message.\nExtensions are not supported for oneof.\nA oneof cannot be repeated.\nReflection APIs work for oneof fields.\nIf you set a oneof field to the default value (such as setting an int32 oneof field to 0), the “case” of that oneof field will be set, and the value will be serialized on the wire.\nIf you’re using C++, make sure your code doesn’t cause memory crashes. The following sample code will crash because sub_message was already deleted by calling the set_name() method.\nSampleMessage message; SubMessage* sub_message = message.mutable_sub_message(); message.set_name(\"name\"); // Will delete sub_message sub_message-\u003eset_... // Crashes here Again in C++, if you Swap() two messages with oneofs, each message will end up with the other’s oneof case: in the example below, msg1 will have a sub_message and msg2 will have a name.\nSampleMessage msg1; msg1.set_name(\"name\"); SampleMessage msg2; msg2.mutable_sub_message(); msg1.swap(\u0026msg2); CHECK(msg1.has_sub_message()); CHECK(msg2.has_name()); Backwards-compatibility issues Be careful when adding or removing oneof fields. If checking the value of a oneof returns None/NOT_SET, it could mean that the oneof has not been set or it has been set to a field in a different version of the oneof. There is no way to tell the difference, since there’s no way to know if an unknown field on the wire is a member of the oneof.\nTag Reuse Issues Move optional fields into or out of a oneof: You may lose some of your information (some fields will be cleared) after the message is serialized and parsed. However, you can safely move a single field into a new oneof and may be able to move multiple fields if it is known that only one is ever set. See Updating A Message Type for further details. Delete a oneof field and add it back: This may clear your currently set oneof field after the message is serialized and parsed. Split or merge oneof: This has similar issues to moving regular optional fields. Maps If you want to create an associative map as part of your data definition, protocol buffers provides a handy shortcut syntax:\nmap\u003ckey_type, value_type\u003e map_field = N; …where the key_type can be any integral or string type (so, any scalar type except for floating point types and bytes). Note that enum is not a valid key_type. The value_type can be any type except another map.\nSo, for example, if you wanted to create a map of projects where each Project message is associated with a string key, you could define it like this:\nmap\u003cstring, Project\u003e projects = 3; The generated map API is currently available for all proto2 supported languages. You can find out more about the map API for your chosen language in the relevant API reference.\nMaps Features Extensions are not supported for maps. Maps cannot be repeated, optional, or required. Wire format ordering and map iteration ordering of map values is undefined, so you cannot rely on your map items being in a particular order. When generating text format for a .proto, maps are sorted by key. Numeric keys are sorted numerically. When parsing from the wire or when merging, if there are duplicate map keys the last key seen is used. When parsing a map from text format, parsing may fail if there are duplicate keys. Backwards compatibility The map syntax is equivalent to the following on the wire, so protocol buffers implementations that do not support maps can still handle your data:\nmessage MapFieldEntry { optional key_type key = 1; optional value_type value = 2; } repeated MapFieldEntry map_field = N; Any protocol buffers implementation that supports maps must both produce and accept data that can be accepted by the above definition.\nPackages You can add an optional package specifier to a .proto file to prevent name clashes between protocol message types.\npackage foo.bar; message Open { ... } You can then use the package specifier when defining fields of your message type:\nmessage Foo { ... required foo.bar.Open open = 1; ... } The way a package specifier affects the generated code depends on your chosen language:\nIn C++ the generated classes are wrapped inside a C++ namespace. For example, Open would be in the namespace foo::bar. In Java, the package is used as the Java package, unless you explicitly provide a option java_package in your .proto file. In Python, the package directive is ignored, since Python modules are organized according to their location in the file system. In Go, the package directive is ignored, and the generated .pb.go file is in the package named after the corresponding go_proto_library rule. Note that even when the package directive does not directly affect the generated code, for example in Python, it is still strongly recommended to specify the package for the .proto file, as otherwise it may lead to naming conflicts in descriptors and make the proto not portable for other languages.\nPackages and Name Resolution Type name resolution in the protocol buffer language works like C++: first the innermost scope is searched, then the next-innermost, and so on, with each package considered to be “inner” to its parent package. A leading ‘.’ (for example, .foo.bar.Baz) means to start from the outermost scope instead.\nThe protocol buffer compiler resolves all type names by parsing the imported .proto files. The code generator for each language knows how to refer to each type in that language, even if it has different scoping rules.\nDefining Services If you want to use your message types with an RPC (Remote Procedure Call) system, you can define an RPC service interface in a .proto file and the protocol buffer compiler will generate service interface code and stubs in your chosen language. So, for example, if you want to define an RPC service with a method that takes your SearchRequest and returns a SearchResponse, you can define it in your .proto file as follows:\nservice SearchService { rpc Search(SearchRequest) returns (SearchResponse); } By default, the protocol compiler will then generate an abstract interface called SearchService and a corresponding “stub” implementation. The stub forwards all calls to an RpcChannel, which in turn is an abstract interface that you must define yourself in terms of your own RPC system. For example, you might implement an RpcChannel which serializes the message and sends it to a server via HTTP. In other words, the generated stub provides a type-safe interface for making protocol-buffer-based RPC calls, without locking you into any particular RPC implementation. So, in C++, you might end up with code like this:\nusing google::protobuf; protobuf::RpcChannel* channel; protobuf::RpcController* controller; SearchService* service; SearchRequest request; SearchResponse response; void DoSearch() { // You provide classes MyRpcChannel and MyRpcController, which implement // the abstract interfaces protobuf::RpcChannel and protobuf::RpcController. channel = new MyRpcChannel(\"somehost.example.com:1234\"); controller = new MyRpcController; // The protocol compiler generates the SearchService class based on the // definition given above. service = new SearchService::Stub(channel); // Set up the request. request.set_query(\"protocol buffers\"); // Execute the RPC. service-\u003eSearch(controller, \u0026request, \u0026response, protobuf::NewCallback(\u0026Done)); } void Done() { delete service; delete channel; delete controller; } All service classes also implement the Service interface, which provides a way to call specific methods without knowing the method name or its input and output types at compile time. On the server side, this can be used to implement an RPC server with which you could register services.\nusing google::protobuf; class ExampleSearchService : public SearchService { public: void Search(protobuf::RpcController* controller, const SearchRequest* request, SearchResponse* response, protobuf::Closure* done) { if (request-\u003equery() == \"google\") { response-\u003eadd_result()-\u003eset_url(\"http://www.google.com\"); } else if (request-\u003equery() == \"protocol buffers\") { response-\u003eadd_result()-\u003eset_url(\"http://protobuf.googlecode.com\"); } done-\u003eRun(); } }; int main() { // You provide class MyRpcServer. It does not have to implement any // particular interface; this is just an example. MyRpcServer server; protobuf::Service* service = new ExampleSearchService; server.ExportOnPort(1234, service); server.Run(); delete service; return 0; } If you don’t want to plug in your own existing RPC system, you can now use gRPC: a language- and platform-neutral open source RPC system developed at Google. gRPC works particularly well with protocol buffers and lets you generate the relevant RPC code directly from your .proto files using a special protocol buffer compiler plugin. However, as there are potential compatibility issues between clients and servers generated with proto2 and proto3, we recommend that you use proto3 for defining gRPC services. You can find out more about proto3 syntax in the Proto3 Language Guide. If you do want to use proto2 with gRPC, you need to use version 3.0.0 or higher of the protocol buffers compiler and libraries.\nIn addition to gRPC, there are also a number of ongoing third-party projects to develop RPC implementations for Protocol Buffers. For a list of links to projects we know about, see the third-party add-ons wiki page.\nOptions Individual declarations in a .proto file can be annotated with a number of options. Options do not change the overall meaning of a declaration, but may affect the way it is handled in a particular context. The complete list of available options is defined in /google/protobuf/descriptor.proto.\nSome options are file-level options, meaning they should be written at the top-level scope, not inside any message, enum, or service definition. Some options are message-level options, meaning they should be written inside message definitions. Some options are field-level options, meaning they should be written inside field definitions. Options can also be written on enum types, enum values, oneof fields, service types, and service methods; however, no useful options currently exist for any of these.\nHere are a few of the most commonly used options:\njava_package (file option): The package you want to use for your generated Java classes. If no explicit java_package option is given in the .proto file, then by default the proto package (specified using the “package” keyword in the .proto file) will be used. However, proto packages generally do not make good Java packages since proto packages are not expected to start with reverse domain names. If not generating Java code, this option has no effect.\noption java_package = \"com.example.foo\"; java_outer_classname (file option): The class name (and hence the file name) for the wrapper Java class you want to generate. If no explicit java_outer_classname is specified in the .proto file, the class name will be constructed by converting the .proto file name to camel-case (so foo_bar.proto becomes FooBar.java). If the java_multiple_files option is disabled, then all other classes/enums/etc. generated for the .proto file will be generated within this outer wrapper Java class as nested classes/enums/etc. If not generating Java code, this option has no effect.\noption java_outer_classname = \"Ponycopter\"; java_multiple_files (file option): If false, only a single .java file will be generated for this .proto file, and all the Java classes/enums/etc. generated for the top-level messages, services, and enumerations will be nested inside of an outer class (see java_outer_classname). If true, separate .java files will be generated for each of the Java classes/enums/etc. generated for the top-level messages, services, and enumerations, and the wrapper Java class generated for this .proto file won’t contain any nested classes/enums/etc. This is a Boolean option which defaults to false. If not generating Java code, this option has no effect.\noption java_multiple_files = true; optimize_for (file option): Can be set to SPEED, CODE_SIZE, or LITE_RUNTIME. This affects the C++ and Java code generators (and possibly third-party generators) in the following ways:\nSPEED (default): The protocol buffer compiler will generate code for serializing, parsing, and performing other common operations on your message types. This code is highly optimized. CODE_SIZE: The protocol buffer compiler will generate minimal classes and will rely on shared, reflection-based code to implement serialialization, parsing, and various other operations. The generated code will thus be much smaller than with SPEED, but operations will be slower. Classes will still implement exactly the same public API as they do in SPEED mode. This mode is most useful in apps that contain a very large number of .proto files and do not need all of them to be blindingly fast. LITE_RUNTIME: The protocol buffer compiler will generate classes that depend only on the “lite” runtime library (libprotobuf-lite instead of libprotobuf). The lite runtime is much smaller than the full library (around an order of magnitude smaller) but omits certain features like descriptors and reflection. This is particularly useful for apps running on constrained platforms like mobile phones. The compiler will still generate fast implementations of all methods as it does in SPEED mode. Generated classes will only implement the MessageLite interface in each language, which provides only a subset of the methods of the full Message interface. option optimize_for = CODE_SIZE; cc_generic_services, java_generic_services, py_generic_services (file options): Whether or not the protocol buffer compiler should generate abstract service code based on services definitions in C++, Java, and Python, respectively. For legacy reasons, these default to true. However, as of version 2.3.0 (January 2010), it is considered preferrable for RPC implementations to provide code generator plugins to generate code more specific to each system, rather than rely on the “abstract” services.\n// This file relies on plugins to generate service code. option cc_generic_services = false; option java_generic_services = false; option py_generic_services = false; cc_enable_arenas (file option): Enables arena allocation for C++ generated code.\nmessage_set_wire_format (message option): If set to true, the message uses a different binary format intended to be compatible with an old format used inside Google called MessageSet. Users outside Google will probably never need to use this option. The message must be declared exactly as follows:\nmessage Foo { option message_set_wire_format = true; extensions 4 to max; } packed (field option): If set to true on a repeated field of a basic numeric type, a more compact encoding is used. There is no downside to using this option. However, note that prior to version 2.3.0, parsers that received packed data when not expected would ignore it. Therefore, it was not possible to change an existing field to packed format without breaking wire compatibility. In 2.3.0 and later, this change is safe, as parsers for packable fields will always accept both formats, but be careful if you have to deal with old programs using old protobuf versions.\nrepeated int32 samples = 4 [packed = true]; deprecated (field option): If set to true, indicates that the field is deprecated and should not be used by new code. In most languages this has no actual effect. In Java, this becomes a @Deprecated annotation. For C++, clang-tidy will generate warnings whenever deprecated fields are used. In the future, other language-specific code generators may generate deprecation annotations on the field’s accessors, which will in turn cause a warning to be emitted when compiling code which attempts to use the field. If the field is not used by anyone and you want to prevent new users from using it, consider replacing the field declaration with a reserved statement.\noptional int32 old_field = 6 [deprecated=true]; Custom Options Protocol Buffers even allow you to define and use your own options. Note that this is an advanced feature which most people don’t need. Since options are defined by the messages defined in google/protobuf/descriptor.proto (like FileOptions or FieldOptions), defining your own options is simply a matter of extending those messages. For example:\nimport \"google/protobuf/descriptor.proto\"; extend google.protobuf.MessageOptions { optional string my_option = 51234; } message MyMessage { option (my_option) = \"Hello world!\"; } Here we have defined a new message-level option by extending MessageOptions. When we then use the option, the option name must be enclosed in parentheses to indicate that it is an extension. We can now read the value of my_option in C++ like so:\nstring value = MyMessage::descriptor()-\u003eoptions().GetExtension(my_option); Here, MyMessage::descriptor()-\u003eoptions() returns the MessageOptions protocol message for MyMessage. Reading custom options from it is just like reading any other extension.\nSimilarly, in Java we would write:\nString value = MyProtoFile.MyMessage.getDescriptor().getOptions() .getExtension(MyProtoFile.myOption); In Python it would be:\nvalue = my_proto_file_pb2.MyMessage.DESCRIPTOR.GetOptions() .Extensions[my_proto_file_pb2.my_option] Custom options can be defined for every kind of construct in the Protocol Buffers language. Here is an example that uses every kind of option:\nimport \"google/protobuf/descriptor.proto\"; extend google.protobuf.FileOptions { optional string my_file_option = 50000; } extend google.protobuf.MessageOptions { optional int32 my_message_option = 50001; } extend google.protobuf.FieldOptions { optional float my_field_option = 50002; } extend google.protobuf.OneofOptions { optional int64 my_oneof_option = 50003; } extend google.protobuf.EnumOptions { optional bool my_enum_option = 50004; } extend google.protobuf.EnumValueOptions { optional uint32 my_enum_value_option = 50005; } extend google.protobuf.ServiceOptions { optional MyEnum my_service_option = 50006; } extend google.protobuf.MethodOptions { optional MyMessage my_method_option = 50007; } option (my_file_option) = \"Hello world!\"; message MyMessage { option (my_message_option) = 1234; optional int32 foo = 1 [(my_field_option) = 4.5]; optional string bar = 2; oneof qux { option (my_oneof_option) = 42; string quux = 3; } } enum MyEnum { option (my_enum_option) = true; FOO = 1 [(my_enum_value_option) = 321]; BAR = 2; } message RequestType {} message ResponseType {} service MyService { option (my_service_option) = FOO; rpc MyMethod(RequestType) returns(ResponseType) { // Note: my_method_option has type MyMessage. We can set each field // within it using a separate \"option\" line. option (my_method_option).foo = 567; option (my_method_option).bar = \"Some string\"; } } Note that if you want to use a custom option in a package other than the one in which it was defined, you must prefix the option name with the package name, just as you would for type names. For example:\n// foo.proto import \"google/protobuf/descriptor.proto\"; package foo; extend google.protobuf.MessageOptions { optional string my_option = 51234; } // bar.proto import \"foo.proto\"; package bar; message MyMessage { option (foo.my_option) = \"Hello world!\"; } One last thing: Since custom options are extensions, they must be assigned field numbers like any other field or extension. In the examples above, we have used field numbers in the range 50000-99999. This range is reserved for internal use within individual organizations, so you can use numbers in this range freely for in-house applications. If you intend to use custom options in public applications, however, then it is important that you make sure that your field numbers are globally unique. To obtain globally unique field numbers, send a request to add an entry to protobuf global extension registry. Usually you only need one extension number. You can declare multiple options with only one extension number by putting them in a sub-message:\nmessage FooOptions { optional int32 opt1 = 1; optional string opt2 = 2; } extend google.protobuf.FieldOptions { optional FooOptions foo_options = 1234; } // usage: message Bar { optional int32 a = 1 [(foo_options).opt1 = 123, (foo_options).opt2 = \"baz\"]; // alternative aggregate syntax (uses TextFormat): optional int32 b = 2 [(foo_options) = { opt1: 123 opt2: \"baz\" }]; } Also, note that each option type (file-level, message-level, field-level, etc.) has its own number space, so, for example, you could declare extensions of FieldOptions and MessageOptions with the same number.\nOption Retention Options have a notion of retention, which controls whether an option is retained in the generated code. Options have runtime retention by default, meaning that they are retained in the generated code and are thus visible at runtime in the generated descriptor pool. However, you can set retention = RETENTION_SOURCE to specify that an option (or field within an option) must not be retained at runtime. This is called source retention.\nOption retention is an advanced feature that most users should not need to worry about, but it can be useful if you would like to use certain options without paying the code size cost of retaining them in your binaries. Options with source retention are still visible to protoc and protoc plugins, so code generators can use them to customize their behavior.\nRetention can be set directly on an option, like this;\nextend google.protobuf.FileOptions { optional int32 source_retention_option = 1234 [retention = RETENTION_SOURCE]; } It can also be set on a plain field, in which case it takes effect only when that field appears inside an option:\nmessage OptionsMessage { optional int32 source_retention_field = 1 [retention = RETENTION_SOURCE]; } You can set retention = RETENTION_RUNTIME if you like, but this has no effect since it is the default behavior. When a message field is marked RETENTION_SOURCE, its entire contents are dropped; fields inside it cannot override that by trying to set RETENTION_RUNTIME.\nNote As of Protocol Buffers 22.0, support for option retention is still in progress and only C++ and Java are supported. In all other languages, options are always retained at runtime. Generating Your Classes To generate the Java, Python, or C++ code you need to work with the message types defined in a .proto file, you need to run the protocol buffer compiler protoc on the .proto. If you haven’t installed the compiler, download the package and follow the instructions in the README.\nThe Protocol Compiler is invoked as follows:\nprotoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto IMPORT_PATH specifies a directory in which to look for .proto files when resolving import directives. If omitted, the current directory is used. Multiple import directories can be specified by passing the --proto_path option multiple times; they will be searched in order. -I=_IMPORT_PATH_ can be used as a short form of --proto_path.\nYou can provide one or more output directives:\n--cpp_out generates C++ code in DST_DIR. See the C++ generated code reference for more. --java_out generates Java code in DST_DIR. See the Java generated code reference for more. --python_out generates Python code in DST_DIR. See the Python generated code reference for more. As an extra convenience, if the DST_DIR ends in .zip or .jar, the compiler will write the output to a single ZIP-format archive file with the given name. .jar outputs will also be given a manifest file as required by the Java JAR specification. Note that if the output archive already exists, it will be overwritten; the compiler is not smart enough to add files to an existing archive.\nYou must provide one or more .proto files as input. Multiple .proto files can be specified at once. Although the files are named relative to the current directory, each file must reside in one of the IMPORT_PATHs so that the compiler can determine its canonical name.\nFile location Prefer not to put .proto files in the same directory as other language sources. Consider creating a subpackage proto for .proto files, under the root package for your project.\nLocation Should be Language-agnostic When working with Java code, it’s handy to put related .proto files in the same directory as the Java source. However, if any non-Java code ever uses the same protos, the path prefix will no longer make sense. So in general, put the protos in a related language-agnostic directory such as //myteam/mypackage.\nThe exception to this rule is when it’s clear that the protos will be used only in a Java context, such as for testing.\nSupported Platforms For information about:\nthe operating systems, compilers, build systems, and C++ versions that are supported, see Foundational C++ Support Policy. the PHP versions that are supported, see Supported PHP versions. ","categories":"","description":"This topic covers how to use the version 2 of Protocol Buffers in your project. It contains language-agnostic content. For information specific to the language you're using, see the corresponding documentation for your language.","excerpt":"This topic covers how to use the version 2 of Protocol Buffers in your …","ref":"/programming-guides/proto2/","tags":"","title":"Language Guide (proto 2)"},{"body":"This guide describes how to use the protocol buffer language to structure your protocol buffer data, including .proto file syntax and how to generate data access classes from your .proto files. It covers the proto3 version of the protocol buffers language: for information on the proto2 syntax, see the Proto2 Language Guide.\nThis is a reference guide – for a step by step example that uses many of the features described in this document, see the tutorial for your chosen language.\nDefining A Message Type First let’s look at a very simple example. Let’s say you want to define a search request message format, where each search request has a query string, the particular page of results you are interested in, and a number of results per page. Here’s the .proto file you use to define the message type.\nsyntax = \"proto3\"; message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } The first line of the file specifies that you’re using proto3 syntax: if you don’t do this the protocol buffer compiler will assume you are using proto2. This must be the first non-empty, non-comment line of the file. The SearchRequest message definition specifies three fields (name/value pairs), one for each piece of data that you want to include in this type of message. Each field has a name and a type. Specifying Field Types In the above example, all the fields are scalar types: two integers (page_number and result_per_page) and a string (query). However, you can also specify composite types for your fields, including enumerations and other message types.\nAssigning Field Numbers As you can see, each field in the message definition has a unique number. These field numbers are used to identify your fields in the message binary format, and should not be changed once your message type is in use. Note that field numbers in the range 1 through 15 take one byte to encode, including the field number and the field’s type (you can find out more about this in Protocol Buffer Encoding). Field numbers in the range 16 through 2047 take two bytes. So you should reserve the numbers 1 through 15 for very frequently occurring message elements. Remember to leave some room for frequently occurring elements that might be added in the future.\nThe smallest field number you can specify is 1, and the largest is 229 - 1, or 536,870,911. You also cannot use the numbers 19000 through 19999 (FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber), as they are reserved for the Protocol Buffers implementation—the protocol buffer compiler will complain if you use one of these reserved numbers in your .proto. Similarly, you cannot use any previously reserved field numbers.\nSpecifying Field Rules Message fields can be one of the following:\nsingular: a well-formed message can have zero or one of this field (but not more than one). When using proto3 syntax, this is the default field rule when no other field rules are specified for a given field. You cannot determine whether it was parsed from the wire. It will be serialized to the wire unless it is the default value. For more on this subject, see Field Presence. optional: the same as singular, except that you can check to see if the value was explicitly set. An optional field is in one of two possible states: the field is set, and contains a value that was explicitly set or parsed from the wire. It will be serialized to the wire. the field is unset, and will return the default value. It will not be serialized to the wire. repeated: this field type can be repeated zero or more times in a well-formed message. The order of the repeated values will be preserved. map: this is a paired key/value field type. See Maps for more on this field type. In proto3, repeated fields of scalar numeric types use packed encoding by default. You can find out more about packed encoding in Protocol Buffer Encoding.\nAdding More Message Types Multiple message types can be defined in a single .proto file. This is useful if you are defining multiple related messages – so, for example, if you wanted to define the reply message format that corresponds to your SearchResponse message type, you could add it to the same .proto:\nmessage SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; } message SearchResponse { ... } Adding Comments To add comments to your .proto files, use C/C++-style // and /* ... */ syntax.\n/* SearchRequest represents a search query, with pagination options to * indicate which results to include in the response. */ message SearchRequest { string query = 1; int32 page_number = 2; // Which page number do we want? int32 result_per_page = 3; // Number of results to return per page. } Reserved Fields If you update a message type by entirely removing a field, or commenting it out, future users can reuse the field number when making their own updates to the type. This can cause severe issues if they later load old versions of the same .proto, including data corruption, privacy bugs, and so on. One way to make sure this doesn’t happen is to specify that the field numbers (and/or names, which can also cause issues for JSON serialization) of your deleted fields are reserved. The protocol buffer compiler will complain if any future users try to use these field identifiers.\nmessage Foo { reserved 2, 15, 9 to 11; reserved \"foo\", \"bar\"; } Note that you can’t mix field names and field numbers in the same reserved statement.\nWhat’s Generated From Your .proto? When you run the protocol buffer compiler on a .proto, the compiler generates the code in your chosen language you’ll need to work with the message types you’ve described in the file, including getting and setting field values, serializing your messages to an output stream, and parsing your messages from an input stream.\nFor C++, the compiler generates a .h and .cc file from each .proto, with a class for each message type described in your file. For Java, the compiler generates a .java file with a class for each message type, as well as a special Builder class for creating message class instances. For Kotlin, in addition to the Java generated code, the compiler generates a .kt file for each message type, containing a DSL which can be used to simplify creating message instances. Python is a little different — the Python compiler generates a module with a static descriptor of each message type in your .proto, which is then used with a metaclass to create the necessary Python data access class at runtime. For Go, the compiler generates a .pb.go file with a type for each message type in your file. For Ruby, the compiler generates a .rb file with a Ruby module containing your message types. For Objective-C, the compiler generates a pbobjc.h and pbobjc.m file from each .proto, with a class for each message type described in your file. For C#, the compiler generates a .cs file from each .proto, with a class for each message type described in your file. For Dart, the compiler generates a .pb.dart file with a class for each message type in your file. You can find out more about using the APIs for each language by following the tutorial for your chosen language (proto3 versions coming soon). For even more API details, see the relevant API reference (proto3 versions also coming soon).\nScalar Value Types A scalar message field can have one of the following types – the table shows the type specified in the .proto file, and the corresponding type in the automatically generated class:\n.proto Type Notes C++ Type Java/Kotlin Type[1] Python Type[3] Go Type Ruby Type C# Type PHP Type Dart Type double double double float float64 Float double float double float float float float float32 Float float float double int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32 int int int32 Fixnum or Bignum (as required) int integer int int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64 long int/long[4] int64 Bignum long integer/string[6] Int64 uint32 Uses variable-length encoding. uint32 int[2] int/long[4] uint32 Fixnum or Bignum (as required) uint integer int uint64 Uses variable-length encoding. uint64 long[2] int/long[4] uint64 Bignum ulong integer/string[6] Int64 sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 Fixnum or Bignum (as required) int integer int sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long[4] int64 Bignum long integer/string[6] Int64 fixed32 Always four bytes. More efficient than uint32 if values are often greater than 228. uint32 int[2] int/long[4] uint32 Fixnum or Bignum (as required) uint integer int fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 256. uint64 long[2] int/long[4] uint64 Bignum ulong integer/string[6] Int64 sfixed32 Always four bytes. int32 int int int32 Fixnum or Bignum (as required) int integer int sfixed64 Always eight bytes. int64 long int/long[4] int64 Bignum long integer/string[6] Int64 bool bool boolean bool bool TrueClass/FalseClass bool boolean bool string A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232. string String str/unicode[5] string String (UTF-8) string string String bytes May contain any arbitrary sequence of bytes no longer than 232. string ByteString str (Python 2)bytes (Python 3) []byte String (ASCII-8BIT) ByteString string List You can find out more about how these types are encoded when you serialize your message in Protocol Buffer Encoding.\n[1] Kotlin uses the corresponding types from Java, even for unsigned types, to ensure compatibility in mixed Java/Kotlin codebases.\n[2] In Java, unsigned 32-bit and 64-bit integers are represented using their signed counterparts, with the top bit simply being stored in the sign bit.\n[3] In all cases, setting values to a field will perform type checking to make sure it is valid.\n[4] 64-bit or unsigned 32-bit integers are always represented as long when decoded, but can be an int if an int is given when setting the field. In all cases, the value must fit in the type represented when set. See [2].\n[5] Python strings are represented as unicode on decode but can be str if an ASCII string is given (this is subject to change).\n[6] Integer is used on 64-bit machines and string is used on 32-bit machines.\nDefault Values When a message is parsed, if the encoded message does not contain a particular singular element, the corresponding field in the parsed object is set to the default value for that field. These defaults are type-specific:\nFor strings, the default value is the empty string. For bytes, the default value is empty bytes. For bools, the default value is false. For numeric types, the default value is zero. For enums, the default value is the first defined enum value, which must be 0. For message fields, the field is not set. Its exact value is language-dependent. See the generated code guide for details. The default value for repeated fields is empty (generally an empty list in the appropriate language).\nNote that for scalar message fields, once a message is parsed there’s no way of telling whether a field was explicitly set to the default value (for example whether a boolean was set to false) or just not set at all: you should bear this in mind when defining your message types. For example, don’t have a boolean that switches on some behavior when set to false if you don’t want that behavior to also happen by default. Also note that if a scalar message field is set to its default, the value will not be serialized on the wire.\nSee the generated code guide for your chosen language for more details about how defaults work in generated code.\nEnumerations When you’re defining a message type, you might want one of its fields to only have one of a pre-defined list of values. For example, let’s say you want to add a corpus field for each SearchRequest, where the corpus can be UNIVERSAL, WEB, IMAGES, LOCAL, NEWS, PRODUCTS or VIDEO. You can do this very simply by adding an enum to your message definition with a constant for each possible value.\nIn the following example we’ve added an enum called Corpus with all the possible values, and a field of type Corpus:\nenum Corpus { CORPUS_UNSPECIFIED = 0; CORPUS_UNIVERSAL = 1; CORPUS_WEB = 2; CORPUS_IMAGES = 3; CORPUS_LOCAL = 4; CORPUS_NEWS = 5; CORPUS_PRODUCTS = 6; CORPUS_VIDEO = 7; } message SearchRequest { string query = 1; int32 page_number = 2; int32 result_per_page = 3; Corpus corpus = 4; } As you can see, the Corpus enum’s first constant maps to zero: every enum definition must contain a constant that maps to zero as its first element. This is because:\nThere must be a zero value, so that we can use 0 as a numeric default value. The zero value needs to be the first element, for compatibility with the proto2 semantics where the first enum value is always the default. You can define aliases by assigning the same value to different enum constants. To do this you need to set the allow_alias option to true, otherwise the protocol compiler generates a warning message when aliases are found. Though all alias values are valid during deserialization, the first value is always used when serializing.\nenum EnumAllowingAlias { option allow_alias = true; EAA_UNSPECIFIED = 0; EAA_STARTED = 1; EAA_RUNNING = 1; EAA_FINISHED = 2; } enum EnumNotAllowingAlias { ENAA_UNSPECIFIED = 0; ENAA_STARTED = 1; // ENAA_RUNNING = 1; // Uncommenting this line will cause a warning message. ENAA_FINISHED = 2; } Enumerator constants must be in the range of a 32-bit integer. Since enum values use varint encoding on the wire, negative values are inefficient and thus not recommended. You can define enums within a message definition, as in the above example, or outside – these enums can be reused in any message definition in your .proto file. You can also use an enum type declared in one message as the type of a field in a different message, using the syntax _MessageType_._EnumType_.\nWhen you run the protocol buffer compiler on a .proto that uses an enum, the generated code will have a corresponding enum for Java, Kotlin, or C++, or a special EnumDescriptor class for Python that’s used to create a set of symbolic constants with integer values in the runtime-generated class.\nImportant The generated code may be subject to language-specific limitations on the number of enumerators (low thousands for one language). Review the limitations for the languages you plan to use. During deserialization, unrecognized enum values will be preserved in the message, though how this is represented when the message is deserialized is language-dependent. In languages that support open enum types with values outside the range of specified symbols, such as C++ and Go, the unknown enum value is simply stored as its underlying integer representation. In languages with closed enum types such as Java, a case in the enum is used to represent an unrecognized value, and the underlying integer can be accessed with special accessors. In either case, if the message is serialized the unrecognized value will still be serialized with the message.\nImportant For information on how enums should work contrasted with how they currently work in different languages, see Enum Behavior. For more information about how to work with message enums in your applications, see the generated code guide for your chosen language.\nReserved Values If you update an enum type by entirely removing an enum entry, or commenting it out, future users can reuse the numeric value when making their own updates to the type. This can cause severe issues if they later load old versions of the same .proto, including data corruption, privacy bugs, and so on. One way to make sure this doesn’t happen is to specify that the numeric values (and/or names, which can also cause issues for JSON serialization) of your deleted entries are reserved. The protocol buffer compiler will complain if any future users try to use these identifiers. You can specify that your reserved numeric value range goes up to the maximum possible value using the max keyword.\nenum Foo { reserved 2, 15, 9 to 11, 40 to max; reserved \"FOO\", \"BAR\"; } Note that you can’t mix field names and numeric values in the same reserved statement.\nUsing Other Message Types You can use other message types as field types. For example, let’s say you wanted to include Result messages in each SearchResponse message – to do this, you can define a Result message type in the same .proto and then specify a field of type Result in SearchResponse:\nmessage SearchResponse { repeated Result results = 1; } message Result { string url = 1; string title = 2; repeated string snippets = 3; } Importing Definitions In the above example, the Result message type is defined in the same file as SearchResponse – what if the message type you want to use as a field type is already defined in another .proto file?\nYou can use definitions from other .proto files by importing them. To import another .proto’s definitions, you add an import statement to the top of your file:\nimport \"myproject/other_protos.proto\"; By default, you can use definitions only from directly imported .proto files. However, sometimes you may need to move a .proto file to a new location. Instead of moving the .proto file directly and updating all the call sites in a single change, you can put a placeholder .proto file in the old location to forward all the imports to the new location using the import public notion.\nNote that the public import functionality is not available in Java.\nimport public dependencies can be transitively relied upon by any code importing the proto containing the import public statement. For example:\n// new.proto // All definitions are moved here // old.proto // This is the proto that all clients are importing. import public \"new.proto\"; import \"other.proto\"; // client.proto import \"old.proto\"; // You use definitions from old.proto and new.proto, but not other.proto The protocol compiler searches for imported files in a set of directories specified on the protocol compiler command line using the -I/--proto_path flag. If no flag was given, it looks in the directory in which the compiler was invoked. In general you should set the --proto_path flag to the root of your project and use fully qualified names for all imports.\nUsing proto2 Message Types It’s possible to import proto2 message types and use them in your proto3 messages, and vice versa. However, proto2 enums cannot be used directly in proto3 syntax (it’s okay if an imported proto2 message uses them).\nNested Types You can define and use message types inside other message types, as in the following example – here the Result message is defined inside the SearchResponse message:\nmessage SearchResponse { message Result { string url = 1; string title = 2; repeated string snippets = 3; } repeated Result results = 1; } If you want to reuse this message type outside its parent message type, you refer to it as _Parent_._Type_:\nmessage SomeOtherMessage { SearchResponse.Result result = 1; } You can nest messages as deeply as you like:\nmessage Outer { // Level 0 message MiddleAA { // Level 1 message Inner { // Level 2 int64 ival = 1; bool booly = 2; } } message MiddleBB { // Level 1 message Inner { // Level 2 int32 ival = 1; bool booly = 2; } } } Updating A Message Type If an existing message type no longer meets all your needs – for example, you’d like the message format to have an extra field – but you’d still like to use code created with the old format, don’t worry! It’s very simple to update message types without breaking any of your existing code. Just remember the following rules:\nDon’t change the field numbers for any existing fields. If you add new fields, any messages serialized by code using your “old” message format can still be parsed by your new generated code. You should keep in mind the default values for these elements so that new code can properly interact with messages generated by old code. Similarly, messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing. See the Unknown Fields section for details. Fields can be removed, as long as the field number is not used again in your updated message type. You may want to rename the field instead, perhaps adding the prefix “OBSOLETE_”, or make the field number reserved, so that future users of your .proto can’t accidentally reuse the number. int32, uint32, int64, uint64, and bool are all compatible – this means you can change a field from one of these types to another without breaking forwards- or backwards-compatibility. If a number is parsed from the wire which doesn’t fit in the corresponding type, you will get the same effect as if you had cast the number to that type in C++ (for example, if a 64-bit number is read as an int32, it will be truncated to 32 bits). sint32 and sint64 are compatible with each other but are not compatible with the other integer types. string and bytes are compatible as long as the bytes are valid UTF-8. Embedded messages are compatible with bytes if the bytes contain an encoded version of the message. fixed32 is compatible with sfixed32, and fixed64 with sfixed64. For string, bytes, and message fields, optional is compatible with repeated. Given serialized data of a repeated field as input, clients that expect this field to be optional will take the last input value if it’s a primitive type field or merge all input elements if it’s a message type field. Note that this is not generally safe for numeric types, including bools and enums. Repeated fields of numeric types can be serialized in the packed format, which will not be parsed correctly when an optional field is expected. enum is compatible with int32, uint32, int64, and uint64 in terms of wire format (note that values will be truncated if they don’t fit). However be aware that client code may treat them differently when the message is deserialized: for example, unrecognized proto3 enum types will be preserved in the message, but how this is represented when the message is deserialized is language-dependent. Int fields always just preserve their value. Changing a single optional field or extension into a member of a new oneof is binary compatible, however for some languages (notably, Go) the generated code’s API will change in incompatible ways. For this reason, Google does not make such changes in its public APIs, as documented in AIP-180. With the same caveat about source-compatibility, moving multiple fields into a new oneof may be safe if you are sure that no code sets more than one at a time. Moving fields into an existing oneof is not safe. Likewise, changing a single field oneof to an optional field or extension is safe. Unknown Fields Unknown fields are well-formed protocol buffer serialized data representing fields that the parser does not recognize. For example, when an old binary parses data sent by a new binary with new fields, those new fields become unknown fields in the old binary.\nOriginally, proto3 messages always discarded unknown fields during parsing, but in version 3.5 we reintroduced the preservation of unknown fields to match the proto2 behavior. In versions 3.5 and later, unknown fields are retained during parsing and included in the serialized output.\nAny The Any message type lets you use messages as embedded types without having their .proto definition. An Any contains an arbitrary serialized message as bytes, along with a URL that acts as a globally unique identifier for and resolves to that message’s type. To use the Any type, you need to import google/protobuf/any.proto.\nimport \"google/protobuf/any.proto\"; message ErrorStatus { string message = 1; repeated google.protobuf.Any details = 2; } The default type URL for a given message type is type.googleapis.com/_packagename_._messagename_.\nDifferent language implementations will support runtime library helpers to pack and unpack Any values in a typesafe manner – for example, in Java, the Any type will have special pack() and unpack() accessors, while in C++ there are PackFrom() and UnpackTo() methods:\n// Storing an arbitrary message type in Any. NetworkErrorDetails details = ...; ErrorStatus status; status.add_details()-\u003ePackFrom(details); // Reading an arbitrary message from Any. ErrorStatus status = ...; for (const google::protobuf::Any\u0026 detail : status.details()) { if (detail.Is\u003cNetworkErrorDetails\u003e()) { NetworkErrorDetails network_error; detail.UnpackTo(\u0026network_error); ... processing network_error ... } } Currently the runtime libraries for working with Any types are under development.\nIf you are already familiar with proto2 syntax, the Any can hold arbitrary proto3 messages, similar to proto2 messages which can allow extensions.\nOneof If you have a message with many fields and where at most one field will be set at the same time, you can enforce this behavior and save memory by using the oneof feature.\nOneof fields are like regular fields except all the fields in a oneof share memory, and at most one field can be set at the same time. Setting any member of the oneof automatically clears all the other members. You can check which value in a oneof is set (if any) using a special case() or WhichOneof() method, depending on your chosen language.\nNote that if multiple values are set, the last set value as determined by the order in the proto will overwrite all previous ones.\nUsing Oneof To define a oneof in your .proto you use the oneof keyword followed by your oneof name, in this case test_oneof:\nmessage SampleMessage { oneof test_oneof { string name = 4; SubMessage sub_message = 9; } } You then add your oneof fields to the oneof definition. You can add fields of any type, except map fields and repeated fields.\nIn your generated code, oneof fields have the same getters and setters as regular fields. You also get a special method for checking which value (if any) in the oneof is set. You can find out more about the oneof API for your chosen language in the relevant API reference.\nOneof Features Setting a oneof field will automatically clear all other members of the oneof. So if you set several oneof fields, only the last field you set will still have a value.\nSampleMessage message; message.set_name(\"name\"); CHECK_EQ(message.name(), \"name\"); // Calling mutable_sub_message() will clear the name field and will set // sub_message to a new instance of SubMessage with none of its fields set. message.mutable_sub_message(); CHECK(message.name().empty()); If the parser encounters multiple members of the same oneof on the wire, only the last member seen is used in the parsed message.\nA oneof cannot be repeated.\nReflection APIs work for oneof fields.\nIf you set a oneof field to the default value (such as setting an int32 oneof field to 0), the “case” of that oneof field will be set, and the value will be serialized on the wire.\nIf you’re using C++, make sure your code doesn’t cause memory crashes. The following sample code will crash because sub_message was already deleted by calling the set_name() method.\nSampleMessage message; SubMessage* sub_message = message.mutable_sub_message(); message.set_name(\"name\"); // Will delete sub_message sub_message-\u003eset_... // Crashes here Again in C++, if you Swap() two messages with oneofs, each message will end up with the other’s oneof case: in the example below, msg1 will have a sub_message and msg2 will have a name.\nSampleMessage msg1; msg1.set_name(\"name\"); SampleMessage msg2; msg2.mutable_sub_message(); msg1.swap(\u0026msg2); CHECK(msg1.has_sub_message()); CHECK_EQ(msg2.name(), \"name\"); Backwards-compatibility issues Be careful when adding or removing oneof fields. If checking the value of a oneof returns None/NOT_SET, it could mean that the oneof has not been set or it has been set to a field in a different version of the oneof. There is no way to tell the difference, since there’s no way to know if an unknown field on the wire is a member of the oneof.\nTag Reuse Issues Move fields into or out of a oneof: You may lose some of your information (some fields will be cleared) after the message is serialized and parsed. However, you can safely move a single field into a new oneof and may be able to move multiple fields if it is known that only one is ever set. See Updating A Message Type for further details. Delete a oneof field and add it back: This may clear your currently set oneof field after the message is serialized and parsed. Split or merge oneof: This has similar issues to moving regular fields. Maps If you want to create an associative map as part of your data definition, protocol buffers provides a handy shortcut syntax:\nmap\u003ckey_type, value_type\u003e map_field = N; …where the key_type can be any integral or string type (so, any scalar type except for floating point types and bytes). Note that enum is not a valid key_type. The value_type can be any type except another map.\nSo, for example, if you wanted to create a map of projects where each Project message is associated with a string key, you could define it like this:\nmap\u003cstring, Project\u003e projects = 3; Map fields cannot be repeated. Wire format ordering and map iteration ordering of map values are undefined, so you cannot rely on your map items being in a particular order. When generating text format for a .proto, maps are sorted by key. Numeric keys are sorted numerically. When parsing from the wire or when merging, if there are duplicate map keys the last key seen is used. When parsing a map from text format, parsing may fail if there are duplicate keys. If you provide a key but no value for a map field, the behavior when the field is serialized is language-dependent. In C++, Java, Kotlin, and Python the default value for the type is serialized, while in other languages nothing is serialized. The generated map API is currently available for all proto3 supported languages. You can find out more about the map API for your chosen language in the relevant API reference.\nBackwards Compatibility The map syntax is equivalent to the following on the wire, so protocol buffers implementations that do not support maps can still handle your data:\nmessage MapFieldEntry { key_type key = 1; value_type value = 2; } repeated MapFieldEntry map_field = N; Any protocol buffers implementation that supports maps must both produce and accept data that can be accepted by the above definition.\nPackages You can add an optional package specifier to a .proto file to prevent name clashes between protocol message types.\npackage foo.bar; message Open { ... } You can then use the package specifier when defining fields of your message type:\nmessage Foo { ... foo.bar.Open open = 1; ... } The way a package specifier affects the generated code depends on your chosen language:\nIn C++ the generated classes are wrapped inside a C++ namespace. For example, Open would be in the namespace foo::bar. In Java and Kotlin, the package is used as the Java package, unless you explicitly provide an option java_package in your .proto file. In Python, the package directive is ignored, since Python modules are organized according to their location in the file system. In Go, the package is used as the Go package name, unless you explicitly provide an option go_package in your .proto file. In Ruby, the generated classes are wrapped inside nested Ruby namespaces, converted to the required Ruby capitalization style (first letter capitalized; if the first character is not a letter, PB_ is prepended). For example, Open would be in the namespace Foo::Bar. In C# the package is used as the namespace after converting to PascalCase, unless you explicitly provide an option csharp_namespace in your .proto file. For example, Open would be in the namespace Foo.Bar. Packages and Name Resolution Type name resolution in the protocol buffer language works like C++: first the innermost scope is searched, then the next-innermost, and so on, with each package considered to be “inner” to its parent package. A leading ‘.’ (for example, .foo.bar.Baz) means to start from the outermost scope instead.\nThe protocol buffer compiler resolves all type names by parsing the imported .proto files. The code generator for each language knows how to refer to each type in that language, even if it has different scoping rules.\nDefining Services If you want to use your message types with an RPC (Remote Procedure Call) system, you can define an RPC service interface in a .proto file and the protocol buffer compiler will generate service interface code and stubs in your chosen language. So, for example, if you want to define an RPC service with a method that takes your SearchRequest and returns a SearchResponse, you can define it in your .proto file as follows:\nservice SearchService { rpc Search(SearchRequest) returns (SearchResponse); } The most straightforward RPC system to use with protocol buffers is gRPC: a language- and platform-neutral open source RPC system developed at Google. gRPC works particularly well with protocol buffers and lets you generate the relevant RPC code directly from your .proto files using a special protocol buffer compiler plugin.\nIf you don’t want to use gRPC, it’s also possible to use protocol buffers with your own RPC implementation. You can find out more about this in the Proto2 Language Guide.\nThere are also a number of ongoing third-party projects to develop RPC implementations for Protocol Buffers. For a list of links to projects we know about, see the third-party add-ons wiki page.\nJSON Mapping Proto3 supports a canonical encoding in JSON, making it easier to share data between systems. The encoding is described on a type-by-type basis in the table below.\nWhen parsing JSON-encoded data into a protocol buffer, if a value is missing or if its value is null, it will be interpreted as the corresponding default value.\nWhen generating JSON-encoded output from a protocol buffer, if a protobuf field has the default value and if the field doesn’t support field presence, it will be omitted from the output by default. An implementation may provide options to include fields with default values in the output.\nA proto3 field that is defined with the optional keyword supports field presence. Fields that have a value set and that support field presence always include the field value in the JSON-encoded output, even if it is the default value.\nproto3 JSON JSON example Notes message object {\"fooBar\": v, \"g\": null, …} Generates JSON objects. Message field names are mapped to lowerCamelCase and become JSON object keys. If the json_name field option is specified, the specified value will be used as the key instead. Parsers accept both the lowerCamelCase name (or the one specified by the json_name option) and the original proto field name. null is an accepted value for all field types and treated as the default value of the corresponding field type. enum string \"FOO_BAR\" The name of the enum value as specified in proto is used. Parsers accept both enum names and integer values. map\u003cK,V\u003e object {\"k\": v, …} All keys are converted to strings. repeated V array [v, …] null is accepted as the empty list []. bool true, false true, false string string \"Hello World!\" bytes base64 string \"YWJjMTIzIT8kKiYoKSctPUB+\" JSON value will be the data encoded as a string using standard base64 encoding with paddings. Either standard or URL-safe base64 encoding with/without paddings are accepted. int32, fixed32, uint32 number 1, -10, 0 JSON value will be a decimal number. Either numbers or strings are accepted. int64, fixed64, uint64 string \"1\", \"-10\" JSON value will be a decimal string. Either numbers or strings are accepted. float, double number 1.1, -10.0, 0, \"NaN\", \"Infinity\" JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\". Either numbers or strings are accepted. Exponent notation is also accepted. -0 is considered equivalent to 0. Any object {\"@type\": \"url\", \"f\": v, … } If the Any contains a value that has a special JSON mapping, it will be converted as follows: {\"@type\": xxx, \"value\": yyy}. Otherwise, the value will be converted into a JSON object, and the \"@type\" field will be inserted to indicate the actual data type. Timestamp string \"1972-01-01T10:00:20.021Z\" Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits. Offsets other than \"Z\" are also accepted. Duration string \"1.000340012s\", \"1s\" Generated output always contains 0, 3, 6, or 9 fractional digits, depending on required precision, followed by the suffix \"s\". Accepted are any fractional digits (also none) as long as they fit into nano-seconds precision and the suffix \"s\" is required. Struct object { … } Any JSON object. See struct.proto. Wrapper types various types 2, \"2\", \"foo\", true, \"true\", null, 0, … Wrappers use the same representation in JSON as the wrapped primitive type, except that null is allowed and preserved during data conversion and transfer. FieldMask string \"f.fooBar,h\" See field_mask.proto. ListValue array [foo, bar, …] Value value Any JSON value. Check google.protobuf.Value for details. NullValue null JSON null Empty object {} An empty JSON object JSON Options A proto3 JSON implementation may provide the following options:\nEmit fields with default values: Fields with default values are omitted by default in proto3 JSON output. An implementation may provide an option to override this behavior and output fields with their default values. Ignore unknown fields: Proto3 JSON parser should reject unknown fields by default but may provide an option to ignore unknown fields in parsing. Use proto field name instead of lowerCamelCase name: By default proto3 JSON printer should convert the field name to lowerCamelCase and use that as the JSON name. An implementation may provide an option to use proto field name as the JSON name instead. Proto3 JSON parsers are required to accept both the converted lowerCamelCase name and the proto field name. Emit enum values as integers instead of strings: The name of an enum value is used by default in JSON output. An option may be provided to use the numeric value of the enum value instead. Options Individual declarations in a .proto file can be annotated with a number of options. Options do not change the overall meaning of a declaration, but may affect the way it is handled in a particular context. The complete list of available options is defined in /google/protobuf/descriptor.proto.\nSome options are file-level options, meaning they should be written at the top-level scope, not inside any message, enum, or service definition. Some options are message-level options, meaning they should be written inside message definitions. Some options are field-level options, meaning they should be written inside field definitions. Options can also be written on enum types, enum values, oneof fields, service types, and service methods; however, no useful options currently exist for any of these.\nHere are a few of the most commonly used options:\njava_package (file option): The package you want to use for your generated Java/Kotlin classes. If no explicit java_package option is given in the .proto file, then by default the proto package (specified using the “package” keyword in the .proto file) will be used. However, proto packages generally do not make good Java packages since proto packages are not expected to start with reverse domain names. If not generating Java or Kotlin code, this option has no effect.\noption java_package = \"com.example.foo\"; java_outer_classname (file option): The class name (and hence the file name) for the wrapper Java class you want to generate. If no explicit java_outer_classname is specified in the .proto file, the class name will be constructed by converting the .proto file name to camel-case (so foo_bar.proto becomes FooBar.java). If the java_multiple_files option is disabled, then all other classes/enums/etc. generated for the .proto file will be generated within this outer wrapper Java class as nested classes/enums/etc. If not generating Java code, this option has no effect.\noption java_outer_classname = \"Ponycopter\"; java_multiple_files (file option): If false, only a single .java file will be generated for this .proto file, and all the Java classes/enums/etc. generated for the top-level messages, services, and enumerations will be nested inside of an outer class (see java_outer_classname). If true, separate .java files will be generated for each of the Java classes/enums/etc. generated for the top-level messages, services, and enumerations, and the wrapper Java class generated for this .proto file won’t contain any nested classes/enums/etc. This is a Boolean option which defaults to false. If not generating Java code, this option has no effect.\noption java_multiple_files = true; optimize_for (file option): Can be set to SPEED, CODE_SIZE, or LITE_RUNTIME. This affects the C++ and Java code generators (and possibly third-party generators) in the following ways:\nSPEED (default): The protocol buffer compiler will generate code for serializing, parsing, and performing other common operations on your message types. This code is highly optimized. CODE_SIZE: The protocol buffer compiler will generate minimal classes and will rely on shared, reflection-based code to implement serialialization, parsing, and various other operations. The generated code will thus be much smaller than with SPEED, but operations will be slower. Classes will still implement exactly the same public API as they do in SPEED mode. This mode is most useful in apps that contain a very large number of .proto files and do not need all of them to be blindingly fast. LITE_RUNTIME: The protocol buffer compiler will generate classes that depend only on the “lite” runtime library (libprotobuf-lite instead of libprotobuf). The lite runtime is much smaller than the full library (around an order of magnitude smaller) but omits certain features like descriptors and reflection. This is particularly useful for apps running on constrained platforms like mobile phones. The compiler will still generate fast implementations of all methods as it does in SPEED mode. Generated classes will only implement the MessageLite interface in each language, which provides only a subset of the methods of the full Message interface. option optimize_for = CODE_SIZE; cc_enable_arenas (file option): Enables arena allocation for C++ generated code.\nobjc_class_prefix (file option): Sets the Objective-C class prefix which is prepended to all Objective-C generated classes and enums from this .proto. There is no default. You should use prefixes that are between 3-5 uppercase characters as recommended by Apple. Note that all 2 letter prefixes are reserved by Apple.\ndeprecated (field option): If set to true, indicates that the field is deprecated and should not be used by new code. In most languages this has no actual effect. In Java, this becomes a @Deprecated annotation. For C++, clang-tidy will generate warnings whenever deprecated fields are used. In the future, other language-specific code generators may generate deprecation annotations on the field’s accessors, which will in turn cause a warning to be emitted when compiling code which attempts to use the field. If the field is not used by anyone and you want to prevent new users from using it, consider replacing the field declaration with a reserved statement.\nint32 old_field = 6 [deprecated = true]; Custom Options Protocol Buffers also allows you to define and use your own options. This is an advanced feature which most people don’t need. If you do think you need to create your own options, see the Proto2 Language Guide for details. Note that creating custom options uses extensions, which are permitted only for custom options in proto3.\nOption Retention Options have a notion of retention, which controls whether an option is retained in the generated code. Options have runtime retention by default, meaning that they are retained in the generated code and are thus visible at runtime in the generated descriptor pool. However, you can set retention = RETENTION_SOURCE to specify that an option (or field within an option) must not be retained at runtime. This is called source retention.\nOption retention is an advanced feature that most users should not need to worry about, but it can be useful if you would like to use certain options without paying the code size cost of retaining them in your binaries. Options with source retention are still visible to protoc and protoc plugins, so code generators can use them to customize their behavior.\nRetention can be set directly on an option, like this;\nextend google.protobuf.FileOptions { optional int32 source_retention_option = 1234 [retention = RETENTION_SOURCE]; } It can also be set on a plain field, in which case it takes effect only when that field appears inside an option:\nmessage OptionsMessage { optional int32 source_retention_field = 1 [retention = RETENTION_SOURCE]; } You can set retention = RETENTION_RUNTIME if you like, but this has no effect since it is the default behavior. When a message field is marked RETENTION_SOURCE, its entire contents are dropped; fields inside it cannot override that by trying to set RETENTION_RUNTIME.\nNote As of Protocol Buffers 22.0, support for option retention is still in progress and only C++ and Java are supported. In all other languages, options are always retained at runtime. Generating Your Classes To generate the Java, Kotlin, Python, C++, Go, Ruby, Objective-C, or C# code you need to work with the message types defined in a .proto file, you need to run the protocol buffer compiler protoc on the .proto. If you haven’t installed the compiler, download the package and follow the instructions in the README. For Go, you also need to install a special code generator plugin for the compiler: you can find this and installation instructions in the golang/protobuf repository on GitHub.\nThe Protocol Compiler is invoked as follows:\nprotoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto IMPORT_PATH specifies a directory in which to look for .proto files when resolving import directives. If omitted, the current directory is used. Multiple import directories can be specified by passing the --proto_path option multiple times; they will be searched in order. -I=_IMPORT_PATH_ can be used as a short form of --proto_path.\nYou can provide one or more output directives:\n--cpp_out generates C++ code in DST_DIR. See the C++ generated code reference for more. --java_out generates Java code in DST_DIR. See the Java generated code reference for more. --kotlin_out generates additional Kotlin code in DST_DIR. See the Kotlin generated code reference for more. --python_out generates Python code in DST_DIR. See the Python generated code reference for more. --go_out generates Go code in DST_DIR. See the Go generated code reference for more. --ruby_out generates Ruby code in DST_DIR. See the Ruby generated code reference for more. --objc_out generates Objective-C code in DST_DIR. See the Objective-C generated code reference for more. --csharp_out generates C# code in DST_DIR. See the C# generated code reference for more. --php_out generates PHP code in DST_DIR. See the PHP generated code reference for more. As an extra convenience, if the DST_DIR ends in .zip or .jar, the compiler will write the output to a single ZIP-format archive file with the given name. .jar outputs will also be given a manifest file as required by the Java JAR specification. Note that if the output archive already exists, it will be overwritten; the compiler is not smart enough to add files to an existing archive.\nYou must provide one or more .proto files as input. Multiple .proto files can be specified at once. Although the files are named relative to the current directory, each file must reside in one of the IMPORT_PATHs so that the compiler can determine its canonical name.\nFile location Prefer not to put .proto files in the same directory as other language sources. Consider creating a subpackage proto for .proto files, under the root package for your project.\nLocation Should be Language-agnostic When working with Java code, it’s handy to put related .proto files in the same directory as the Java source. However, if any non-Java code ever uses the same protos, the path prefix will no longer make sense. So in general, put the protos in a related language-agnostic directory such as //myteam/mypackage.\nThe exception to this rule is when it’s clear that the protos will be used only in a Java context, such as for testing.\nSupported Platforms For information about:\nthe operating systems, compilers, build systems, and C++ versions that are supported, see Foundational C++ Support Policy. the PHP versions that are supported, see Supported PHP versions. ","categories":"","description":"This topic covers how to use the version 3 of Protocol Buffers in your project. It contains language-agnostic content. For information specific to the language you're using, see the corresponding documentation for your language.","excerpt":"This topic covers how to use the version 3 of Protocol Buffers in your …","ref":"/programming-guides/proto3/","tags":"","title":"Language Guide (proto 3)"},{"body":"This document provides a style guide for .proto files. By following these conventions, you’ll make your protocol buffer message definitions and their corresponding classes consistent and easy to read.\nNote that protocol buffer style has evolved over time, so it is likely that you will see .proto files written in different conventions or styles. Respect the existing style when you modify these files. Consistency is key. However, it is best to adopt the current best style when you are creating a new .proto file.\nStandard File Formatting Keep the line length to 80 characters. Use an indent of 2 spaces. Prefer the use of double quotes for strings. File Structure Files should be named lower_snake_case.proto.\nAll files should be ordered in the following manner:\nLicense header (if applicable) File overview Syntax Package Imports (sorted) File options Everything else Packages Package names should be in lowercase. Package names should have unique names based on the project name, and possibly based on the path of the file containing the protocol buffer type definitions.\nMessage and Field Names Use PascalCase (with an initial capital) for message names – for example, SongServerRequest. Use lower_snake_case for field names (including oneof field and extension names) – for example, song_name.\nmessage SongServerRequest { optional string song_name = 1; } Using this naming convention for field names gives you accessors like those shown in the the following two code samples.\nC++:\nconst string\u0026 song_name() { ... } void set_song_name(const string\u0026 x) { ... } Java:\npublic String getSongName() { ... } public Builder setSongName(String v) { ... } If your field name contains a number, the number should appear after the letter instead of after the underscore. For example, use song_name1 instead of song_name_1\nRepeated Fields Use pluralized names for repeated fields.\nrepeated string keys = 1; ... repeated MyMessage accounts = 17; Enums Use PascalCase (with an initial capital) for enum type names and CAPITALS_WITH_UNDERSCORES for value names:\nenum FooBar { FOO_BAR_UNSPECIFIED = 0; FOO_BAR_FIRST_VALUE = 1; FOO_BAR_SECOND_VALUE = 2; } Each enum value should end with a semicolon, not a comma. Prefer prefixing enum values instead of surrounding them in an enclosing message. The zero value enum should have the suffix UNSPECIFIED, because a server or application that gets an unexpected enum value will mark the field as unset in the proto instance. The field accessor will then return the default value, which for enum fields is the first enum value.\nServices If your .proto defines an RPC service, you should use PascalCase (with an initial capital) for both the service name and any RPC method names:\nservice FooService { rpc GetSomething(GetSomethingRequest) returns (GetSomethingResponse); rpc ListSomething(ListSomethingRequest) returns (ListSomethingResponse); } Things to Avoid Required fields (only for proto2) Groups (only for proto2) ","categories":"","description":"This topic provides direction for how best to stucture your proto definitions.","excerpt":"This topic provides direction for how best to stucture your proto …","ref":"/programming-guides/style/","tags":"","title":"Style Guide"},{"body":"Enums behave differently in different language libraries. This topic covers the different behaviors as well as the plans to move protobufs to a state where they are consistent across all languages. If you’re looking for information on how to use enums in general, see the corresponding sections in the proto2 and proto3 language guide topics.\nDefinitions Enums have two distinct flavors (open and closed). They behave identically except in their handling of unknown values. Practically, this means that simple cases work the same, but some corner cases have interesting implications.\nFor the purpose of explanation, let us assume we have the following .proto file (we are deliberately not specifying if this is a syntax = \"proto2\" or syntax = \"proto3\" file right now):\nenum Enum { A = 0; B = 1; } message Msg { optional Enum enum = 1; } The distinction between open and closed can be encapsulated in a single question:\nWhat happens when a program parses binary data that contains field 1 with the value 2?\nOpen enums will parse the value 2 and store it directly in the field. Accessor will report the field as being set and will return something that represents 2. Closed enums will parse the value 2 and store it in the message’s unknown field set. Accessors will report the field as being unset and will return the enum’s default value. Implications of Closed Enums The behavior of closed enums has unexpected consquences when parsing a repeated field. When a repeated Enum field is parsed all unknown values will be placed in the unknown field set. When it is serialized those unknown values will be written again, but not in their original place in the list. For example, given the .proto file:\nenum Enum { A = 0; B = 1; } message Msg { repeated Enum r = 1; } A wire format containing the values [0, 2, 1, 2] for field 1 will parse so that the repeated field contains [0, 1] and the value [2, 2] will end up stored as an unknown field. After reserializing the message, the wire format will correspond to [0, 1, 2, 2].\nSimilarly, maps with closed enums for their value will place entire entries (key and value) in the unknown fields whenever the value is unknown.\nHistory Prior to the introduction of syntax = \"proto3\" all enums were closed. Proto3 introduced open enums specifically because of the unexpected behavior that closed enums cause.\nSpecification The following specifies the behavior of conformant implementations for protobuf. Because this is subtle, many implementations are out of conformance. See Known Issues for details on how different implementations behave.\nWhen a proto2 file imports an enum defined in a proto2 file, that enum should be treated as closed. When a proto3 file imports an enum defined in a proto3 file, that enum should be treated as open. When a proto3 file imports an enum defined in a proto2 file, the protoc compiler will produce an error. When a proto2 file imports an enum defined in a proto3 file, that enum should be treated as open. Known Issues C++ All known C++ releases are out of conformance. When a proto2 file imports an enum defined in a proto3 file, C++ treats that field as a closed enum.\nC# All known C# releases are out of conformance. C# treats all enums as open.\nJava All known Java releases are out of conformance. When a proto2 file imports an enum defined in a proto3 file, Java treats that field as a closed enum.\nNOTE: Java’s handling of open enums has surprising edge cases. Given the following definitions:\nsyntax = \"proto3\"; enum Enum { A = 0; B = 1; } message Msg { repeated Enum name = 1; } Java will generate the methods Enum getName() and int getNameValue(). The method getName will return Enum.UNRECOGNIZED for values outside the known set (such as 2), whereas getNameValue will return 2.\nSimilarly, Java will generate methods Builder setName(Enum value) and Builder setNameValue(int value). The method setName will throw an exception when passed Enum.UNRECOGNIZED, whereas setNameValue will accept 2.\nKotlin All known Kotlin releases are out of conformance. When a proto2 file imports an enum defined in a proto3 file, Kotlin treats that field as a closed enum.\nKotlin is built on Java and shares all of its oddities.\nGo All known Go releases are out of conformance. Go treats all enums as open.\nJSPB All known JSPB releases are out of conformance. JSPB treats all enums as open.\nPHP PHP is conformant.\nPython After 4.22.0, Python is conformant.\nIn 4.21.x, Python is conformant by default, but setting PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python will cause it to be out of conformance.\nBefore 4.21.0, Python is out of conformance.\nWhen a proto2 file imports an enum defined in a proto3 file, non-conformant Python versions treat that field as a closed enum.\nRuby All known Ruby releases are out of conformance. Ruby treats all enums as open.\nObjective-C After 22.0, Objective-C is conformant.\nPrior to 22.0, Objective-C was out of conformance. When a proto2 file imported an enum defined in a proto3 file, it would treat that field as a closed enum.\nSwift Swift is conformant.\n","categories":"","description":"This topic explains how enums currently work in Protocol Buffers vs. how they should work.","excerpt":"This topic explains how enums currently work in Protocol Buffers vs. …","ref":"/programming-guides/enum/","tags":"","title":"Enum Behavior"},{"body":"This document describes the protocol buffer wire format, which defines the details of how your message is sent on the wire and how much space it consumes on disk. You probably don’t need to understand this to use protocol buffers in your application, but it’s useful information for doing optimizations.\nIf you already know the concepts but want a reference, skip to the Condensed reference card section.\nProtoscope is a very simple language for describing snippets of the low-level wire format, which we’ll use to provide a visual reference for the encoding of various messages. Protoscope’s syntax consists of a sequence of tokens that each encode down to a specific byte sequence.\nFor example, backticks denote a raw hex literal, like `70726f746f6275660a`. This encodes into the exact bytes denoted as hex in the literal. Quotes denote UTF-8 strings, like \"Hello, Protobuf!\". This literal is synonymous with `48656c6c6f2c2050726f746f62756621` (which, if you observe closely, is composed of ASCII bytes). We’ll introduce more of the Protoscope language as we discuss aspects of the wire format.\nThe Protoscope tool can also dump encoded protocol buffers as text. See https://github.com/protocolbuffers/protoscope/tree/main/testdata for examples.\nA Simple Message Let’s say you have the following very simple message definition:\nmessage Test1 { optional int32 a = 1; } In an application, you create a Test1 message and set a to 150. You then serialize the message to an output stream. If you were able to examine the encoded message, you’d see three bytes:\n08 96 01 So far, so small and numeric – but what does it mean? If you use the Protoscope tool to dump those bytes, you’d get something like 1: 150. How does it know this is the contents of the message?\nBase 128 Varints Variable-width integers, or varints, are at the core of the wire format. They allow encoding unsigned 64-bit integers using anywhere between one and ten bytes, with small values using fewer bytes.\nEach byte in the varint has a continuation bit that indicates if the byte that follows it is part of the varint. This is the most significant bit (MSB) of the byte (sometimes also called the sign bit). The lower 7 bits are a payload; the resulting integer is built by appending together the 7-bit payloads of its constituent bytes.\nSo, for example, here is the number 1, encoded as `01` – it’s a single byte, so the MSB is not set:\n0000 0001 ^ msb And here is 150, encoded as `9601` – this is a bit more complicated:\n10010110 00000001 ^ msb ^ msb How do you figure out that this is 150? First you drop the MSB from each byte, as this is just there to tell us whether we’ve reached the end of the number (as you can see, it’s set in the first byte as there is more than one byte in the varint). Then we concatenate the 7-bit payloads, and interpret it as a little-endian, 64-bit unsigned integer:\n10010110 00000001 // Original inputs. 0010110 0000001 // Drop continuation bits. 0000001 0010110 // Put into little-endian order. 10010110 // Concatenate. 128 + 16 + 4 + 2 = 150 // Interpret as integer. Because varints are so crucial to protocol buffers, in protoscope syntax, we refer to them as plain integers. 150 is the same as `9601`.\nMessage Structure A protocol buffer message is a series of key-value pairs. The binary version of a message just uses the field’s number as the key – the name and declared type for each field can only be determined on the decoding end by referencing the message type’s definition (i.e. the .proto file). Protoscope does not have access to this information, so it can only provide the field numbers.\nWhen a message is encoded, each key-value pair is turned into a record consisting of the field number, a wire type and a payload. The wire type tells the parser how big the payload after it is. This allows old parsers to skip over new fields they don’t understand. This type of scheme is sometimes called Tag-Length-Value, or TLV.\nThere are six wire types: VARINT, I64, LEN, SGROUP, EGROUP, and I32\nID Name Used For 0 VARINT int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 I64 fixed64, sfixed64, double 2 LEN string, bytes, embedded messages, packed repeated fields 3 SGROUP group start (deprecated) 4 EGROUP group end (deprecated) 5 I32 fixed32, sfixed32, float The “tag” of a record is encoded as a varint formed from the field number and the wire type via the formula (field_number \u003c\u003c 3) | wire_type. In other words, after decoding the varint representing a field, the low 3 bits tell us the wire type, and the rest of the integer tells us the field number.\nNow let’s look at our simple example again. You now know that the first number in the stream is always a varint key, and here it’s `08`, or (dropping the MSB):\n000 1000 You take the last three bits to get the wire type (0) and then right-shift by three to get the field number (1). Protoscope represents a tag as an integer followed by a colon and the wire type, so we can write the above bytes as 1:VARINT.\nBecause the wire type is 0, or VARINT, we know that we need to decode a varint to get the payload. As we saw above, the bytes `9601` varint-decode to 150, giving us our record. We can write it in Protoscope as 1:VARINT 150.\nProtoscope can infer the type for a tag if there is whitespace after the :. It does so by looking ahead at the next token and guessing what you meant (the rules are documented in detail in Protoscope’s language.txt). For example, in 1: 150, there is a varint immediately after the untyped tag, so Protoscope infers its type to be VARINT. If you wrote 2: {}, it would see the { and guess LEN; if you wrote 3: 5i32 it would guess I32, and so on.\nMore Integer Types Bools and Enums Bools and enums are both encoded as if they were int32s. Bools, in particular, always encode as either `00` or `01`. In Protoscope, false and true are aliases for these byte strings.\nSigned Integers As you saw in the previous section, all the protocol buffer types associated with wire type 0 are encoded as varints. However, varints are unsigned, so the different signed types, sint32 and sint64 vs int32 or int64, encode negative integers differently.\nThe intN types encode negative numbers as two’s complement, which means that, as unsigned, 64-bit integers, they have their highest bit set. As a result, this means that all ten bytes must be used. For example, -2 is converted by protoscope into\n11111110 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 00000001 This is the two’s complement of 2, defined in unsigned arithmetic as ~0 - 2 + 1, where ~0 is the all-ones 64-bit integer. It is a useful exercise to understand why this produces so many ones.\nsintN uses the “ZigZag” encoding instead of two’s complement to encode negative integers. Positive integers n are encoded as 2 * n (the even numbers), while negative integers -n are encoded as 2 * n + 1 (the odd numbers). The encoding thus “zig-zags” between positive and negative numbers. For example:\nSigned Original Encoded As 0 0 -1 1 1 2 -2 3 … … 0x7fffffff 0xfffffffe -0x80000000 0xffffffff Using some bit tricks, it’s cheap to convert n into its ZigZag representation:\n((n + n) ^ -(n \u003c 0)) - (n \u003c 0) Here, we assume that the boolean n \u003c 0 is converted into an integer 1 if true or an integer 0 if false.\nWhen the sint32 or sint64 is parsed, its value is decoded back to the original, signed version.\nIn protoscope, suffixing an integer with a z will make it encode as ZigZag. For example, -500z is the same as the varint 1001.\nNon-varint Numbers Non-varint numeric types are simple – double and fixed64 have wire type I64, which tells the parser to expect a fixed eight-byte lump of data. We can specify a double record by writing 5: 25.4, or a fixed64 record with 6: 200i64. In both cases, omitting an explicit wire type infers the I64 wire type.\nSimilarly float and fixed32 have wire type I32, which tells it to expect four bytes instead. The syntax for these consists of adding an i32 prefix. 25.4i32 will emit four bytes, as will 200i32. Tag types are inferred as I32.\nLength-Delimited Records Length prefixes are another major concept in the wire format. The LEN wire type has a dynamic length, specified by a varint immediately after the tag, which is followed by the payload as usual.\nConsider this message schema:\nmessage Test2 { optional string b = 2; } A record for the field b is a string, and strings are LEN-encoded. If we set b to \"testing\", we encoded as a LEN record with field number 2 containing the ASCII string \"testing\". The result is `120774657374696e67`. Breaking up the bytes,\n12 07 [74 65 73 74 69 6e 67] we see that the tag, `12`, is 00010 010, or 2:LEN. The byte that follows is the varint 7, and the next seven bytes are the UTF-8 encoding of \"testing\".\nIn Protoscope, this is written as 2:LEN 7 \"testing\". However, it can be incovenient to repeat the length of the string (which, in Protoscope text, is already quote-delimited). Wrapping Protoscope content in braces will generate a length prefix for it: {\"testing\"} is a shorthand for 7 \"testing\". {} is always inferred by fields to be a LEN record, so we can write this record simply as 2: {\"testing\"}.\nbytes fields are encoded in the same way.\nSubmessages Submessage fields also use the LEN wire type. Here’s a message definition with an embedded message of our original example message, Test1:\nmessage Test3 { optional Test1 c = 3; } If Test1’s a field (i.e., Test3’s c.a field) is set to 150, we get ``1a03089601``. Breaking it up:\n1a 03 [08 96 01] The last three bytes (in []) are exactly the same ones from our very first example. These bytes are preceded by a LEN-typed tag, and a length of 3, exactly the same way as strings are encoded.\nIn Protoscope, submessages are quite succinct. ``1a03089601`` can be written as 3: {1: 150}.\nOptional and Repeated Elements Missing optional fields are easy to encode: we just leave out the record if it’s not present. This means that “huge” protos with only a few fields set are quite sparse.\nrepeated fields are a bit more complicated. Ordinary (not packed) repeated fields emit one record for every element of the field. Thus, if we have\nmessage Test4 { optional string d = 4; repeated int32 e = 5; } and we construct a Test4 message with d set to \"hello\", and e set to 1, 2, and 3, this could be encoded as `220568656c6c6f280128022803`, or written out as Protoscope,\n4: {\"hello\"} 5: 1 5: 2 5: 3 However, records for e do not need to appear consecutively, and can be interleaved with other fields; only the order of records for the same field with respect to each other is preserved. Thus, this could also have been encoded as\n5: 1 5: 2 4: {\"hello\"} 5: 3 There is no special treatment for oneofs in the wire format.\nLast One Wins Normally, an encoded message would never have more than one instance of a non-repeated field. However, parsers are expected to handle the case in which they do. For numeric types and strings, if the same field appears multiple times, the parser accepts the last value it sees. For embedded message fields, the parser merges multiple instances of the same field, as if with the Message::MergeFrom method – that is, all singular scalar fields in the latter instance replace those in the former, singular embedded messages are merged, and repeated fields are concatenated. The effect of these rules is that parsing the concatenation of two encoded messages produces exactly the same result as if you had parsed the two messages separately and merged the resulting objects. That is, this:\nMyMessage message; message.ParseFromString(str1 + str2); is equivalent to this:\nMyMessage message, message2; message.ParseFromString(str1); message2.ParseFromString(str2); message.MergeFrom(message2); This property is occasionally useful, as it allows you to merge two messages (by concatenation) even if you do not know their types.\nPacked Repeated Fields Starting in v2.1.0, repeated fields of scalar type can be declared as “packed”. In proto2 this is done with the [packed=true], but in proto3 it is the default.\nInstead of being encoded as one record per entry, they are encoded as a single LEN record that contains each element concatenated. To decode, elements are decoded from the LEN record one by one until the payload is exhausted. The start of the next element is determined by the length of the previous, which itself depends on the type of the field.\nFor example, imagine you have the message type:\nmessage Test5 { repeated int32 f = 6 [packed=true]; } Now let’s say you construct a Test5, providing the values 3, 270, and 86942 for the repeated field f. Encoded, this gives us `3206038e029ea705`, or as Protoscope text,\n6: {3 270 86942} Only repeated fields of primitive numeric types can be declared “packed”. These are types that would normally use the VARINT, I32, or I64 wire types.\nNote that although there’s usually no reason to encode more than one key-value pair for a packed repeated field, parsers must be prepared to accept multiple key-value pairs. In this case, the payloads should be concatenated. Each pair must contain a whole number of elements. The following is a valid encoding of the same message above that parsers must accept:\n6: {3 270} 6: {86942} Protocol buffer parsers must be able to parse repeated fields that were compiled as packed as if they were not packed, and vice versa. This permits adding [packed=true] to existing fields in a forward- and backward-compatible way.\nMaps Map fields are just a shorthand for a special kind of repeated field. If we have\nmessage Test6 { map\u003cstring, int32\u003e g = 7; } this is actually the same as\nmessage Test6 { message g_Entry { optional string key = 1; optional int32 value = 2; } repeated g_Entry g = 7; } Thus, maps are encoded exactly like a repeated message field: as a sequence of LEN-typed records, with two fields each.\nGroups Groups are a deprecated feature that should not be used, but they remain in the wire format, and deserve a passing mention.\nA group is a bit like a submessage, but it is delimited by special tags rather than by a LEN prefix. Each group in a message has a field number, which is used on these special tags.\nA group with field number 8 begins with an 8:SGROUP tag. SGROUP records have empty payloads, so all this does is denote the start of the group. Once all the fields in the group are listed, a corresponding 8:EGROUP tag denotes its end. EGROUP records also have no payload, so 8:EGROUP is the entire record. Group field numbers need to match up. If we encounter 7:EGROUP where we expect 8:EGROUP, the message is mal-formed.\nProtoscope provides a convenient syntax for writing groups. Instead of writing\n8:SGROUP 1: 2 3: {\"foo\"} 8:EGROUP Protoscope allows\n8: !{ 1: 2 3: {\"foo\"} } This will generate the appropriate start and end group markers. The !{} syntax can only occur immediately after an un-typed tag expression, like 8:.\nField Order Field numbers may be declared in any order in a .proto file. The order chosen has no effect on how the messages are serialized.\nWhen a message is serialized, there is no guaranteed order for how its known or unknown fields will be written. Serialization order is an implementation detail, and the details of any particular implementation may change in the future. Therefore, protocol buffer parsers must be able to parse fields in any order.\nImplications Do not assume the byte output of a serialized message is stable. This is especially true for messages with transitive bytes fields representing other serialized protocol buffer messages. By default, repeated invocations of serialization methods on the same protocol buffer message instance may not produce the same byte output. That is, the default serialization is not deterministic. Deterministic serialization only guarantees the same byte output for a particular binary. The byte output may change across different versions of the binary. The following checks may fail for a protocol buffer message instance foo: foo.SerializeAsString() == foo.SerializeAsString() Hash(foo.SerializeAsString()) == Hash(foo.SerializeAsString()) CRC(foo.SerializeAsString()) == CRC(foo.SerializeAsString()) FingerPrint(foo.SerializeAsString()) == FingerPrint(foo.SerializeAsString()) Here are a few example scenarios where logically equivalent protocol buffer messages foo and bar may serialize to different byte outputs: bar is serialized by an old server that treats some fields as unknown. bar is serialized by a server that is implemented in a different programming language and serializes fields in different order. bar has a field that serializes in a non-deterministic manner. bar has a field that stores a serialized byte output of a protocol buffer message which is serialized differently. bar is serialized by a new server that serializes fields in a different order due to an implementation change. foo and bar are concatenations of the same individual messages in a different order. Condensed Reference Card The following provides the most prominent parts of the wire format in an easy-to-reference format.\nmessage := (tag value)* tag := (field \u003c\u003c 3) bit-or wire_type; encoded as varint value := varint for wire_type == VARINT, i32 for wire_type == I32, i64 for wire_type == I64, len-prefix for wire_type == LEN, \u003cempty\u003e for wire_type == SGROUP or EGROUP varint := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64; encoded as varints (sintN are ZigZag-encoded first) i32 := sfixed32 | fixed32 | float; encoded as 4-byte little-endian; memcpy of the equivalent C types (u?int32_t, float) i64 := sfixed64 | fixed64 | double; encoded as 8-byte little-endian; memcpy of the equivalent C types (u?int32_t, float) len-prefix := size (message | string | bytes | packed); size encoded as varint string := valid UTF-8 string (e.g. ASCII); max 2GB of bytes bytes := any sequence of 8-bit bytes; max 2GB of bytes packed := varint* | i32* | i64*, consecutive values of the type specified in `.proto` See also the Protoscope Language Reference.\nKey message := (tag value)* A message is encoded as a sequence of zero or more pairs of tags and values. tag := (field \u003c\u003c 3) bit-or wire_type A tag is a combination of a wire_type, stored in the least significant three bits, and the field number that is defined in the .proto file. value := varint for wire_type == VARINT, ... A value is stored differently depending on the wire_type specified in the tag. varint := int32 | int64 | uint32 | uint64 | bool | enum | sint32 | sint64 You can use varint to store any of the listed data types. i32 := sfixed32 | fixed32 | float You can use fixed32 to store any of the listed data types. i64 := sfixed64 | fixed64 | double You can use fixed64 to store any of the listed data types. len-prefix := size (message | string | bytes | packed) A length-prefixed value is stored as a length (encoded as a varint), and then one of the listed data types. string := valid UTF-8 string (e.g. ASCII) As described, a string must use UTF-8 character encoding. A string cannot exceed 2GB. bytes := any sequence of 8-bit bytes As described, bytes can store custom data types, up to 2GB in size. packed := varint* | i32* | i64* Use the packed data type when you are storing consecutive values of the type described in the protocol definition. The tag is dropped for values after the first, which amortizes the costs of tags to one per field, rather than per element. ","categories":"","description":"This topic explains how Protocol Buffers encodes data to files or to the wire.","excerpt":"This topic explains how Protocol Buffers encodes data to files or to …","ref":"/programming-guides/encoding/","tags":"","title":"Encoding"},{"body":"This page describes some commonly-used design patterns for dealing with Protocol Buffers. You can also send design and usage questions to the Protocol Buffers discussion group.\nStreaming Multiple Messages If you want to write multiple messages to a single file or stream, it is up to you to keep track of where one message ends and the next begins. The Protocol Buffer wire format is not self-delimiting, so protocol buffer parsers cannot determine where a message ends on their own. The easiest way to solve this problem is to write the size of each message before you write the message itself. When you read the messages back in, you read the size, then read the bytes into a separate buffer, then parse from that buffer. (If you want to avoid copying bytes to a separate buffer, check out the CodedInputStream class (in both C++ and Java) which can be told to limit reads to a certain number of bytes.)\nLarge Data Sets Protocol Buffers are not designed to handle large messages. As a general rule of thumb, if you are dealing in messages larger than a megabyte each, it may be time to consider an alternate strategy.\nThat said, Protocol Buffers are great for handling individual messages within a large data set. Usually, large data sets are a collection of small pieces, where each small piece is structured data. Even though Protocol Buffers cannot handle the entire set at once, using Protocol Buffers to encode each piece greatly simplifies your problem: now all you need is to handle a set of byte strings rather than a set of structures.\nProtocol Buffers do not include any built-in support for large data sets because different situations call for different solutions. Sometimes a simple list of records will do while other times you want something more like a database. Each solution should be developed as a separate library, so that only those who need it need pay the costs.\nSelf-describing Messages Protocol Buffers do not contain descriptions of their own types. Thus, given only a raw message without the corresponding .proto file defining its type, it is difficult to extract any useful data.\nHowever, the contents of a .proto file can itself be represented using protocol buffers. The file src/google/protobuf/descriptor.proto in the source code package defines the message types involved. protoc can output a FileDescriptorSet—which represents a set of .proto files—using the --descriptor_set_out option. With this, you can define a self-describing protocol message like so:\nsyntax = \"proto3\"; import \"google/protobuf/any.proto\"; import \"google/protobuf/descriptor.proto\"; message SelfDescribingMessage { // Set of FileDescriptorProtos which describe the type and its dependencies. google.protobuf.FileDescriptorSet descriptor_set = 1; // The message and its type, encoded as an Any message. google.protobuf.Any message = 2; } By using classes like DynamicMessage (available in C++ and Java), you can then write tools which can manipulate SelfDescribingMessages.\nAll that said, the reason that this functionality is not included in the Protocol Buffer library is because we have never had a use for it inside Google.\nThis technique requires support for dynamic messages using descriptors. Check that your platforms support this feature before using self-describing messages.\n","categories":"","description":"This topic describes some commonly-used design patterns for dealing with Protocol Buffers.","excerpt":"This topic describes some commonly-used design patterns for dealing …","ref":"/programming-guides/techniques/","tags":"","title":"Techniques"},{"body":"Many open source projects seek to add useful functionality on top of Protocol Buffers. For a list of links to projects we know about, see the third-party add-ons wiki page.\n","categories":"","description":"This topic links out to many open source projects that seek to add useful functionality on top of Protocol Buffers.","excerpt":"This topic links out to many open source projects that seek to add …","ref":"/programming-guides/addons/","tags":"","title":"Third-party Add-ons"},{"body":"This application note explains the various presence tracking disciplines for protobuf fields. It also explains the behaviour of explicit presence tracking for singular proto3 fields with basic types.\nBackground Field presence is the notion of whether a protobuf field has a value. There are two different manifestations of presence for protobufs: no presence, where the generated message API stores field values (only), and explicit presence, where the API also stores whether or not a field has been set.\nHistorically, proto2 has mostly followed explicit presence, while proto3 exposes only no presence semantics. Singular proto3 fields of basic types (numeric, string, bytes, and enums) which are defined with the optional label have explicit presence, like proto2 (this feature is enabled by default as release 3.15).\nPresence Disciplines Presence disciplines define the semantics for translating between the API representation and the serialized representation. The no presence discipline relies upon the field value itself to make decisions at (de)serialization time, while the explicit presence discipline relies upon the explicit tracking state instead.\nPresence in Tag-value stream (Wire Format) Serialization The wire format is a stream of tagged, self-delimiting values. By definition, the wire format represents a sequence of present values. In other words, every value found within a serialization represents a present field; furthermore, the serialization contains no information about not-present values.\nThe generated API for a proto message includes (de)serialization definitions which translate between API types and a stream of definitionally present (tag, value) pairs. This translation is designed to be forward- and backward-compatibile across changes to the message definition; however, this compatibility introduces some (perhaps surprising) considerations when deserializing wire-formatted messages:\nWhen serializing, fields with no presence are not serialized if they contain their default value. For numeric types, the default is 0. For enums, the default is the zero-valued enumerator. For strings, bytes, and repeated fields, the default is the zero-length value. For messages, the default is the language-specific null value. “Empty” length-delimited values (such as empty strings) can be validly represented in serialized values: the field is “present,” in the sense that it appears in the wire format. However, if the generated API does not track presence, then these values may not be re-serialized; i.e., the empty field may be “not present” after a serialization round-trip. When deserializing, duplicate field values may be handled in different ways depending on the field definition. Duplicate repeated fields are typically appended to the field’s API representation. (Note that serializing a packed repeated field produces only one, length-delimited value in the tag stream.) Duplicate optional field values follow the rule that “the last one wins.” oneof fields expose the API-level invariant that only one field is set at a time. However, the wire format may include multiple (tag, value) pairs which notionally belong to the oneof. Similar to optional fields, the generated API follows the “last one wins” rule. Out-of-range values are not returned for enum fields in generated proto2 APIs. However, out-of-range values may be stored as unknown fields in the API, even though the wire-format tag was recognized. Presence in Named-field Mapping Formats Protobufs can be represented in human-readable, textual forms. Two notable formats are TextFormat (the output format produced by generated message DebugString methods) and JSON.\nThese formats have correctness requirements of their own, and are generally stricter than tagged-value stream formats. However, TextFormat more closely mimics the semantics of the wire format, and does, in certain cases, provide similar semantics (for example, appending repeated name-value mappings to a repeated field). In particular, similar to the wire format, TextFormat only includes fields which are present.\nJSON is a much stricter format, however, and cannot validly represent some semantics of the wire format or TextFormat.\nNotably, JSON elements are semantically unordered, and each member must have a unique name. This is different from TextFormat rules for repeated fields. JSON may include fields that are “not present,” unlike the no presence discipline for other formats: JSON defines a null value, which may be used to represent a defined but not-present field. Repeated field values may be included in the formatted output, even if they are equal to the default (an empty list). Because JSON elements are unordered, there is no way to unambiguously interpret the “last one wins” rule. In most cases, this is fine: JSON elements must have unique names: repeated field values are not valid JSON, so they do not need to be resolved as they are for TextFormat. However, this means that it may not be possible to interpret oneof fields unambiguously: if multiple cases are present, they are unordered. In theory, JSON can represent presence in a semantic-preserving fashion. In practice, however, presence correctness can vary depending upon implementation choices, especially if JSON was chosen as a means to interoperate with clients not using protobufs.\nPresence in Proto2 APIs This table outlines whether presence is tracked for fields in proto2 APIs (both for generated APIs and using dynamic reflection):\nField type Explicit Presence Singular numeric (integer or floating point) ✔️ Singular enum ✔️ Singular string or bytes ✔️ Singular message ✔️ Repeated Oneofs ✔️ Maps Singular fields (of all types) track presence explicitly in the generated API. The generated message interface includes methods to query presence of fields. For example, the field foo has a corresponding has_foo method. (The specific name follows the same language-specific naming convention as the field accessors.) These methods are sometimes referred to as “hazzers” within the protobuf implementation.\nSimilar to singular fields, oneof fields explicitly track which one of the members, if any, contains a value. For example, consider this example oneof:\noneof foo { int32 a = 1; float b = 2; } Depending on the target language, the generated API would generally include several methods:\nA hazzer for the oneof: has_foo A oneof case method: foo Hazzers for the members: has_a, has_b Getters for the members: a, b Repeated fields and maps do not track presence: there is no distinction between an empty and a not-present repeated field.\nPresence in Proto3 APIs This table outlines whether presence is tracked for fields in proto3 APIs (both for generated APIs and using dynamic reflection):\nField type optional Explicit Presence Singular numeric (integer or floating point) No Singular enum No Singular string or bytes No Singular numeric (integer or floating point) Yes ✔️ Singular enum Yes ✔️ Singular string or bytes Yes ✔️ Singular message Yes ✔️ Singular message No ✔️ Repeated N/A Oneofs N/A ✔️ Maps N/A Similar to proto2 APIs, proto3 does not track presence explicitly for repeated fields. Without the optional label, proto3 APIs do not track presence for basic types (numeric, string, bytes, and enums), either. Oneof fields affirmatively expose presence, although the same set of hazzer methods may not generated as in proto2 APIs.\nUnder the no presence discipline, the default value is synonymous with “not present” for purposes of serialization. To notionally “clear” a field (so it won’t be serialized), an API user would set it to the default value.\nThe default value for enum-typed fields under no presence is the corresponding 0-valued enumerator. Under proto3 syntax rules, all enum types are required to have an enumerator value which maps to 0. By convention, this is an UNKNOWN or similarly-named enumerator. If the zero value is notionally outside the domain of valid values for the application, this behavior can be thought of as tantamount to explicit presence.\nSemantic Differences The no presence serialization discipline results in visible differences from the explicit presence tracking discipline, when the default value is set. For a singular field with numeric, enum, or string type:\nNo presence discipline: Default values are not serialized. Default values are not merged-from. To “clear” a field, it is set to its default value. The default value may mean: the field was explicitly set to its default value, which is valid in the application-specific domain of values; the field was notionally “cleared” by setting its default; or the field was never set. Explicit presence discipline: Explicitly set values are always serialized, including default values. Un-set fields are never merged-from. Explicitly set fields – including default values – are merged-from. A generated has_foo method indicates whether or not the field foo has been set (and not cleared). A generated clear_foo method must be used to clear (i.e., un-set) the value. Considerations for Merging Under the no presence rules, it is effectively impossible for a target field to merge-from its default value (using the protobuf’s API merging functions). This is because default values are skipped, similar to the no presence serialization discipline. Merging only updates the target (merged-to) message using the non-skipped values from the update (merged-from) message.\nThe difference in merging behavior has further implications for protocols which rely on partial “patch” updates. If field presence is not tracked, then an update patch alone cannot represent an update to the default value, because only non-default values are merged-from.\nUpdating to set a default value in this case requires some external mechanism, such as FieldMask. However, if presence is tracked, then all explicitly-set values – even default values – will be merged into the target.\nConsiderations for change-compatibility Changing a field between explicit presence and no presence is a binary-compatible change for serialized values in wire format. However, the serialized representation of the message may differ, depending on which version of the message definition was used for serialization. Specifically, when a “sender” explicitly sets a field to its default value:\nThe serialized value following no presence discipline does not contain the default value, even though it was explicitly set. The serialized value following explicit presence discipline contains every “present” field, even if it contains the default value. This change may or may not be safe, depending on the application’s semantics. For example, consider two clients with different versions of a message definition.\nClient A uses this definition of the message, which follows the explicit presence serialization discipline for field foo:\nsyntax = \"proto3\"; message Msg { optional int32 foo = 1; } Client B uses a definition of the same message, except that it follows the no presence discipline:\nsyntax = \"proto3\"; message Msg { int32 foo = 1; } Now, consider a scenario where client A observes foo’s presence as the clients repeatedly exchange the “same” message by deserializing and reserializing:\n// Client A: Msg m_a; m_a.set_foo(1); // non-default value assert(m_a.has_foo()); // OK Send(m_a.SerializeAsString()); // to client B // Client B: Msg m_b; m_b.ParseFromString(Receive()); // from client A assert(m_b.foo() == 1); // OK Send(m_b.SerializeAsString()); // to client A // Client A: m_a.ParseFromString(Receive()); // from client B assert(m_a.foo() == 1); // OK assert(m_a.has_foo()); // OK m_a.set_foo(0); // default value Send(m_a.SerializeAsString()); // to client B // Client B: Msg m_b; m_b.ParseFromString(Receive()); // from client A assert(m_b.foo() == 0); // OK Send(m_b.SerializeAsString()); // to client A // Client A: m_a.ParseFromString(Receive()); // from client B assert(m_a.foo() == 0); // OK assert(m_a.has_foo()); // FAIL If client A depends on explicit presence for foo, then a “round trip” through client B will be lossy from the perspective of client A. In the example, this is not a safe change: client A requires (by assert) that the field is present; even without any modifications through the API, that requirement fails in a value- and peer-dependent case.\nHow to Enable Explicit Presence in Proto3 These are the general steps to use field tracking support for proto3:\nAdd an optional field to a .proto file. Run protoc (at least v3.15, or v3.12 using --experimental_allow_proto3_optional flag). Use the generated “hazzer” methods and “clear” methods in application code, instead of comparing or setting default values. .proto File Changes This is an example of a proto3 message with fields which follow both no presence and explicit presence semantics:\nsyntax = \"proto3\"; package example; message MyMessage { // No presence: int32 not_tracked = 1; // Explicit presence: optional int32 tracked = 2; } protoc Invocation Presence tracking for proto3 messages is enabled by default since v3.15.0 release, formerly up until v3.12.0 the --experimental_allow_proto3_optional flag was required when using presence tracking with protoc.\nUsing the Generated Code The generated code for proto3 fields with explicit presence (the optional label) will be the same as it would be in a proto2 file.\nThis is the definition used in the “no presence” examples below:\nsyntax = \"proto3\"; package example; message Msg { int32 foo = 1; } This is the definition used in the “explicit presence” examples below:\nsyntax = \"proto3\"; package example; message Msg { optional int32 foo = 1; } In the examples, a function GetProto constructs and returns a message of type Msg with unspecified contents.\nC++ Example No presence:\nMsg m = GetProto(); if (m.foo() != 0) { // \"Clear\" the field: m.set_foo(0); } else { // Default value: field may not have been present. m.set_foo(1); } Explicit presence:\nMsg m = GetProto(); if (m.has_foo()) { // Clear the field: m.clear_foo(); } else { // Field is not present, so set it. m.set_foo(1); } C# Example No presence:\nvar m = GetProto(); if (m.Foo != 0) { // \"Clear\" the field: m.Foo = 0; } else { // Default value: field may not have been present. m.Foo = 1; } Explicit presence:\nvar m = GetProto(); if (m.HasFoo) { // Clear the field: m.ClearFoo(); } else { // Field is not present, so set it. m.Foo = 1; } Go Example No presence:\nm := GetProto() if m.Foo != 0 { // \"Clear\" the field: m.Foo = 0 } else { // Default value: field may not have been present. m.Foo = 1 } Explicit presence:\nm := GetProto() if m.Foo != nil { // Clear the field: m.Foo = nil } else { // Field is not present, so set it. m.Foo = proto.Int32(1) } Java Example These examples use a Builder to demonstrate clearing. Simply checking presence and getting values from a Builder follows the same API as the message type.\nNo presence:\nMsg.Builder m = GetProto().toBuilder(); if (m.getFoo() != 0) { // \"Clear\" the field: m.setFoo(0); } else { // Default value: field may not have been present. m.setFoo(1); } Explicit presence:\nMsg.Builder m = GetProto().toBuilder(); if (m.hasFoo()) { // Clear the field: m.clearFoo() } else { // Field is not present, so set it. m.setFoo(1); } Python Example No presence:\nm = example.Msg() if m.foo != 0: # \"Clear\" the field: m.foo = 0 else: # Default value: field may not have been present. m.foo = 1 Explicit presence:\nm = example.Msg() if m.HasField('foo'): # Clear the field: m.ClearField('foo') else: # Field is not present, so set it. m.foo = 1 Ruby Example No presence:\nm = Msg.new if m.foo != 0 # \"Clear\" the field: m.foo = 0 else # Default value: field may not have been present. m.foo = 1 end Explicit presence:\nm = Msg.new if m.has_foo? # Clear the field: m.clear_foo else # Field is not present, so set it. m.foo = 1 end Javascript Example No presence:\nvar m = new Msg(); if (m.getFoo() != 0) { // \"Clear\" the field: m.setFoo(0); } else { // Default value: field may not have been present. m.setFoo(1); } Explicit presence:\nvar m = new Msg(); if (m.hasFoo()) { // Clear the field: m.clearFoo() } else { // Field is not present, so set it. m.setFoo(1); } Objective C Example No presence:\nMsg *m = [[Msg alloc] init]; if (m.foo != 0) { // \"Clear\" the field: m.foo = 0; } else { // Default value: field may not have been present. m.foo = 1; } Explicit presence:\nMsg *m = [[Msg alloc] init]; if (m.hasFoo()) { // Clear the field: [m clearFoo]; } else { // Field is not present, so set it. [m setFoo:1]; } ","categories":"","description":"This topic explains the various presence-tracking disciplines for protobuf fields. It also explains the behavior of explicit presence-tracking for singular proto3 fields with basic types.","excerpt":"This topic explains the various presence-tracking disciplines for …","ref":"/programming-guides/field_presence/","tags":"","title":"Application Note: Field Presence"},{"body":"Clients and servers are never updated at exactly the same time - even when you try to update them at the same time. One or the other may get rolled back. Don’t assume that you can make a breaking change and it’ll be okay because the client and server are in sync.\nDon’t Re-use a Tag Number Never re-use a tag number. It messes up deserialization. Even if you think no one is using the field, don’t re-use a tag number. If the change was live ever, there could be serialized versions of your proto in a log somewhere. Or there could be old code in another server that will break.\nDon’t Change the Type of a Field Almost never change the type of a field; it’ll mess up deserialization, same as re-using a tag number. The protobuf docs outline a small number of cases that are okay (for example, going between int32, uint32, int64 and bool). However, you’re guaranteed to break if you change a field’s message type (for example, going from a Foo message to a Bar message).\nDon’t Add a Required Field Never add a required field, instead add // required to document the API contract. Required fields are considered harmful by so many they were removed from proto3 completely. Make all fields optional or repeated. You never know how long a message type is going to last and whether someone will be forced to fill in your required field with an empty string or zero in four years when it’s no longer logically required but the proto still says it is.\nDon’t Make a Message with Lots of Fields Don’t make a message with “lots” (think: hundreds) of fields. In C++ every field adds roughly 65 bits to the in-memory object size whether it’s populated or not (8 bytes for the pointer and, if the field is declared as optional, another bit in a bitfield that keeps track of whether the field is set). When your proto grows too large, the generated code may not even compile (for example, in Java there is a hard limit on the size of a method ).\nDo Include an Unspecified Value in an Enum Enums should include a default FOO_UNSPECIFIED value as the first value in the declaration . When new values are added to a proto2 enum, old clients will see the field as unset and the getter will return the default value or the first-declared value if no default exists . For consistent behavior with proto enums, the first declared enum value should be a default FOO_UNSPECIFIED value and should use tag 0. It may be tempting to declare this default as a semantically meaningful value but as a general rule, do not, to aid in the evolution of your protocol as new enum values are added over time. All enum values declared under a container message are in the same C++ namespace, so prefix the unspecified value with the enum’s name to avoid compilation errors. If you’ll never need cross-language constants, an int32 will preserve unknown values and generates less code. Note that proto enums require the first value to be zero and can round-trip (deserialize, serialize) an unknown enum value.\nDon’t Use C/C++ Macro Constants for Enum Values Using words that have already been defined by the C++ language - specifically, in its headers such as math.h, may cause compilation errors if the #include statement for one of those headers appears before the one for .proto.h. Avoid using macro constants such as “NULL,” “NAN,” and “DOMAIN” as enum values.\nDo Use Well-Known Types and Common Types Embedding the following common, shared types is strongly encouraged. Do not use int32 timestamp_seconds_since_epoch or int64 timeout_millis in your code when a perfectly suitable common type already exists!\nWell-Known Types: duration is a signed, fixed-length span of time (for example, 42s). timestamp is a point in time independent of any time zone or calendar (for example, 2017-01-15T01:30:15.01Z). field_mask is a set of symbolic field paths (for example, f.b.d). Common Types: interval is a time interval independent of time zone or calendar (for example, 2017-01-15T01:30:15.01Z - 2017-01-16T02:30:15.01Z). date is a whole calendar date (for example, 2005-09-19). dayofweek is a day of week (for example, Monday). timeofday is a time of day (for example, 10:42:23). latlng is a latitude/longitude pair (for example, 37.386051 latitude and -122.083855 longitude). money is an amount of money with its currency type (for example, 42 USD). postal_address is a postal address (for example, 1600 Amphitheatre Parkway Mountain View, CA 94043 USA). color is a color in the RGBA color space. month is a month of year (for example, April). Do Define Widely-used Message Types in Separate Files If you’re defining message types or enums that you hope/fear/expect to be widely used outside your immediate team, consider putting them in their own file with no dependencies. Then it’s easy for anyone to use those types without introducing the transitive dependencies in your other proto files.\nDo Reserve Tag Numbers for Deleted Fields When you delete a field that’s no longer used, reserve its tag number so that no one accidentally re-uses it in the future. Just reserved 2, 3; is enough. No type required (lets you trim dependencies!). You can also reserve names to avoid recycling now-deleted field names: reserved \"foo\", \"bar\";.\nDo Reserve Numbers for Deleted Enum Values When you delete an enum value that’s no longer used, reserve its number so that no one accidentally re-uses it in the future. Just reserved 2, 3; is enough. You can also reserve names to avoid recycling now-deleted value names: reserved \"FOO\", \"BAR\";.\nDon’t Change the Default Value of a Field Almost never change the default value of a proto field. This causes version skew between clients and servers. A client reading an unset value will see a different result than a server reading the same unset value when their builds straddle the proto change. Proto3 removed the ability to set default values.\nDon’t Go from Repeated to Scalar Although it won’t cause crashes, you’ll lose data. For JSON, a mismatch in repeatedness will lose the whole message. For numeric proto3 fields and proto2 packed fields, going from repeated to scalar will lose all data in that field. For non-numeric proto3 fields and un-annotated proto2 fields, going from repeated to scalar will result in the last deserialized value “winning.”\nGoing from scalar to repeated is OK in proto2 and in proto3 with [packed=false] because for binary serialization the scalar value becomes a one-element list .\nDo Follow the Style Guide for Generated Code Proto generated code is referred to in normal code. Ensure that options in .proto file do not result in generation of code which violate the style guide. For example:\njava_outer_classname should follow https://google.github.io/styleguide/javaguide.html#s5.2.2-class-names\njava_package and java_alt_package should follow https://google.github.io/styleguide/javaguide.html#s5.2.1-package-names\npackage, although used for Java when java_package is not present, always directly corresponds to C++ namespace and thus should follow https://google.github.io/styleguide/cppguide.html#Namespace_Names. If these style guides conflict, use java_package for Java.\nNever Use Text-format Messages for Interchange Deserializing of text-format protocol buffers will fail when the binary is unaware of a field rename, a new field, or a new extension. In general, text-format is not future proof. Use text-format for human editing and debugging only.\nNever Rely on Serialization Stability Across Builds The stability of proto serialization is not guaranteed across binaries or across builds of the same binary. Do not rely on it when, for example, building cache keys.\nDon’t Generate Java Protos in the Same Java Package as Other Code Generate Java proto sources into a separate package from your hand-written Java sources. The package, java_package and java_alt_api_package options control where the generated Java sources are emitted. Make sure hand-written Java source code does not also live in that same package. A common practice is to generate your protos into a proto subpackage in your project that only contains those protos (that is, no hand-written source code).\nAppendix API Best Practices This document lists only changes that are extremely likely to cause breakage. For higher-level guidance on how to craft proto API’s that grow gracefully see API Best Practices.\n","categories":"","description":"This topic contains vetted best practices for authoring Protocol Buffers.","excerpt":"This topic contains vetted best practices for authoring Protocol …","ref":"/programming-guides/dos-donts/","tags":"","title":"Proto Best Practices"},{"body":"Updated for proto3. Patches welcome!\nThe suggestions in this document make trade-offs to favor long-term, bug-free evolution. This doc is a complement to Proto Best Practices. It’s not a prescription for Java/C++/Go and other APIs.\nIf you see a proto straying from these guidelines in a code review, point the author to this topic and help spread the word.\nNote These guidelines are just that and many have documented exceptions. For example, if you’re writing a performance-critical backend, you might want to sacrifice flexibility or safety for speed. This topic will help you better understand the trade-offs and make a decision that works for your situation. Precisely, Concisely Document Most Fields and Messages Chances are good your proto will be inherited and used by people who don’t know what you were thinking when you wrote or modified it. Document each field in terms that will be useful to a new team-member or client with little knowledge of your system.\nSome concrete examples:\n// Bad: Option to enable Foo // Good: Configuration controlling the behavior of the Foo feature. message FeatureFooConfig { // Bad: Sets whether the feature is enabled // Good: Required field indicating whether the Foo feature // is enabled for account_id. Must be false if account_id's // FOO_OPTIN Gaia bit is not set. optional bool enabled; } // Bad: Foo object. // Good: Client-facing representation of a Foo (what/foo) exposed in APIs. message Foo { // Bad: Title of the foo. // Good: Indicates the user-supplied title of this Foo, with no // normalization or escaping. // An example title: \"Picture of my cat in a box \u003c3 \u003c3 !!!\" optional string title [(max_length) = 512]; } // Bad: Foo config. // Less-Bad: If the most useful comment is re-stating the name, better to omit // the comment. FooConfig foo_config = 3; Document the constraints, expectations and interpretation of each field in as few words as possible.\nYou can use custom proto annotations. See Custom Options to define cross-language constants like max_length in the example above. Supported in proto2 and proto3.\nOver time, documentation of an interface can get longer and longer. The length takes away from the clarity. When the documentation is genuinely unclear, fix it, but look at it holistically and aim for brevity.\nUse Different Messages for Wire and Storage If a top-level proto you expose to clients is the same one you store on disk, you’re headed for trouble. More and more binaries will depend on your API over time, making it harder to change. You’ll want the freedom to change your storage format without impacting your clients. Layer your code so that modules deal either with client protos, storage protos, or translation.\nWhy? You might want to swap your underlying storage system. You might want to normalize—or denormalize—data differently. You might realize that parts of your client-exposed proto make sense to store in RAM while other parts make sense to go on disk.\nWhen it comes to protos nested one or more levels within a top-level request or response, the case for separating storage and wire protos isn’t as strong, and depends on how closely you’re willing to couple your clients to those protos.\nThere’s a cost in maintaining the translation layer, but it quickly pays off once you have clients and have to do your first storage changes.\nYou might be tempted to share protos and diverge “when you need to.” With a perceived high cost to diverge and no clear place to put internal fields, your API will accrue fields clients either don’t understand or begin to depend on without your knowledge.\nBy starting with separate proto files, your team will know where to add internal fields without polluting your API. In the early days, the wire proto can be tag-for-tag identical with an automatic translation layer (think: byte copying or proto reflection). Proto annotations can also power an automatic translation layer.\nThe following are exceptions to the rule:\nIf the proto field is one of a common type, such as google.type or google.protobuf, then using that type both as storage and API is acceptable.\nIf your service is extremely performance-sensitive, it may be worth trading flexibility for execution speed. If your service doesn’t have millions of QPS with millisecond latency, you’re probably not the exception.\nIf all of the following are true:\nyour service is the storage system your system doesn’t make decisions based on your clients’ structured data your system simply stores, loads, and perhaps provides queries at your client’s request Note that if you are implementing something like a logging system or a proto-based wrapper around a generic storages system, then you probably want to aim to have your clients’ messages transit into your storage backend as opaquely as possible so that you don’t create a dependency nexus. Consider using extensions or Encode Opaque Data in Strings by Web-safe Encoding Binary Proto Serialization.\nFor Mutations, Support Partial Updates or Append-Only Updates, Not Full Replaces Don’t make an UpdateFooRequest that only takes a Foo.\nIf a client doesn’t preserve unknown fields, they will not have the newest fields of GetFooResponse leading to data loss on a round-trip. Some systems don’t preserve unknown fields. Proto2 and proto3 implementations do preserve unknown fields unless the application drops the unknown fields explicitly. In general, public APIs should drop unknown fields on server-side to prevent security attack via unknown fields. For example, garbage unknown fields may cause a server to fail when it starts to use them as new fields in the future.\nAbsent documentation, handling of optional fields is ambiguous. Will UpdateFoo clear the field? That leaves you open to data loss when the client doesn’t know about the field. Does it not touch a field? Then how can clients clear the field? Neither are good.\nFix #1: Use an Update Field-mask Have your client pass which fields it wants to modify and include only those fields in the update request. Your server leaves other fields alone and updates only those specified by the mask. In general, the structure of your mask should mirror the structure of the response proto; that is, if Foo contains Bar, FooMask contains BarMask.\nFix #2: Expose More Narrow Mutations That Change Individual Pieces For example, instead of UpdateEmployeeRequest, you might have: PromoteEmployeeRequest, SetEmployeePayRequest, TransferEmployeeRequest, etc.\nCustom update methods are easier to monitor, audit, and secure than a very flexible update method. They’re also easier to implement and call. A large number of them can increase the cognitive load of an API.\nDon’t Include Primitive Types in a Top-level Request or Response Proto Many of the pitfalls described elsewhere in this doc are solved with this rule. For example:\nTelling clients that a repeated field is unset in storage versus not-populated in this particular call can be done by wrapping the repeated field in a message.\nCommon request options that are shared between requests naturally fall out of following this rule. Read and write field masks fall out of this.\nYour top-level proto should almost always be a container for other messages that can grow independently.\nEven when you only need a single primitive type today, having it wrapped in a message gives you a clear path to expand that type and share the type among other methods that return the similar values. For example:\nmessage MultiplicationResponse { // Bad: What if you later want to return complex numbers and have an // AdditionResponse that returns the same multi-field type? optional double result; // Good: Other methods can share this type and it can grow as your // service adds new features (units, confidence intervals, etc.). optional NumericResult result; } message NumericResult { optional double real_value; optional double complex_value; optional UnitType units; } One exception to top-level primitives: Opaque strings (or bytes) that encode a proto but are only built and parsed on the server. Continuation tokens, version info tokens and IDs can all be returned as strings if the string is actually an encoding of a structured proto.\nNever Use Booleans for Something That Has Two States Now, but Might Have More Later If you are using boolean for a field, make sure that the field is indeed describing just two possible states (for all time, not just now and the near future). Often, the flexibility of an enum, int, or message turns out to be worth it.\nFor example, in returning a stream of posts a developer may need to indicate whether a post should be rendered in two-columns or not based on the current mocks from UX. Even though a boolean is all that’s needed today, nothing prevents UX from introducing two-row posts, three-column posts or four-square posts in a future version.\nmessage GooglePlusPost { // Bad: Whether to render this post across two columns. optional bool big_post; // Good: Rendering hints for clients displaying this post. // Clients should use this to decide how prominently to render this // post. If absent, assume a default rendering. optional LayoutConfig layout_config; } message Photo { // Bad: True if it's a GIF. optional bool gif; // Good: File format of the referenced photo (for example, GIF, WebP, PNG). optional PhotoType type; } Be cautious about adding states to an enum that conflates concepts.\nIf a state introduces a new dimension to the enum or implies multiple application behaviors, you almost certainly want another field.\nRarely Use an Integer Field for an ID It’s tempting to use an int64 as an identifier for an object. Opt instead for a string.\nThis lets you change your ID space if you need to and reduces the chance of collisions. 2^64 isn’t as big as it used to be.\nYou can also encode a structured identifier as a string which encourages clients to treat it as an opaque blob. You still must have a proto backing the string, but you can serialize the proto to a string field (encoded as web-safe Base64) which removes any of the internal details from the client-exposed API. In this case follow the guidelines below.\nmessage GetFooRequest { // Which Foo to fetch. optional string foo_id; } // Serialized and websafe-base64-encoded into the GetFooRequest.foo_id field. message InternalFooRef { // Only one of these two is set. Foos that have already been // migrated use the spanner_foo_id and Foos still living in // Caribou Storage Server have a classic_foo_id. optional bytes spanner_foo_id; optional int64 classic_foo_id; } If you start off with your own serialization scheme to represent your IDs as strings, things can get weird quickly. That’s why it’s often best to start with an internal proto that backs your string field.\nDon’t Encode Data in a String That You Expect a Client to Construct or Parse It’s less efficient over the wire, more work for the consumer of the proto, and confusing for someone reading your documentation. Your clients also have to wonder about the encoding: Are lists comma-separated? Did I escape this untrusted data correctly? Are numbers base-10? Better to have clients send an actual message or primitive type. It’s more compact over the wire and clearer for your clients.\nThis gets especially bad when your service acquires clients in several languages. Now each will have to choose the right parser or builder—or worse—write one.\nMore generally, choose the right primitive type. See the Scalar Value Types table in the Protocol Buffer Language Guide.\nReturning HTML in a Front-End Proto With a JavaScript client, it’s tempting to return HTML or JSON in a field of your API. This is a slippery slope towards tying your API to a specific UI. Here are three concrete dangers:\nA “scrappy” non-web client will end up parsing your HTML or JSON to get the data they want leading to fragility if you change formats and vulnerabilities if their parsing is bad. Your web-client is now vulnerable to an XSS exploit if that HTML is ever returned unsanitized. The tags and classes you’re returning expect a particular style-sheet and DOM structure. From release to release, that structure will change, and you risk a version-skew problem where the JavaScript client is older than the server and the HTML the server returns no longer renders properly on old clients. For projects that release often, this is not an edge case. Other than the initial page load, it’s usually better to return data and use client-side templating to construct HTML on the client .\nEncode Opaque Data in Strings by Web-Safe Encoding Binary Proto Serialization If you do encode opaque data in a client-visible field (continuation tokens, serialized IDs, version infos, and so on), document that clients should treat it as an opaque blob. Always use binary proto serialization, never text-format or something of your own devising for these fields. When you need to expand the data encoded in an opaque field, you’ll find yourself reinventing protocol buffer serialization if you’re not already using it.\nDefine an internal proto to hold the fields that will go in the opaque field (even if you only need one field), serialize this internal proto to bytes then web-safe base-64 encode the result into your string field .\nOne rare exception to using proto serialization: Very occasionally, the compactness wins from a carefully constructed alternative format are worth it.\nDon’t Include Fields that Your Clients Can’t Possibly Have a Use for The API you expose to clients should only be for describing how to interact with your system. Including anything else in it adds cognitive overhead to someone trying to understand it.\nReturning debug data in response protos used to be a common practice, but we have a better way. RPC response extensions (also called “side channels”) let you describe your client interface with one proto and your debugging surface with another.\nSimilarly, returning experiment names in response protos used to be a logging convenience–the unwritten contract was the client would send those experiments back on subsequent actions. The accepted way of accomplishing the same is to do log joining in the analysis pipeline.\nOne exception:\nIf you need continuous, real-time analytics and are on a small machine budget, running log joins might be prohibitive. In cases where cost is a deciding factor, denormalizing log data ahead of time can be a win. If you need log data round-tripped to you, send it to clients as an opaque blob and document the request and response fields.\nCaution: If you need to return or round-trip hidden data on every request , you’re hiding the true cost of using your service and that’s not good either.\nRarely Define a Pagination API Without a Continuation Token message FooQuery { // Bad: If the data changes between the first query and second, each of // these strategies can cause you to miss results. In an eventually // consistent world (that is, storage backed by Bigtable), it's not uncommon // to have old data appear after the new data. Also, the offset- and // page-based approaches all assume a sort-order, taking away some // flexibility. optional int64 max_timestamp_ms; optional int32 result_offset; optional int32 page_number; optional int32 page_size; // Good: You've got flexibility! Return this in a FooQueryResponse and // have clients pass it back on the next query. optional string next_page_token; } The best practice for a pagination API is to use an opaque continuation token (called next_page_token ) backed by an internal proto that you serialize and then WebSafeBase64Escape (C++) or BaseEncoding.base64Url().encode (Java). That internal proto could include many fields. The important thing is it buys you flexibility and–if you choose–it can buy your clients stability in the results.\nDo not forget to validate the fields of this proto as untrustworthy inputs (see note in Encode opaque data in strings).\nmessage InternalPaginationToken { // Track which IDs have been seen so far. This gives perfect recall at the // expense of a larger continuation token--especially as the user pages // back. repeated FooRef seen_ids; // Similar to the seen_ids strategy, but puts the seen_ids in a Bloom filter // to save bytes and sacrifice some precision. optional bytes bloom_filter; // A reasonable first cut and it may work for longer. Having it embedded in // a continuation token lets you change it later without affecting clients. optional int64 max_timestamp_ms; } Group Related Fields into a New Message. Nest Only Fields with High Cohesion message Foo { // Bad: The price and currency of this Foo. optional int price; optional CurrencyType currency; // Better: Encapsulates the price and currency of this Foo. optional CurrencyAmount price; } Only fields with high cohesion should be nested. If the fields are genuinely related, you’ll often want to pass them around together inside a server. That’s easier if they’re defined together in a message. Think:\nCurrencyAmount calculateLocalTax(CurrencyAmount price, Location where) If your CL introduces one field, but that field might have related fields later, preemptively put it in its own message to avoid this:\nmessage Foo { // DEPRECATED! Use currency_amount. optional int price [deprecated = true]; // The price and currency of this Foo. optional google.type.Money currency_amount; } The problem with a nested message is that while CurrencyAmount might be a popular candidate for reuse in other places of your API, Foo.CurrencyAmount might not. In the worst case, Foo.CurrencyAmount is reused, but Foo-specific fields leak into it.\nWhile loose coupling is generally accepted as a best practice when developing systems, that practice may not always apply when designing .proto files. There may be cases in which tightly coupling two units of information (by nesting one unit inside of the other) may make sense. For example, if you are creating a set of fields that appear fairly generic right now but which you anticipate adding specialized fields into at a later time, nesting the message would dissuade others from referencing that message from elsewhere in this or other .proto files.\nmessage Photo { // Bad: It's likely PhotoMetadata will be reused outside the scope of Photo, // so it's probably a good idea not to nest it and make it easier to access. message PhotoMetadata { optional int32 width = 1; optional int32 height = 2; } optional PhotoMetadata metadata = 1; } message FooConfiguration { // Good: Reusing FooConfiguration.Rule outside the scope of FooConfiguration // tightly-couples it with likely unrelated components, nesting it dissuades // from doing that. message Rule { optional float multiplier = 1; } repeated Rule rules = 1; } Include a Field Read Mask in Read Requests // Recommended: use google.protobuf.FieldMask // Alternative one: message FooReadMask { optional bool return_field1; optional bool return_field2; } // Alternative two: message BarReadMask { // Tag numbers of the fields in Bar to return. repeated int32 fields_to_return; } If you use the recommended google.protobuf.FieldMask, you can use the FieldMaskUtil (Java/C++) libraries to automatically filter a proto.\nRead masks set clear expectations on the client side, give them control of how much data they want back and allow the backend to only fetch data the client needs.\nThe acceptable alternative is to always populate every field; that is, treat the request as if there were an implicit read mask with all fields set to true. This can get costly as your proto grows.\nThe worst failure mode is to have an implicit (undeclared) read mask that varies depending on which method populated the message. This anti-pattern leads to apparent data loss on clients that build a local cache from response protos.\nInclude a Version Field to Allow for Consistent Reads When a client does a write followed by a read of the same object, they expect to get back what they wrote–even when the expectation isn’t reasonable for the underlying storage system.\nYour server will read the local value and if the local version_info is less than the expected version_info, it will read from remote replicas to find the latest value. Typically version_info is a proto encoded as a string that includes the datacenter the mutation went to and the timestamp at which it was committed.\nEven systems backed by consistent storage often want a token to trigger the more expensive read-consistent path rather than incurring the cost on every read.\nUse Consistent Request Options for RPCs that Return the Same Data Type An example failure pattern is the request options for a service in which each RPC returns the same data type, but has separate request options for specifying things like maximum comments, embeds supported types list, and so on.\nThe cost of approaching this ad hoc is increased complexity on the client from figuring out how to fill out each request and increased complexity on the server transforming the N request options into a common internal one. A not-small number of real-life bugs are traceable to this example.\nInstead, create a single, separate message to hold request options and include that in each of the top-level request messages. Here’s a better-practices example:\nmessage FooRequestOptions { // Field-level read mask of which fields to return. Only fields that // were requested will be returned in the response. Clients should only // ask for fields they need to help the backend optimize requests. optional FooReadMask read_mask; // Up to this many comments will be returned on each Foo in the response. // Comments that are marked as spam don't count towards the maximum // comments. By default, no comments are returned. optional int max_comments_to_return; // Foos that include embeds that are not on this supported types list will // have the embeds down-converted to an embed specified in this list. If no // supported types list is specified, no embeds will be returned. If an embed // can't be down-converted to one of the supplied supported types, no embed // will be returned. Clients are strongly encouraged to always include at // least the THING_V2 embed type from EmbedTypes.proto. repeated EmbedType embed_supported_types_list; } message GetFooRequest { // What Foo to read. If the viewer doesn't have access to the Foo or the // Foo has been deleted, the response will be empty but will succeed. optional string foo_id; // Clients are required to include this field. Server returns // INVALID_ARGUMENT if FooRequestOptions is left empty. optional FooRequestOptions params; } message ListFooRequest { // Which Foos to return. Searches have 100% recall, but more clauses // impact performance. optional FooQuery query; // Clients are required to include this field. The server returns // INVALID_ARGUMENT if FooRequestOptions is left empty. optional FooRequestOptions params; } Batch/multi-phase Requests Where possible, make mutations atomic. Even more important, make mutations idempotent. A full retry of a partial failure shouldn’t corrupt/duplicate data.\nOccasionally, you’ll need a single RPC that encapsulates multiple operations for performance reasons. What to do on a partial failure? If some succeeded and some failed, it’s best to let clients know.\nConsider setting the RPC as failed and return details of both the successes and failures in an RPC status proto.\nIn general, you want clients who are unaware of your handling of partial failures to still behave correctly and clients who are aware to get extra value.\nCreate Methods that Return or Manipulate Small Bits of Data and Expect Clients to Compose UIs from Batching Multiple Such Requests The ability to query many narrowly specified bits of data in a single round-trip allows a wider range of UX options without server changes by letting the client compose what they need.\nThis is most relevant for front-end and middle-tier servers.\nMany services expose their own batching API.\nMake a One-off RPC when the Alternative is Serial Round-trips on Mobile or Web In cases where a web or mobile client needs to make two queries with a data dependency between them, the current best practice is to create a new RPC that protects the client from the round trip.\nIn the case of mobile, it’s almost always worth saving your client the cost of an extra round-trip by bundling the two service methods together in one new one. For server-to-server calls, the case may not be as clear; it depends on how performance-sensitive your service is and how much cognitive overhead the new method introduces.\nMake Repeated Fields Messages, Not Scalars or Enums A common evolution is that a single repeated field needs to become multiple related repeated fields. If you start with a repeated primitive your options are limited–you either create parallel repeated fields, or define a new repeated field with a new message that holds the values and migrate clients to it.\nIf you start with a repeated message, evolution becomes trivial.\n// Describes a type of enhancement applied to a photo enum EnhancementType { ENHANCEMENT_TYPE_UNSPECIFIED; RED_EYE_REDUCTION; SKIN_SOFTENING; } message PhotoEnhancement { optional EnhancementType type; } message PhotoEnhancementReply { // Good: PhotoEnhancement can grow to describe enhancements that require // more fields than just an enum. repeated PhotoEnhancement enhancements; // Bad: If we ever want to return parameters associated with the // enhancement, we'd have to introduce a parallel array (terrible) or // deprecate this field and introduce a repeated message. repeated EnhancementType enhancement_types; } Imagine the following feature request: “We need to know which enhancements were performed by the user and which enhancements were automatically applied by the system.”\nIf the enhancement field in PhotoEnhancementReply were a scalar or enum, this would be much harder to support.\nThis applies equally to maps. It is much easier to add additional fields to a map value if it’s already a message rather than having to migrate from map\u003cstring, string\u003e to map\u003cstring, MyProto\u003e.\nOne exception:\nLatency-critical applications will find parallel arrays of primitive types are faster to construct and delete than a single array of messages; they can also be smaller over the wire if you use [packed=true] (eliding field tags). Allocating a fixed number of arrays is less work than allocating N messages. Bonus: in Proto3, packing is automatic; you don’t need to explicitly specify it.\nUse Proto Maps Prior to the introduction in Proto3 of Proto3 maps, services would sometimes expose data as pairs using an ad-hoc KVPair message with scalar fields. Eventually clients would need a deeper structure and would end up devising keys or values that need to be parsed in some way. See Don’t encode data in a string.\nSo, using a (extensible) message type for the value is an immediate improvement over the naive design.\nMaps were back-ported to proto2 in all languages, so using map\u003cscalar, **message**\u003e is better than inventing your own KVPair for the same purpose1.\nIf you want to represent arbitrary data whose structure you don’t know ahead of time, use google.protobuf.Any.\nPrefer Idempotency Somewhere in the stack above you, a client may have retry logic. If the retry is a mutation, the user could be in for a surprise. Duplicate comments, build requests, edits, and so on aren’t good for anyone.\nA simple way to avoid duplicate writes is to allow clients to specify a client-created request ID that your server dedupes on (for example, hash of content or UUID).\nBe Mindful of Your Service Name, and Make it Globally Unique A service name (that is, the part after the service keyword in your .proto file) is used in surprisingly many places, not just to generate the service class name. This makes this name more important than one might think.\nWhat’s tricky is that these tools make the implicit assumption that your service name is unique across a network . Worse, the service name they use is the unqualified service name (for example, MyService), not the qualified service name (for example, my_package.MyService).\nFor this reason, it makes sense to take steps to prevent naming conflicts on your service name, even if it is defined inside a specific package. For example, a service named Watcher is likely to cause problems; something like MyProjectWatcher would be better.\nEnsure Every RPC Specifies and Enforces a (Permissive) Deadline By default, an RPC does not have a timeout. Since a request may tie up backend resources that are only released on completion, setting a default deadline that allows all well-behaving requests to finish is a good defensive practice. Not enforcing one has in the past caused severe problems for major services . RPC clients should still set a deadline on outgoing RPCs and will typically do so by default when they use standard frameworks. A deadline may and typically will be overwritten by a shorter deadline attached to a request.\nSetting the deadline option clearly communicates the RPC deadline to your clients, and is respected and enforced by standard frameworks:\nrpc Foo(FooRequest) returns (FooResponse) { option deadline = x; // there is no globally good default } Choosing a deadline value will especially impact how your system acts under load. For existing services, it is critical to evaluate existing client behavior before enforcing new deadlines to avoid breaking clients (consult SRE). In some cases, it may not be possible to enforce a shorter deadline after the fact.\nBound Request and Response Sizes Request and response sizes should be bounded. We recommend a bound in the ballpark of 8 MiB, and 2 GiB is a hard limit at which many proto implementations break . Many storage systems have a limit on message sizes .\nAlso, unbounded messages\nbloat both client and server, cause high and unpredictable latency, decrease resiliency by relying on a long-lived connection between a single client and a single server. Here are a few ways to bound all messages in an API:\nDefine RPCs that return bounded messages, where each RPC call is logically independent from the others. Define RPCs that operate on a single object, instead of on an unbounded, client-specified list of objects. Avoid encoding unbounded data in string, byte, or repeated fields. Define a long-running operation . Store the result in a storage system designed for scalable, concurrent reads . Use a pagination API (see Rarely define a pagination API without a continuation token). Use streaming RPCs. If you are working on a UI, see also Create methods that return or manipulate small bits of data.\nPropagate Status Codes Carefully RPC services should take care at RPC boundaries to interrogate errors, and return meaningful status errors to their callers.\nLet’s examine a toy example to illustrate the point:\nConsider a client that calls ProductService.GetProducts, which takes no arguments. As part of GetProducts, ProductService might get all the products, and call LocaleService.LocaliseNutritionFacts for each product.\ndigraph toy_example { node [style=filled] client [label=\"Client\"]; product [label=\"ProductService\"]; locale [label=\"LocaleService\"]; client -\u003e product [label=\"GetProducts\"] product -\u003e locale [label=\"LocaliseNutritionFacts\"] } If ProductService is incorrectly implemented, it might send the wrong arguments to LocaleService, resulting in an INVALID_ARGUMENT.\nIf ProductService carelessly returns errors to its callers, the client will receive INVALID_ARGUMENT, since status codes propagate across RPC boundaries. But, the client didn’t pass any arguments to ProductService.GetProducts. So, the error is worse than useless: it will cause a great deal of confusion!\nInstead, ProductService should interrogate errors it receives at the RPC boundary; that is, the ProductService RPC handler it implements. It should return meaningful errors to users: if it received invalid arguments from the caller, it should return INVALID_ARGUMENT. If something downstream received invalid arguments, it should convert the INVALID_ARGUMENT to INTERNAL before returning the error to the caller.\nCarelessly propagating status errors leads to confusion, which can be very expensive to debug. Worse, it can lead to an invisible outage where every service forwards a client error without causing any alerts to happen .\nThe general rule is: at RPC boundaries, take care to interrogate errors, and return meaningful status errors to callers, with appropriate status codes. To convey meaning, each RPC method should document what error codes it returns in which circumstances. The implementation of each method should conform to the documented API contract.\nAppendix Returning Repeated Fields When a repeated field is empty, the client can’t tell if the field just wasn’t populated by the server or if the backing data for the field is genuinely empty. In other words, there’s no hasFoo method for repeated fields.\nWrapping a repeated field in a message is an easy way to get a hasFoo method.\nmessage FooList { repeated Foo foos; } The more holistic way to solve it is with a field read mask. If the field was requested, an empty list means there’s no data. If the field wasn’t requested the client should ignore the field in the response.\nUpdating Repeated Fields The worst way to update a repeated field is to force the client to supply a replacement list. The dangers with forcing the client to supply the entire array are manyfold. Clients that don’t preserve unknown fields cause data loss. Concurrent writes cause data loss. Even if those problems don’t apply, your clients will need to carefully read your documentation to know how the field is interpreted on the server side. Does an empty field mean the server won’t update it, or that the server will clear it?\nFix #1: Use a repeated update mask that permits the client to replace, delete, or insert elements into the array without supplying the entire array on a write.\nFix #2: Create separate append, replace, delete arrays in the request proto.\nFix #3: Allow only appending or clearing. You can do this by wrapping the repeated field in a message. A present, but empty, message means clear, otherwise, any repeated elements mean append.\nOrder Independence in Repeated Fields Try to avoid order dependence in general. It’s an extra layer of fragility. An especially bad type of order dependence is parallel arrays. Parallel arrays make it more difficult for clients to interpret the results and make it unnatural to pass the two related fields around inside your own service.\nmessage BatchEquationSolverResponse { // Bad: Solved values are returned in the order of the equations given in // the request. repeated double solved_values; // (Usually) Bad: Parallel array for solved_values. repeated double solved_complex_values; } // Good: A separate message that can grow to include more fields and be // shared among other methods. No order dependence between request and // response, no order dependence between multiple repeated fields. message BatchEquationSolverResponse { // Deprecated, this will continue to be populated in responses until Q2 // 2014, after which clients must move to using the solutions field below. repeated double solved_values [deprecated = true]; // Good: Each equation in the request has a unique identifier that's // included in the EquationSolution below so that the solutions can be // correlated with the equations themselves. Equations are solved in // parallel and as the solutions are made they are added to this array. repeated EquationSolution solutions; } Leaking Features Because Your Proto is in a Mobile Build Android and iOS runtimes both support reflection. To do that, the unfiltered names of fields and messages are embedded in the application binary (APK, IPA) as strings.\nmessage Foo { // This will leak existence of Google Teleport project on Android and iOS optional FeatureStatus google_teleport_enabled; } Several mitigation strategies:\nProGuard obfuscation on Android. As of Q3 2014. iOS has no obfuscation option: once you have the IPA on a desktop, piping it through strings will reveal field names of included protos. iOS Chrome tear-down Curate precisely which fields are sent to mobile clients . If plugging the leak isn’t feasible on an acceptable timescale, get buy-in from the feature owner to risk it. Never use this as an excuse to obfuscate the meaning of a field with a code-name. Either plug the leak or get buy-in to risk it.\nPerformance Optimizations You can trade type safety or clarity for performance wins in some cases. For example, a proto with hundreds of fields–particularly message-type fields–is going to be slower to parse than one with fewer fields. A very deeply-nested message can be slow to deserialize just from the memory management. A handful of techniques teams have used to speed deserialization:\nCreate a parallel, trimmed proto that mirrors the larger proto but has only some of the tags declared. Use this for parsing when you don’t need all the fields. Add tests to enforce that tag numbers continue to match as the trimmed proto accumulates numbering “holes.” Annotate the fields as “lazily parsed” with [lazy=true]. Declare a field as bytes and document its type. Clients who care to parse the field can do so manually. The danger with this approach is there’s nothing preventing someone from putting a message of the wrong type in the bytes field. You should never do this with a proto that’s written to any logs, as it prevents the proto from being vetted for PII or scrubbed for policy or privacy reasons. A gotcha with protos that contain map\u003ck,v\u003e fields. Don’t use them as reduce keys in a MapReduce. The wire format and iteration order of proto3 map items are unspecified which leads to inconsistent map shards. ↩︎\n","categories":"","description":"A future-proof API is surprisingly hard to get right. The suggestions in this document make trade-offs to favor long-term, bug-free evolution.","excerpt":"A future-proof API is surprisingly hard to get right. The suggestions …","ref":"/programming-guides/api/","tags":"","title":"API Best Practices"},{"body":"Each tutorial in this section shows you how to implement a simple application using protocol buffers in your favourite language, introducing you to the language’s protocol buffer API as well as showing you the basics of creating and using .proto files. The complete sample code for each application is also provided.\nThe tutorials don’t assume that you know anything about protocol buffers, but do assume that you are comfortable writing code in your chosen language, including using file I/O.\nC++ C# Dart Go Java Kotlin Python ","categories":"","description":"Each tutorial in this section shows you how to implement a simple application using protocol buffers in your favourite language, introducing you to the language's protocol buffer API as well as showing you the basics of creating and using .proto files.","excerpt":"Each tutorial in this section shows you how to implement a simple …","ref":"/getting-started/","tags":"","title":"Tutorials"},{"body":"This tutorial provides a basic C++ programmers introduction to working with protocol buffers. By walking through creating a simple example application, it shows you how to\nDefine message formats in a .proto file. Use the protocol buffer compiler. Use the C++ protocol buffer API to write and read messages. This isn’t a comprehensive guide to using protocol buffers in C++. For more detailed reference information, see the Protocol Buffer Language Guide (proto2), the Protocol Buffer Language Guide (proto3), the C++ API Reference, the C++ Generated Code Guide, and the Encoding Reference.\nThe Problem Domain The example we’re going to use is a very simple “address book” application that can read and write people’s contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.\nHow do you serialize and retrieve structured data like this? There are a few ways to solve this problem:\nThe raw in-memory data structures can be sent/saved in binary form. Over time, this is a fragile approach, as the receiving/reading code must be compiled with exactly the same memory layout, endianness, etc. Also, as files accumulate data in the raw format and copies of software that are wired for that format are spread around, it’s very hard to extend the format. You can invent an ad-hoc way to encode the data items into a single string – such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing imposes a small run-time cost. This works best for encoding very simple data. Serialize the data to XML. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you want to share data with other applications/projects. However, XML is notoriously space intensive, and encoding/decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be. Instead of these options, you can use protocol buffers. Protocol buffers are the flexible, efficient, automated solution to solve exactly this problem. With protocol buffers, you write a .proto description of the data structure you wish to store. From that, the protocol buffer compiler creates a class that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated class provides getters and setters for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code can still read data encoded with the old format.\nWhere to Find the Example Code The example code is included in the source code package, under the “examples” directory.\nDefining Your Protocol Format To create your address book application, you’ll need to start with a .proto file. The definitions in a .proto file are simple: you add a message for each data structure you want to serialize, then specify a name and a type for each field in the message. Here is the .proto file that defines your messages, addressbook.proto.\nsyntax = \"proto2\"; package tutorial; message Person { optional string name = 1; optional int32 id = 2; optional string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { optional string number = 1; optional PhoneType type = 2 [default = HOME]; } repeated PhoneNumber phones = 4; } message AddressBook { repeated Person people = 1; } As you can see, the syntax is similar to C++ or Java. Let’s go through each part of the file and see what it does.\nThe .proto file starts with a package declaration, which helps to prevent naming conflicts between different projects. In C++, your generated classes will be placed in a namespace matching the package name.\nNext, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including bool, int32, float, double, and string. You can also add further structure to your messages by using other message types as field types – in the above example the Person message contains PhoneNumber messages, while the AddressBook message contains Person messages. You can even define message types nested inside other messages – as you can see, the PhoneNumber type is defined inside Person. You can also define enum types if you want one of your fields to have one of a predefined list of values – here you want to specify that a phone number can be one of the following phone types: MOBILE, HOME, or WORK.\nThe \" = 1\", \" = 2\" markers on each element identify the unique field number that field uses in the binary encoding. Field numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those numbers for the commonly used or repeated elements, leaving field numbers 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the field number, so repeated fields are particularly good candidates for this optimization.\nEach field must be annotated with one of the following modifiers:\noptional: the field may or may not be set. If an optional field value isn’t set, a default value is used. For simple types, you can specify your own default value, as we’ve done for the phone number type in the example. Otherwise, a system default is used: zero for numeric types, the empty string for strings, false for bools. For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of an optional (or required) field which has not been explicitly set always returns that field’s default value. repeated: the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays. required: a value for the field must be provided, otherwise the message will be considered “uninitialized”. If libprotobuf is compiled in debug mode, serializing an uninitialized message will cause an assertion failure. In optimized builds, the check is skipped and the message will be written anyway. However, parsing an uninitialized message will always fail (by returning false from the parse method). Other than this, a required field behaves exactly like an optional field. Important Required Is Forever You should be very careful about marking fields as required. If at some point you wish to stop writing or sending a required field, it will be problematic to change the field to an optional field – old readers will consider messages without this field to be incomplete and may reject or drop them unintentionally. You should consider writing application-specific custom validation routines for your buffers instead. Within Google, required fields are strongly disfavored; most messages defined in proto2 syntax use optional and repeated only. (Proto3 does not support required fields at all.) You’ll find a complete guide to writing .proto files – including all the possible field types – in the Protocol Buffer Language Guide. Don’t go looking for facilities similar to class inheritance, though – protocol buffers don’t do that.\nCompiling Your Protocol Buffers Now that you have a .proto, the next thing you need to do is generate the classes you’ll need to read and write AddressBook (and hence Person and PhoneNumber) messages. To do this, you need to run the protocol buffer compiler protoc on your .proto:\nIf you haven’t installed the compiler, download the package and follow the instructions in the README.\nNow run the compiler, specifying the source directory (where your application’s source code lives – the current directory is used if you don’t provide a value), the destination directory (where you want the generated code to go; often the same as $SRC_DIR), and the path to your .proto. In this case, you…:\nprotoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/addressbook.proto Because you want C++ classes, you use the --cpp_out option – similar options are provided for other supported languages.\nThis generates the following files in your specified destination directory:\naddressbook.pb.h, the header which declares your generated classes. addressbook.pb.cc, which contains the implementation of your classes. The Protocol Buffer API Let’s look at some of the generated code and see what classes and functions the compiler has created for you. If you look in addressbook.pb.h, you can see that you have a class for each message you specified in addressbook.proto. Looking closer at the Person class, you can see that the compiler has generated accessors for each field. For example, for the name, id, email, and phones fields, you have these methods:\n// name inline bool has_name() const; inline void clear_name(); inline const ::std::string\u0026 name() const; inline void set_name(const ::std::string\u0026 value); inline void set_name(const char* value); inline ::std::string* mutable_name(); // id inline bool has_id() const; inline void clear_id(); inline int32_t id() const; inline void set_id(int32_t value); // email inline bool has_email() const; inline void clear_email(); inline const ::std::string\u0026 email() const; inline void set_email(const ::std::string\u0026 value); inline void set_email(const char* value); inline ::std::string* mutable_email(); // phones inline int phones_size() const; inline void clear_phones(); inline const ::google::protobuf::RepeatedPtrField\u003c ::tutorial::Person_PhoneNumber \u003e\u0026 phones() const; inline ::google::protobuf::RepeatedPtrField\u003c ::tutorial::Person_PhoneNumber \u003e* mutable_phones(); inline const ::tutorial::Person_PhoneNumber\u0026 phones(int index) const; inline ::tutorial::Person_PhoneNumber* mutable_phones(int index); inline ::tutorial::Person_PhoneNumber* add_phones(); As you can see, the getters have exactly the name as the field in lowercase, and the setter methods begin with set_. There are also has_ methods for each singular (required or optional) field which return true if that field has been set. Finally, each field has a clear_ method that un-sets the field back to its empty state.\nWhile the numeric id field just has the basic accessor set described above, the name and email fields have a couple of extra methods because they’re strings – a mutable_ getter that lets you get a direct pointer to the string, and an extra setter. Note that you can call mutable_email() even if email is not already set; it will be initialized to an empty string automatically. If you had a repeated message field in this example, it would also have a mutable_ method but not a set_ method.\nRepeated fields also have some special methods – if you look at the methods for the repeated phones field, you’ll see that you can\ncheck the repeated field’s _size (in other words, how many phone numbers are associated with this Person). get a specified phone number using its index. update an existing phone number at the specified index. add another phone number to the message which you can then edit (repeated scalar types have an add_ that just lets you pass in the new value). For more information on exactly what members the protocol compiler generates for any particular field definition, see the C++ generated code reference.\nEnums and Nested Classes The generated code includes a PhoneType enum that corresponds to your .proto enum. You can refer to this type as Person::PhoneType and its values as Person::MOBILE, Person::HOME, and Person::WORK (the implementation details are a little more complicated, but you don’t need to understand them to use the enum).\nThe compiler has also generated a nested class for you called Person::PhoneNumber. If you look at the code, you can see that the “real” class is actually called Person_PhoneNumber, but a typedef defined inside Person allows you to treat it as if it were a nested class. The only case where this makes a difference is if you want to forward-declare the class in another file – you cannot forward-declare nested types in C++, but you can forward-declare Person_PhoneNumber.\nStandard Message Methods Each message class also contains a number of other methods that let you check or manipulate the entire message, including:\nbool IsInitialized() const;: checks if all the required fields have been set. string DebugString() const;: returns a human-readable representation of the message, particularly useful for debugging. void CopyFrom(const Person\u0026 from);: overwrites the message with the given message’s values. void Clear();: clears all the elements back to the empty state. These and the I/O methods described in the following section implement the Message interface shared by all C++ protocol buffer classes. For more info, see the complete API documentation for Message.\nParsing and Serialization Finally, each protocol buffer class has methods for writing and reading messages of your chosen type using the protocol buffer binary format. These include:\nbool SerializeToString(string* output) const;: serializes the message and stores the bytes in the given string. Note that the bytes are binary, not text; we only use the string class as a convenient container. bool ParseFromString(const string\u0026 data);: parses a message from the given string. bool SerializeToOstream(ostream* output) const;: writes the message to the given C++ ostream. bool ParseFromIstream(istream* input);: parses a message from the given C++ istream. These are just a couple of the options provided for parsing and serialization. Again, see the Message API reference for a complete list.\nImportant Protocol Buffers and Object Oriented Design Protocol buffer classes are basically data holders (like structs in C) that don’t provide additional functionality; they don’t make good first class citizens in an object model. If you want to add richer behavior to a generated class, the best way to do this is to wrap the generated protocol buffer class in an application-specific class. Wrapping protocol buffers is also a good idea if you don’t have control over the design of the .proto file (if, say, you’re reusing one from another project). In that case, you can use the wrapper class to craft an interface better suited to the unique environment of your application: hiding some data and methods, exposing convenience functions, etc. You should never add behavior to the generated classes by inheriting from them. This will break internal mechanisms and is not good object-oriented practice anyway. Writing a Message Now let’s try using your protocol buffer classes. The first thing you want your address book application to be able to do is write personal details to your address book file. To do this, you need to create and populate instances of your protocol buffer classes and then write them to an output stream.\nHere is a program which reads an AddressBook from a file, adds one new Person to it based on user input, and writes the new AddressBook back out to the file again. The parts which directly call or reference code generated by the protocol compiler are highlighted.\n#include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003cstring\u003e #include \"addressbook.pb.h\" using namespace std; // This function fills in a Person message based on user input. void PromptForAddress(tutorial::Person* person) { cout \u003c\u003c \"Enter person ID number: \"; int id; cin \u003e\u003e id; person-\u003eset_id(id); cin.ignore(256, '\\n'); cout \u003c\u003c \"Enter name: \"; getline(cin, *person-\u003emutable_name()); cout \u003c\u003c \"Enter email address (blank for none): \"; string email; getline(cin, email); if (!email.empty()) { person-\u003eset_email(email); } while (true) { cout \u003c\u003c \"Enter a phone number (or leave blank to finish): \"; string number; getline(cin, number); if (number.empty()) { break; } tutorial::Person::PhoneNumber* phone_number = person-\u003eadd_phones(); phone_number-\u003eset_number(number); cout \u003c\u003c \"Is this a mobile, home, or work phone? \"; string type; getline(cin, type); if (type == \"mobile\") { phone_number-\u003eset_type(tutorial::Person::MOBILE); } else if (type == \"home\") { phone_number-\u003eset_type(tutorial::Person::HOME); } else if (type == \"work\") { phone_number-\u003eset_type(tutorial::Person::WORK); } else { cout \u003c\u003c \"Unknown phone type. Using default.\" \u003c\u003c endl; } } } // Main function: Reads the entire address book from a file, // adds one person based on user input, then writes it back out to the same // file. int main(int argc, char* argv[]) { // Verify that the version of the library that we linked against is // compatible with the version of the headers we compiled against. GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) { cerr \u003c\u003c \"Usage: \" \u003c\u003c argv[0] \u003c\u003c \" ADDRESS_BOOK_FILE\" \u003c\u003c endl; return -1; } tutorial::AddressBook address_book; { // Read the existing address book. fstream input(argv[1], ios::in | ios::binary); if (!input) { cout \u003c\u003c argv[1] \u003c\u003c \": File not found. Creating a new file.\" \u003c\u003c endl; } else if (!address_book.ParseFromIstream(\u0026input)) { cerr \u003c\u003c \"Failed to parse address book.\" \u003c\u003c endl; return -1; } } // Add an address. PromptForAddress(address_book.add_people()); { // Write the new address book back to disk. fstream output(argv[1], ios::out | ios::trunc | ios::binary); if (!address_book.SerializeToOstream(\u0026output)) { cerr \u003c\u003c \"Failed to write address book.\" \u003c\u003c endl; return -1; } } // Optional: Delete all global objects allocated by libprotobuf. google::protobuf::ShutdownProtobufLibrary(); return 0; } Notice the GOOGLE_PROTOBUF_VERIFY_VERSION macro. It is good practice – though not strictly necessary – to execute this macro before using the C++ Protocol Buffer library. It verifies that you have not accidentally linked against a version of the library which is incompatible with the version of the headers you compiled with. If a version mismatch is detected, the program will abort. Note that every .pb.cc file automatically invokes this macro on startup.\nAlso notice the call to ShutdownProtobufLibrary() at the end of the program. All this does is delete any global objects that were allocated by the Protocol Buffer library. This is unnecessary for most programs, since the process is just going to exit anyway and the OS will take care of reclaiming all of its memory. However, if you use a memory leak checker that requires that every last object be freed, or if you are writing a library which may be loaded and unloaded multiple times by a single process, then you may want to force Protocol Buffers to clean up everything.\nReading a Message Of course, an address book wouldn’t be much use if you couldn’t get any information out of it! This example reads the file created by the above example and prints all the information in it.\n#include \u003ciostream\u003e #include \u003cfstream\u003e #include \u003cstring\u003e #include \"addressbook.pb.h\" using namespace std; // Iterates though all people in the AddressBook and prints info about them. void ListPeople(const tutorial::AddressBook\u0026 address_book) { for (int i = 0; i \u003c address_book.people_size(); i++) { const tutorial::Person\u0026 person = address_book.people(i); cout \u003c\u003c \"Person ID: \" \u003c\u003c person.id() \u003c\u003c endl; cout \u003c\u003c \" Name: \" \u003c\u003c person.name() \u003c\u003c endl; if (person.has_email()) { cout \u003c\u003c \" E-mail address: \" \u003c\u003c person.email() \u003c\u003c endl; } for (int j = 0; j \u003c person.phones_size(); j++) { const tutorial::Person::PhoneNumber\u0026 phone_number = person.phones(j); switch (phone_number.type()) { case tutorial::Person::MOBILE: cout \u003c\u003c \" Mobile phone #: \"; break; case tutorial::Person::HOME: cout \u003c\u003c \" Home phone #: \"; break; case tutorial::Person::WORK: cout \u003c\u003c \" Work phone #: \"; break; } cout \u003c\u003c phone_number.number() \u003c\u003c endl; } } } // Main function: Reads the entire address book from a file and prints all // the information inside. int main(int argc, char* argv[]) { // Verify that the version of the library that we linked against is // compatible with the version of the headers we compiled against. GOOGLE_PROTOBUF_VERIFY_VERSION; if (argc != 2) { cerr \u003c\u003c \"Usage: \" \u003c\u003c argv[0] \u003c\u003c \" ADDRESS_BOOK_FILE\" \u003c\u003c endl; return -1; } tutorial::AddressBook address_book; { // Read the existing address book. fstream input(argv[1], ios::in | ios::binary); if (!address_book.ParseFromIstream(\u0026input)) { cerr \u003c\u003c \"Failed to parse address book.\" \u003c\u003c endl; return -1; } } ListPeople(address_book); // Optional: Delete all global objects allocated by libprotobuf. google::protobuf::ShutdownProtobufLibrary(); return 0; } Extending a Protocol Buffer Sooner or later after you release the code that uses your protocol buffer, you will undoubtedly want to “improve” the protocol buffer’s definition. If you want your new buffers to be backwards-compatible, and your old buffers to be forward-compatible – and you almost certainly do want this – then there are some rules you need to follow. In the new version of the protocol buffer:\nyou must not change the field numbers of any existing fields. you must not add or delete any required fields. you may delete optional or repeated fields. you may add new optional or repeated fields but you must use fresh field numbers (that is, field numbers that were never used in this protocol buffer, not even by deleted fields). (There are some exceptions to these rules, but they are rarely used.)\nIf you follow these rules, old code will happily read new messages and simply ignore any new fields. To the old code, optional fields that were deleted will simply have their default value, and deleted repeated fields will be empty. New code will also transparently read old messages. However, keep in mind that new optional fields will not be present in old messages, so you will need to either check explicitly whether they’re set with has_, or provide a reasonable default value in your .proto file with [default = value] after the field number. If the default value is not specified for an optional element, a type-specific default value is used instead: for strings, the default value is the empty string. For booleans, the default value is false. For numeric types, the default value is zero. Note also that if you added a new repeated field, your new code will not be able to tell whether it was left empty (by new code) or never set at all (by old code) since there is no has_ flag for it.\nOptimization Tips The C++ Protocol Buffers library is extremely heavily optimized. However, proper usage can improve performance even more. Here are some tips for squeezing every last drop of speed out of the library:\nReuse message objects when possible. Messages try to keep around any memory they allocate for reuse, even when they are cleared. Thus, if you are handling many messages with the same type and similar structure in succession, it is a good idea to reuse the same message object each time to take load off the memory allocator. However, objects can become bloated over time, especially if your messages vary in “shape” or if you occasionally construct a message that is much larger than usual. You should monitor the sizes of your message objects by calling the SpaceUsed method and delete them once they get too big. Your system’s memory allocator may not be well-optimized for allocating lots of small objects from multiple threads. Try using Google’s TCMalloc instead. Advanced Usage Protocol buffers have uses that go beyond simple accessors and serialization. Be sure to explore the C++ API reference to see what else you can do with them.\nOne key feature provided by protocol message classes is reflection. You can iterate over the fields of a message and manipulate their values without writing your code against any specific message type. One very useful way to use reflection is for converting protocol messages to and from other encodings, such as XML or JSON. A more advanced use of reflection might be to find differences between two messages of the same type, or to develop a sort of “regular expressions for protocol messages” in which you can write expressions that match certain message contents. If you use your imagination, it’s possible to apply Protocol Buffers to a much wider range of problems than you might initially expect!\nReflection is provided by the Message::Reflection interface.\n","categories":"","description":"This tutorial provides a basic C++ programmers introduction to working with protocol buffers.","excerpt":"This tutorial provides a basic C++ programmers introduction to working …","ref":"/getting-started/cpptutorial/","tags":"","title":"Protocol Buffer Basics: C++"},{"body":"This tutorial provides a basic C# programmer’s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to\nDefine message formats in a .proto file. Use the protocol buffer compiler. Use the C# protocol buffer API to write and read messages. This isn’t a comprehensive guide to using protocol buffers in C#. For more detailed reference information, see the Protocol Buffer Language Guide, the C# API Reference, the C# Generated Code Guide, and the Encoding Reference.\nThe Problem Domain The example we’re going to use is a very simple “address book” application that can read and write people’s contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.\nHow do you serialize and retrieve structured data like this? There are a few ways to solve this problem:\nUse .NET binary serialization with System.Runtime.Serialization.Formatters.Binary.BinaryFormatter and associated classes. This ends up being very fragile in the face of changes, expensive in terms of data size in some cases. It also doesn’t work very well if you need to share data with applications written for other platforms. You can invent an ad-hoc way to encode the data items into a single string – such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing imposes a small run-time cost. This works best for encoding very simple data. Serialize the data to XML. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you want to share data with other applications/projects. However, XML is notoriously space intensive, and encoding/decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be. Protocol buffers are the flexible, efficient, automated solution to solve exactly this problem. With protocol buffers, you write a .proto description of the data structure you wish to store. From that, the protocol buffer compiler creates a class that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated class provides getters and setters for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code can still read data encoded with the old format.\nWhere to Find the Example Code Our example is a command-line application for managing an address book data file, encoded using protocol buffers. The command AddressBook (see: Program.cs) can add a new entry to the data file or parse the data file and print the data to the console.\nYou can find the complete example in the examples directory and csharp/src/AddressBook directory of the GitHub repository.\nDefining Your Protocol Format To create your address book application, you’ll need to start with a .proto file. The definitions in a .proto file are simple: you add a message for each data structure you want to serialize, then specify a name and a type for each field in the message. In our example, the .proto file that defines the messages is addressbook.proto.\nThe .proto file starts with a package declaration, which helps to prevent naming conflicts between different projects.\nsyntax = \"proto3\"; package tutorial; import \"google/protobuf/timestamp.proto\"; In C#, your generated classes will be placed in a namespace matching the package name if csharp_namespace is not specified. In our example, the csharp_namespace option has been specified to override the default, so the generated code uses a namespace of Google.Protobuf.Examples.AddressBook instead of Tutorial.\noption csharp_namespace = \"Google.Protobuf.Examples.AddressBook\"; Next, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including bool, int32, float, double, and string. You can also add further structure to your messages by using other message types as field types.\nmessage Person { string name = 1; int32 id = 2; // Unique ID number for this person. string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { string number = 1; PhoneType type = 2; } repeated PhoneNumber phones = 4; google.protobuf.Timestamp last_updated = 5; } // Our address book file is just one of these. message AddressBook { repeated Person people = 1; } In the above example, the Person message contains PhoneNumber messages, while the AddressBook message contains Person messages. You can even define message types nested inside other messages – as you can see, the PhoneNumber type is defined inside Person. You can also define enum types if you want one of your fields to have one of a predefined list of values – here you want to specify that a phone number can be one of MOBILE, HOME, or WORK.\nThe \" = 1\", \" = 2\" markers on each element identify the unique “tag” that field uses in the binary encoding. Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the tag number, so repeated fields are particularly good candidates for this optimization.\nIf a field value isn’t set, a default value is used: zero for numeric types, the empty string for strings, false for bools. For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of a field which has not been explicitly set always returns that field’s default value.\nIf a field is repeated, the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays.\nYou’ll find a complete guide to writing .proto files – including all the possible field types – in the Protocol Buffer Language Guide. Don’t go looking for facilities similar to class inheritance, though – protocol buffers don’t do that.\nCompiling Your Protocol Buffers Now that you have a .proto, the next thing you need to do is generate the classes you’ll need to read and write AddressBook (and hence Person and PhoneNumber) messages. To do this, you need to run the protocol buffer compiler protoc on your .proto:\nIf you haven’t installed the compiler, download the package and follow the instructions in the README.\nNow run the compiler, specifying the source directory (where your application’s source code lives – the current directory is used if you don’t provide a value), the destination directory (where you want the generated code to go; often the same as $SRC_DIR), and the path to your .proto. In this case, you would invoke:\nprotoc -I=$SRC_DIR --csharp_out=$DST_DIR $SRC_DIR/addressbook.proto Because you want C# code, you use the --csharp_out option – similar options are provided for other supported languages.\nThis generates Addressbook.cs in your specified destination directory. To compile this code, you’ll need a project with a reference to the Google.Protobuf assembly.\nThe Addressbook Classes Generating Addressbook.cs gives you five useful types:\nA static Addressbook class that contains metadata about the protocol buffer messages. An AddressBook class with a read-only People property. A Person class with properties for Name, Id, Email and Phones. A PhoneNumber class, nested in a static Person.Types class. A PhoneType enum, also nested in Person.Types. You can read more about the details of exactly what’s generated in the C# Generated Code guide, but for the most part you can treat these as perfectly ordinary C# types. One point to highlight is that any properties corresponding to repeated fields are read-only. You can add items to the collection or remove items from it, but you can’t replace it with an entirely separate collection. The collection type for repeated fields is always RepeatedField\u003cT\u003e. This type is like List\u003cT\u003e but with a few extra convenience methods, such as an Add overload accepting a collection of items, for use in collection initializers.\nHere’s an example of how you might create an instance of Person:\nPerson john = new Person { Id = 1234, Name = \"John Doe\", Email = \"jdoe@example.com\", Phones = { new Person.Types.PhoneNumber { Number = \"555-4321\", Type = Person.Types.PhoneType.Home } } }; Note that with C# 6, you can use using static to remove the Person.Types ugliness:\n// Add this to the other using directives using static Google.Protobuf.Examples.AddressBook.Person.Types; ... // The earlier Phones assignment can now be simplified to: Phones = { new PhoneNumber { Number = \"555-4321\", Type = PhoneType.HOME } } Parsing and Serialization The whole purpose of using protocol buffers is to serialize your data so that it can be parsed elsewhere. Every generated class has a WriteTo(CodedOutputStream) method, where CodedOutputStream is a class in the protocol buffer runtime library. However, usually you’ll use one of the extension methods to write to a regular System.IO.Stream or convert the message to a byte array or ByteString. These extension messages are in the Google.Protobuf.MessageExtensions class, so when you want to serialize you’ll usually want a using directive for the Google.Protobuf namespace. For example:\nusing Google.Protobuf; ... Person john = ...; // Code as before using (var output = File.Create(\"john.dat\")) { john.WriteTo(output); } Parsing is also simple. Each generated class has a static Parser property which returns a MessageParser\u003cT\u003e for that type. That in turn has methods to parse streams, byte arrays and ByteStrings. So to parse the file we’ve just created, we can use:\nPerson john; using (var input = File.OpenRead(\"john.dat\")) { john = Person.Parser.ParseFrom(input); } A full example program to maintain an addressbook (adding new entries and listing existing ones) using these messages is available in the Github repository.\nExtending a Protocol Buffer Sooner or later after you release the code that uses your protocol buffer, you will undoubtedly want to “improve” the protocol buffer’s definition. If you want your new buffers to be backwards-compatible, and your old buffers to be forward-compatible – and you almost certainly do want this – then there are some rules you need to follow. In the new version of the protocol buffer:\nyou must not change the tag numbers of any existing fields. you may delete fields. you may add new fields but you must use fresh tag numbers (i.e. tag numbers that were never used in this protocol buffer, not even by deleted fields). (There are some exceptions to these rules, but they are rarely used.)\nIf you follow these rules, old code will happily read new messages and simply ignore any new fields. To the old code, singular fields that were deleted will simply have their default value, and deleted repeated fields will be empty. New code will also transparently read old messages.\nHowever, keep in mind that new fields will not be present in old messages, so you will need to do something reasonable with the default value. A type-specific default value is used: for strings, the default value is the empty string. For booleans, the default value is false. For numeric types, the default value is zero.\nReflection Message descriptors (the information in the .proto file) and instances of messages can be examined programmatically using the reflection API. This can be useful when writing generic code such as a different text format or a smart diff tool. Each generated class has a static Descriptor property, and the descriptor for any instance can be retrieved using the IMessage.Descriptor property. As a quick example of how these can be used, here is a short method to print the top-level fields of any message.\npublic void PrintMessage(IMessage message) { var descriptor = message.Descriptor; foreach (var field in descriptor.Fields.InDeclarationOrder()) { Console.WriteLine( \"Field {0} ({1}): {2}\", field.FieldNumber, field.Name, field.Accessor.GetValue(message); } } ","categories":"","description":"This tutorial provides a basic C# programmers introduction to working with protocol buffers.","excerpt":"This tutorial provides a basic C# programmers introduction to working …","ref":"/getting-started/csharptutorial/","tags":"","title":"Protocol Buffer Basics: C#"},{"body":"This tutorial provides a basic Dart programmer’s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to\nDefine message formats in a .proto file. Use the protocol buffer compiler. Use the Dart protocol buffer API to write and read messages. This isn’t a comprehensive guide to using protocol buffers in Dart . For more detailed reference information, see the Protocol Buffer Language Guide, the Dart Language Tour, the Dart API Reference, the Dart Generated Code Guide, and the Encoding Reference.\nThe Problem Domain The example we’re going to use is a very simple “address book” application that can read and write people’s contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.\nHow do you serialize and retrieve structured data like this? There are a few ways to solve this problem:\nYou can invent an ad-hoc way to encode the data items into a single string – such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing imposes a small run-time cost. This works best for encoding very simple data. Serialize the data to XML. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you want to share data with other applications/projects. However, XML is notoriously space intensive, and encoding/decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be. Protocol buffers are the flexible, efficient, automated solution to solve exactly this problem. With protocol buffers, you write a .proto description of the data structure you wish to store. From that, the protocol buffer compiler creates a class that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated class provides getters and setters for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code can still read data encoded with the old format.\nWhere to Find the Example Code Our example is a set of command-line applications for managing an address book data file, encoded using protocol buffers. The command dart add_person.dart adds a new entry to the data file. The command dart list_people.dart parses the data file and prints the data to the console.\nYou can find the complete example in the examples directory of the GitHub repository.\nDefining Your Protocol Format To create your address book application, you’ll need to start with a .proto file. The definitions in a .proto file are simple: you add a message for each data structure you want to serialize, then specify a name and a type for each field in the message. In our example, the .proto file that defines the messages is addressbook.proto.\nThe .proto file starts with a package declaration, which helps to prevent naming conflicts between different projects.\nsyntax = \"proto3\"; package tutorial; import \"google/protobuf/timestamp.proto\"; Next, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including bool, int32, float, double, and string. You can also add further structure to your messages by using other message types as field types.\nmessage Person { string name = 1; int32 id = 2; // Unique ID number for this person. string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { string number = 1; PhoneType type = 2; } repeated PhoneNumber phones = 4; google.protobuf.Timestamp last_updated = 5; } // Our address book file is just one of these. message AddressBook { repeated Person people = 1; } In the above example, the Person message contains PhoneNumber messages, while the AddressBook message contains Person messages. You can even define message types nested inside other messages – as you can see, the PhoneNumber type is defined inside Person. You can also define enum types if you want one of your fields to have one of a predefined list of values – here you want to specify that a phone number can be one of MOBILE, HOME, or WORK.\nThe \" = 1\", \" = 2\" markers on each element identify the unique “tag” that field uses in the binary encoding. Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the tag number, so repeated fields are particularly good candidates for this optimization.\nIf a field value isn’t set, a default value is used: zero for numeric types, the empty string for strings, false for bools. For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of a field which has not been explicitly set always returns that field’s default value.\nIf a field is repeated, the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays.\nYou’ll find a complete guide to writing .proto files – including all the possible field types – in the Protocol Buffer Language Guide. Don’t go looking for facilities similar to class inheritance, though – protocol buffers don’t do that.\nCompiling Your Protocol Buffers Now that you have a .proto, the next thing you need to do is generate the classes you’ll need to read and write AddressBook (and hence Person and PhoneNumber) messages. To do this, you need to run the protocol buffer compiler protoc on your .proto:\nIf you haven’t installed the compiler, download the package and follow the instructions in the README.\nInstall the Dart Protocol Buffer plugin as described in its README. The executable bin/protoc-gen-dart must be in your PATH for the protocol buffer protoc to find it.\nNow run the compiler, specifying the source directory (where your application’s source code lives – the current directory is used if you don’t provide a value), the destination directory (where you want the generated code to go; often the same as $SRC_DIR), and the path to your .proto. In this case, you would invoke:\nprotoc -I=$SRC_DIR --dart_out=$DST_DIR $SRC_DIR/addressbook.proto Because you want Dart code, you use the --dart_out option – similar options are provided for other supported languages.\nThis generates addressbook.pb.dart in your specified destination directory.\nThe Protocol Buffer API Generating addressbook.pb.dart gives you the following useful types:\nAn AddressBook class with a List\u003cPerson\u003e get people getter. A Person class with accessor methods for name, id, email and phones. A Person_PhoneNumber class, with accessor methods for number and type. A Person_PhoneType class with static fields for each value in the Person.PhoneType enum. You can read more about the details of exactly what’s generated in the Dart Generated Code guide.\nWriting a Message Now let’s try using your protocol buffer classes. The first thing you want your address book application to be able to do is write personal details to your address book file. To do this, you need to create and populate instances of your protocol buffer classes and then write them to an output stream.\nHere is a program which reads an AddressBook from a file, adds one new Person to it based on user input, and writes the new AddressBook back out to the file again. The parts which directly call or reference code generated by the protocol compiler are highlighted.\nimport 'dart:io'; import 'dart_tutorial/addressbook.pb.dart'; // This function fills in a Person message based on user input. Person promptForAddress() { Person person = Person(); print('Enter person ID: '); String input = stdin.readLineSync(); person.id = int.parse(input); print('Enter name'); person.name = stdin.readLineSync(); print('Enter email address (blank for none) : '); String email = stdin.readLineSync(); if (email.isNotEmpty) { person.email = email; } while (true) { print('Enter a phone number (or leave blank to finish): '); String number = stdin.readLineSync(); if (number.isEmpty) break; Person_PhoneNumber phoneNumber = Person_PhoneNumber(); phoneNumber.number = number; print('Is this a mobile, home, or work phone? '); String type = stdin.readLineSync(); switch (type) { case 'mobile': phoneNumber.type = Person_PhoneType.MOBILE; break; case 'home': phoneNumber.type = Person_PhoneType.HOME; break; case 'work': phoneNumber.type = Person_PhoneType.WORK; break; default: print('Unknown phone type. Using default.'); } person.phones.add(phoneNumber); } return person; } // Reads the entire address book from a file, adds one person based // on user input, then writes it back out to the same file. main(List arguments) { if (arguments.length != 1) { print('Usage: add_person ADDRESS_BOOK_FILE'); exit(-1); } File file = File(arguments.first); AddressBook addressBook; if (!file.existsSync()) { print('File not found. Creating new file.'); addressBook = AddressBook(); } else { addressBook = AddressBook.fromBuffer(file.readAsBytesSync()); } addressBook.people.add(promptForAddress()); file.writeAsBytes(addressBook.writeToBuffer()); } Reading a Message Of course, an address book wouldn’t be much use if you couldn’t get any information out of it! This example reads the file created by the above example and prints all the information in it.\nimport 'dart:io'; import 'dart_tutorial/addressbook.pb.dart'; import 'dart_tutorial/addressbook.pbenum.dart'; // Iterates though all people in the AddressBook and prints info about them. void printAddressBook(AddressBook addressBook) { for (Person person in addressBook.people) { print('Person ID: ${ person.id}'); print(' Name: ${ person.name}'); if (person.hasEmail()) { print(' E-mail address:${ person.email}'); } for (Person_PhoneNumber phoneNumber in person.phones) { switch (phoneNumber.type) { case Person_PhoneType.MOBILE: print(' Mobile phone #: '); break; case Person_PhoneType.HOME: print(' Home phone #: '); break; case Person_PhoneType.WORK: print(' Work phone #: '); break; default: print(' Unknown phone #: '); break; } print(phoneNumber.number); } } } // Reads the entire address book from a file and prints all // the information inside. main(List arguments) { if (arguments.length != 1) { print('Usage: list_person ADDRESS_BOOK_FILE'); exit(-1); } // Read the existing address book. File file = new File(arguments.first); AddressBook addressBook = new AddressBook.fromBuffer(file.readAsBytesSync()); printAddressBook(addressBook); } Extending a Protocol Buffer Sooner or later after you release the code that uses your protocol buffer, you will undoubtedly want to “improve” the protocol buffer’s definition. If you want your new buffers to be backwards-compatible, and your old buffers to be forward-compatible – and you almost certainly do want this – then there are some rules you need to follow. In the new version of the protocol buffer:\nyou must not change the tag numbers of any existing fields. you may delete fields. you may add new fields but you must use fresh tag numbers (i.e. tag numbers that were never used in this protocol buffer, not even by deleted fields). (There are some exceptions to these rules, but they are rarely used.)\nIf you follow these rules, old code will happily read new messages and simply ignore any new fields. To the old code, singular fields that were deleted will simply have their default value, and deleted repeated fields will be empty. New code will also transparently read old messages.\nHowever, keep in mind that new fields will not be present in old messages, so you will need to do something reasonable with the default value. A type-specific default value is used: for strings, the default value is the empty string. For booleans, the default value is false. For numeric types, the default value is zero.\n","categories":"","description":"This tutorial provides a basic Dart programmers introduction to working with protocol buffers.","excerpt":"This tutorial provides a basic Dart programmers introduction to …","ref":"/getting-started/darttutorial/","tags":"","title":"Protocol Buffer Basics: Dart"},{"body":"This tutorial provides a basic Go programmer’s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to\nDefine message formats in a .proto file. Use the protocol buffer compiler. Use the Go protocol buffer API to write and read messages. This isn’t a comprehensive guide to using protocol buffers in Go. For more detailed reference information, see the Protocol Buffer Language Guide, the Go API Reference, the Go Generated Code Guide, and the Encoding Reference.\nThe Problem Domain The example we’re going to use is a very simple “address book” application that can read and write people’s contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.\nHow do you serialize and retrieve structured data like this? There are a few ways to solve this problem:\nUse gobs to serialize Go data structures. This is a good solution in a Go-specific environment, but it doesn’t work well if you need to share data with applications written for other platforms. You can invent an ad-hoc way to encode the data items into a single string – such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing imposes a small run-time cost. This works best for encoding very simple data. Serialize the data to XML. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you want to share data with other applications/projects. However, XML is notoriously space intensive, and encoding/decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be. Protocol buffers are the flexible, efficient, automated solution to solve exactly this problem. With protocol buffers, you write a .proto description of the data structure you wish to store. From that, the protocol buffer compiler creates a class that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated class provides getters and setters for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code can still read data encoded with the old format.\nWhere to Find the Example Code Our example is a set of command-line applications for managing an address book data file, encoded using protocol buffers. The command add_person_go adds a new entry to the data file. The command list_people_go parses the data file and prints the data to the console.\nYou can find the complete example in the examples directory of the GitHub repository.\nDefining Your Protocol Format To create your address book application, you’ll need to start with a .proto file. The definitions in a .proto file are simple: you add a message for each data structure you want to serialize, then specify a name and a type for each field in the message. In our example, the .proto file that defines the messages is addressbook.proto.\nThe .proto file starts with a package declaration, which helps to prevent naming conflicts between different projects.\nsyntax = \"proto3\"; package tutorial; import \"google/protobuf/timestamp.proto\"; The go_package option defines the import path of the package which will contain all the generated code for this file. The Go package name will be the last path component of the import path. For example, our example will use a package name of “tutorialpb”.\noption go_package = \"github.com/protocolbuffers/protobuf/examples/go/tutorialpb\"; Next, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including bool, int32, float, double, and string. You can also add further structure to your messages by using other message types as field types.\nmessage Person { string name = 1; int32 id = 2; // Unique ID number for this person. string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { string number = 1; PhoneType type = 2; } repeated PhoneNumber phones = 4; google.protobuf.Timestamp last_updated = 5; } // Our address book file is just one of these. message AddressBook { repeated Person people = 1; } In the above example, the Person message contains PhoneNumber messages, while the AddressBook message contains Person messages. You can even define message types nested inside other messages – as you can see, the PhoneNumber type is defined inside Person. You can also define enum types if you want one of your fields to have one of a predefined list of values – here you want to specify that a phone number can be one of MOBILE, HOME, or WORK.\nThe \" = 1\", \" = 2\" markers on each element identify the unique “tag” that field uses in the binary encoding. Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the tag number, so repeated fields are particularly good candidates for this optimization.\nIf a field value isn’t set, a default value is used: zero for numeric types, the empty string for strings, false for bools. For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of a field which has not been explicitly set always returns that field’s default value.\nIf a field is repeated, the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays.\nYou’ll find a complete guide to writing .proto files – including all the possible field types – in the Protocol Buffer Language Guide. Don’t go looking for facilities similar to class inheritance, though – protocol buffers don’t do that.\nCompiling Your Protocol Buffers Now that you have a .proto, the next thing you need to do is generate the classes you’ll need to read and write AddressBook (and hence Person and PhoneNumber) messages. To do this, you need to run the protocol buffer compiler protoc on your .proto:\nIf you haven’t installed the compiler, download the package and follow the instructions in the README.\nRun the following command to install the Go protocol buffers plugin:\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest The compiler plugin protoc-gen-go will be installed in $GOBIN, defaulting to $GOPATH/bin. It must be in your $PATH for the protocol compiler protoc to find it.\nNow run the compiler, specifying the source directory (where your application’s source code lives – the current directory is used if you don’t provide a value), the destination directory (where you want the generated code to go; often the same as $SRC_DIR), and the path to your .proto. In this case, you would invoke:\nprotoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto Because you want Go code, you use the --go_out option – similar options are provided for other supported languages.\nThis generates github.com/protocolbuffers/protobuf/examples/go/tutorialpb/addressbook.pb.go in your specified destination directory.\nThe Protocol Buffer API Generating addressbook.pb.go gives you the following useful types:\nAn AddressBook structure with a People field. A Person structure with fields for Name, Id, Email and Phones. A Person_PhoneNumber structure, with fields for Number and Type. The type Person_PhoneType and a value defined for each value in the Person.PhoneType enum. You can read more about the details of exactly what’s generated in the Go Generated Code guide, but for the most part you can treat these as perfectly ordinary Go types.\nHere’s an example from the list_people command’s unit tests of how you might create an instance of Person:\np := pb.Person{ Id: 1234, Name: \"John Doe\", Email: \"jdoe@example.com\", Phones: []*pb.Person_PhoneNumber{ {Number: \"555-4321\", Type: pb.Person_HOME}, }, } Writing a Message The whole purpose of using protocol buffers is to serialize your data so that it can be parsed elsewhere. In Go, you use the proto library’s Marshal function to serialize your protocol buffer data. A pointer to a protocol buffer message’s struct implements the proto.Message interface. Calling proto.Marshal returns the protocol buffer, encoded in its wire format. For example, we use this function in the add_person command:\nbook := \u0026pb.AddressBook{} // ... // Write the new address book back to disk. out, err := proto.Marshal(book) if err != nil { log.Fatalln(\"Failed to encode address book:\", err) } if err := ioutil.WriteFile(fname, out, 0644); err != nil { log.Fatalln(\"Failed to write address book:\", err) } Reading a Message To parse an encoded message, you use the proto library’s Unmarshal function. Calling this parses the data in in as a protocol buffer and places the result in book. So to parse the file in the list_people command, we use:\n// Read the existing address book. in, err := ioutil.ReadFile(fname) if err != nil { log.Fatalln(\"Error reading file:\", err) } book := \u0026pb.AddressBook{} if err := proto.Unmarshal(in, book); err != nil { log.Fatalln(\"Failed to parse address book:\", err) } Extending a Protocol Buffer Sooner or later after you release the code that uses your protocol buffer, you will undoubtedly want to “improve” the protocol buffer’s definition. If you want your new buffers to be backwards-compatible, and your old buffers to be forward-compatible – and you almost certainly do want this – then there are some rules you need to follow. In the new version of the protocol buffer:\nyou must not change the tag numbers of any existing fields. you may delete fields. you may add new fields but you must use fresh tag numbers (i.e. tag numbers that were never used in this protocol buffer, not even by deleted fields). (There are some exceptions to these rules, but they are rarely used.)\nIf you follow these rules, old code will happily read new messages and simply ignore any new fields. To the old code, singular fields that were deleted will simply have their default value, and deleted repeated fields will be empty. New code will also transparently read old messages.\nHowever, keep in mind that new fields will not be present in old messages, so you will need to do something reasonable with the default value. A type-specific default value is used: for strings, the default value is the empty string. For booleans, the default value is false. For numeric types, the default value is zero.\n","categories":"","description":"This tutorial provides a basic Go programmers introduction to working with protocol buffers.","excerpt":"This tutorial provides a basic Go programmers introduction to working …","ref":"/getting-started/gotutorial/","tags":"","title":"Protocol Buffer Basics: Go"},{"body":"This tutorial provides a basic Java programmer’s introduction to working with protocol buffers. By walking through creating a simple example application, it shows you how to\nDefine message formats in a .proto file. Use the protocol buffer compiler. Use the Java protocol buffer API to write and read messages. This isn’t a comprehensive guide to using protocol buffers in Java. For more detailed reference information, see the Protocol Buffer Language Guide (proto2), the Protocol Buffer Language Guide (proto3), the Java API Reference, the Java Generated Code Guide, and the Encoding Reference.\nThe Problem Domain The example we’re going to use is a very simple “address book” application that can read and write people’s contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.\nHow do you serialize and retrieve structured data like this? There are a few ways to solve this problem:\nUse Java Serialization. This is the default approach since it’s built into the language, but it has a host of well-known problems (see Effective Java, by Josh Bloch pp. 213), and also doesn’t work very well if you need to share data with applications written in C++ or Python. You can invent an ad-hoc way to encode the data items into a single string – such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing imposes a small run-time cost. This works best for encoding very simple data. Serialize the data to XML. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you want to share data with other applications/projects. However, XML is notoriously space intensive, and encoding/decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be. Instead of these options, you can use protocol buffers. Protocol buffers are the flexible, efficient, automated solution to solve exactly this problem. With protocol buffers, you write a .proto description of the data structure you wish to store. From that, the protocol buffer compiler creates a class that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated class provides getters and setters for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code can still read data encoded with the old format.\nWhere to Find the Example Code The example code is included in the source code package, under the “examples” directory. Download it here.\nDefining Your Protocol Format To create your address book application, you’ll need to start with a .proto file. The definitions in a .proto file are simple: you add a message for each data structure you want to serialize, then specify a name and a type for each field in the message. Here is the .proto file that defines your messages, addressbook.proto.\nsyntax = \"proto2\"; package tutorial; option java_multiple_files = true; option java_package = \"com.example.tutorial.protos\"; option java_outer_classname = \"AddressBookProtos\"; message Person { optional string name = 1; optional int32 id = 2; optional string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { optional string number = 1; optional PhoneType type = 2 [default = HOME]; } repeated PhoneNumber phones = 4; } message AddressBook { repeated Person people = 1; } As you can see, the syntax is similar to C++ or Java. Let’s go through each part of the file and see what it does.\nThe .proto file starts with a package declaration, which helps to prevent naming conflicts between different projects. In Java, the package name is used as the Java package unless you have explicitly specified a java_package, as we have here. Even if you do provide a java_package, you should still define a normal package as well to avoid name collisions in the Protocol Buffers name space as well as in non-Java languages.\nAfter the package declaration, you can see three options that are Java-specific: java_multiple_files, java_package, and java_outer_classname. java_package specifies in what Java package name your generated classes should live. If you don’t specify this explicitly, it simply matches the package name given by the package declaration, but these names usually aren’t appropriate Java package names (since they usually don’t start with a domain name). The java_outer_classname option defines the class name of the wrapper class which will represent this file. If you don’t give a java_outer_classname explicitly, it will be generated by converting the file name to upper camel case. For example, “my_proto.proto” would, by default, use “MyProto” as the wrapper class name. The java_multiple_files = true option enables generating a separate .java file for each generated class (instead of the legacy behavior of generating a single .java file for the wrapper class, using the wrapper class as an outer class, and nesting all the other classes inside the wrapper class).\nNext, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including bool, int32, float, double, and string. You can also add further structure to your messages by using other message types as field types – in the above example the Person message contains PhoneNumber messages, while the AddressBook message contains Person messages. You can even define message types nested inside other messages – as you can see, the PhoneNumber type is defined inside Person. You can also define enum types if you want one of your fields to have one of a predefined list of values – here you want to specify that a phone number can be one of the following phone types: MOBILE, HOME, or WORK.\nThe \" = 1\", \" = 2\" markers on each element identify the unique “tag” that field uses in the binary encoding. Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the tag number, so repeated fields are particularly good candidates for this optimization.\nEach field must be annotated with one of the following modifiers:\noptional: the field may or may not be set. If an optional field value isn’t set, a default value is used. For simple types, you can specify your own default value, as we’ve done for the phone number type in the example. Otherwise, a system default is used: zero for numeric types, the empty string for strings, false for bools. For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of an optional (or required) field which has not been explicitly set always returns that field’s default value. repeated: the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays. required: a value for the field must be provided, otherwise the message will be considered “uninitialized”. Trying to build an uninitialized message will throw a RuntimeException. Parsing an uninitialized message will throw an IOException. Other than this, a required field behaves exactly like an optional field. Important Required Is Forever You should be very careful about marking fields as required. If at some point you wish to stop writing or sending a required field, it will be problematic to change the field to an optional field – old readers will consider messages without this field to be incomplete and may reject or drop them unintentionally. You should consider writing application-specific custom validation routines for your buffers instead. Within Google, required fields are strongly disfavored; most messages defined in proto2 syntax use optional and repeated only. (Proto3 does not support required fields at all.) You’ll find a complete guide to writing .proto files – including all the possible field types – in the Protocol Buffer Language Guide. Don’t go looking for facilities similar to class inheritance, though – protocol buffers don’t do that.\nCompiling Your Protocol Buffers Now that you have a .proto, the next thing you need to do is generate the classes you’ll need to read and write AddressBook (and hence Person and PhoneNumber) messages. To do this, you need to run the protocol buffer compiler protoc on your .proto:\nIf you haven’t installed the compiler, download the package and follow the instructions in the README.\nNow run the compiler, specifying the source directory (where your application’s source code lives – the current directory is used if you don’t provide a value), the destination directory (where you want the generated code to go; often the same as $SRC_DIR), and the path to your .proto. In this case, you…:\nprotoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto Because you want Java classes, you use the --java_out option – similar options are provided for other supported languages.\nThis generates a com/example/tutorial/protos/ subdirectory in your specified destination directory, containing a few generated .java files.\nThe Protocol Buffer API Let’s look at some of the generated code and see what classes and methods the compiler has created for you. If you look in com/example/tutorial/protos/, you can see that it contains .java files defining a class for each message you specified in addressbook.proto. Each class has its own Builder class that you use to create instances of that class. You can find out more about builders in the Builders vs. Messages section below.\nBoth messages and builders have auto-generated accessor methods for each field of the message; messages have only getters while builders have both getters and setters. Here are some of the accessors for the Person class (implementations omitted for brevity):\n// required string name = 1; public boolean hasName(); public String getName(); // required int32 id = 2; public boolean hasId(); public int getId(); // optional string email = 3; public boolean hasEmail(); public String getEmail(); // repeated .tutorial.Person.PhoneNumber phones = 4; public List\u003cPhoneNumber\u003e getPhonesList(); public int getPhonesCount(); public PhoneNumber getPhones(int index); Meanwhile, Person.Builder has the same getters plus setters:\n// required string name = 1; public boolean hasName(); public java.lang.String getName(); public Builder setName(String value); public Builder clearName(); // required int32 id = 2; public boolean hasId(); public int getId(); public Builder setId(int value); public Builder clearId(); // optional string email = 3; public boolean hasEmail(); public String getEmail(); public Builder setEmail(String value); public Builder clearEmail(); // repeated .tutorial.Person.PhoneNumber phones = 4; public List\u003cPhoneNumber\u003e getPhonesList(); public int getPhonesCount(); public PhoneNumber getPhones(int index); public Builder setPhones(int index, PhoneNumber value); public Builder addPhones(PhoneNumber value); public Builder addAllPhones(Iterable\u003cPhoneNumber\u003e value); public Builder clearPhones(); As you can see, there are simple JavaBeans-style getters and setters for each field. There are also has getters for each singular field which return true if that field has been set. Finally, each field has a clear method that un-sets the field back to its empty state.\nRepeated fields have some extra methods – a Count method (which is just shorthand for the list’s size), getters and setters which get or set a specific element of the list by index, an add method which appends a new element to the list, and an addAll method which adds an entire container full of elements to the list.\nNotice how these accessor methods use camel-case naming, even though the .proto file uses lowercase-with-underscores. This transformation is done automatically by the protocol buffer compiler so that the generated classes match standard Java style conventions. You should always use lowercase-with-underscores for field names in your .proto files; this ensures good naming practice in all the generated languages. See the style guide for more on good .proto style.\nFor more information on exactly what members the protocol compiler generates for any particular field definition, see the Java generated code reference.\nEnums and Nested Classes The generated code includes a PhoneType Java 5 enum, nested within Person:\npublic static enum PhoneType { MOBILE(0, 0), HOME(1, 1), WORK(2, 2), ; ... } The nested type Person.PhoneNumber is generated, as you’d expect, as a nested class within Person.\nBuilders vs. Messages The message classes generated by the protocol buffer compiler are all immutable. Once a message object is constructed, it cannot be modified, just like a Java String. To construct a message, you must first construct a builder, set any fields you want to set to your chosen values, then call the builder’s build() method.\nYou may have noticed that each method of the builder which modifies the message returns another builder. The returned object is actually the same builder on which you called the method. It is returned for convenience so that you can string several setters together on a single line of code.\nHere’s an example of how you would create an instance of Person:\nPerson john = Person.newBuilder() .setId(1234) .setName(\"John Doe\") .setEmail(\"jdoe@example.com\") .addPhones( Person.PhoneNumber.newBuilder() .setNumber(\"555-4321\") .setType(Person.PhoneType.HOME)) .build(); Standard Message Methods Each message and builder class also contains a number of other methods that let you check or manipulate the entire message, including:\nisInitialized(): checks if all the required fields have been set. toString(): returns a human-readable representation of the message, particularly useful for debugging. mergeFrom(Message other): (builder only) merges the contents of other into this message, overwriting singular scalar fields, merging composite fields, and concatenating repeated fields. clear(): (builder only) clears all the fields back to the empty state. These methods implement the Message and Message.Builder interfaces shared by all Java messages and builders. For more information, see the complete API documentation for Message.\nParsing and Serialization Finally, each protocol buffer class has methods for writing and reading messages of your chosen type using the protocol buffer binary format. These include:\nbyte[] toByteArray();: serializes the message and returns a byte array containing its raw bytes. static Person parseFrom(byte[] data);: parses a message from the given byte array. void writeTo(OutputStream output);: serializes the message and writes it to an OutputStream. static Person parseFrom(InputStream input);: reads and parses a message from an InputStream. These are just a couple of the options provided for parsing and serialization. Again, see the Message API reference for a complete list.\nImportant Protocol Buffers and Object Oriented Design Protocol buffer classes are basically data holders (like structs in C) that don’t provide additional functionality; they don’t make good first class citizens in an object model. If you want to add richer behavior to a generated class, the best way to do this is to wrap the generated protocol buffer class in an application-specific class. Wrapping protocol buffers is also a good idea if you don’t have control over the design of the .proto file (if, say, you’re reusing one from another project). In that case, you can use the wrapper class to craft an interface better suited to the unique environment of your application: hiding some data and methods, exposing convenience functions, etc. You should never add behavior to the generated classes by inheriting from them. This will break internal mechanisms and is not good object-oriented practice anyway. Writing a Message Now let’s try using your protocol buffer classes. The first thing you want your address book application to be able to do is write personal details to your address book file. To do this, you need to create and populate instances of your protocol buffer classes and then write them to an output stream.\nHere is a program which reads an AddressBook from a file, adds one new Person to it based on user input, and writes the new AddressBook back out to the file again. The parts which directly call or reference code generated by the protocol compiler are highlighted.\nimport com.example.tutorial.protos.AddressBook; import com.example.tutorial.protos.Person; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.InputStreamReader; import java.io.IOException; import java.io.PrintStream; class AddPerson { // This function fills in a Person message based on user input. static Person PromptForAddress(BufferedReader stdin, PrintStream stdout) throws IOException { Person.Builder person = Person.newBuilder(); stdout.print(\"Enter person ID: \"); person.setId(Integer.valueOf(stdin.readLine())); stdout.print(\"Enter name: \"); person.setName(stdin.readLine()); stdout.print(\"Enter email address (blank for none): \"); String email = stdin.readLine(); if (email.length() \u003e 0) { person.setEmail(email); } while (true) { stdout.print(\"Enter a phone number (or leave blank to finish): \"); String number = stdin.readLine(); if (number.length() == 0) { break; } Person.PhoneNumber.Builder phoneNumber = Person.PhoneNumber.newBuilder().setNumber(number); stdout.print(\"Is this a mobile, home, or work phone? \"); String type = stdin.readLine(); if (type.equals(\"mobile\")) { phoneNumber.setType(Person.PhoneType.MOBILE); } else if (type.equals(\"home\")) { phoneNumber.setType(Person.PhoneType.HOME); } else if (type.equals(\"work\")) { phoneNumber.setType(Person.PhoneType.WORK); } else { stdout.println(\"Unknown phone type. Using default.\"); } person.addPhones(phoneNumber); } return person.build(); } // Main function: Reads the entire address book from a file, // adds one person based on user input, then writes it back out to the same // file. public static void main(String[] args) throws Exception { if (args.length != 1) { System.err.println(\"Usage: AddPerson ADDRESS_BOOK_FILE\"); System.exit(-1); } AddressBook.Builder addressBook = AddressBook.newBuilder(); // Read the existing address book. try { addressBook.mergeFrom(new FileInputStream(args[0])); } catch (FileNotFoundException e) { System.out.println(args[0] + \": File not found. Creating a new file.\"); } // Add an address. addressBook.addPerson( PromptForAddress(new BufferedReader(new InputStreamReader(System.in)), System.out)); // Write the new address book back to disk. FileOutputStream output = new FileOutputStream(args[0]); addressBook.build().writeTo(output); output.close(); } } Reading a Message Of course, an address book wouldn’t be much use if you couldn’t get any information out of it! This example reads the file created by the above example and prints all the information in it.\nimport com.example.tutorial.protos.AddressBook; import com.example.tutorial.protos.Person; import java.io.FileInputStream; import java.io.IOException; import java.io.PrintStream; class ListPeople { // Iterates though all people in the AddressBook and prints info about them. static void Print(AddressBook addressBook) { for (Person person: addressBook.getPeopleList()) { System.out.println(\"Person ID: \" + person.getId()); System.out.println(\" Name: \" + person.getName()); if (person.hasEmail()) { System.out.println(\" E-mail address: \" + person.getEmail()); } for (Person.PhoneNumber phoneNumber : person.getPhonesList()) { switch (phoneNumber.getType()) { case MOBILE: System.out.print(\" Mobile phone #: \"); break; case HOME: System.out.print(\" Home phone #: \"); break; case WORK: System.out.print(\" Work phone #: \"); break; } System.out.println(phoneNumber.getNumber()); } } } // Main function: Reads the entire address book from a file and prints all // the information inside. public static void main(String[] args) throws Exception { if (args.length != 1) { System.err.println(\"Usage: ListPeople ADDRESS_BOOK_FILE\"); System.exit(-1); } // Read the existing address book. AddressBook addressBook = AddressBook.parseFrom(new FileInputStream(args[0])); Print(addressBook); } } Extending a Protocol Buffer Sooner or later after you release the code that uses your protocol buffer, you will undoubtedly want to “improve” the protocol buffer’s definition. If you want your new buffers to be backwards-compatible, and your old buffers to be forward-compatible – and you almost certainly do want this – then there are some rules you need to follow. In the new version of the protocol buffer:\nyou must not change the tag numbers of any existing fields. you must not add or delete any required fields. you may delete optional or repeated fields. you may add new optional or repeated fields but you must use fresh tag numbers (that is, tag numbers that were never used in this protocol buffer, not even by deleted fields). (There are some exceptions to these rules, but they are rarely used.)\nIf you follow these rules, old code will happily read new messages and simply ignore any new fields. To the old code, optional fields that were deleted will simply have their default value, and deleted repeated fields will be empty. New code will also transparently read old messages. However, keep in mind that new optional fields will not be present in old messages, so you will need to either check explicitly whether they’re set with has_, or provide a reasonable default value in your .proto file with [default = value] after the tag number. If the default value is not specified for an optional element, a type-specific default value is used instead: for strings, the default value is the empty string. For booleans, the default value is false. For numeric types, the default value is zero. Note also that if you added a new repeated field, your new code will not be able to tell whether it was left empty (by new code) or never set at all (by old code) since there is no has_ flag for it.\nAdvanced Usage Protocol buffers have uses that go beyond simple accessors and serialization. Be sure to explore the Java API reference to see what else you can do with them.\nOne key feature provided by protocol message classes is reflection. You can iterate over the fields of a message and manipulate their values without writing your code against any specific message type. One very useful way to use reflection is for converting protocol messages to and from other encodings, such as XML or JSON. A more advanced use of reflection might be to find differences between two messages of the same type, or to develop a sort of “regular expressions for protocol messages” in which you can write expressions that match certain message contents. If you use your imagination, it’s possible to apply Protocol Buffers to a much wider range of problems than you might initially expect!\nReflection is provided as part of the Message and Message.Builder interfaces.\n","categories":"","description":"This tutorial provides a basic Java programmers introduction to working with protocol buffers.","excerpt":"This tutorial provides a basic Java programmers introduction to …","ref":"/getting-started/javatutorial/","tags":"","title":"Protocol Buffer Basics: Java"},{"body":"This tutorial provides a basic Kotlin programmer’s introduction to working with protocol buffers, using the proto3 version of the protocol buffers language. By walking through creating a simple example application, it shows you how to\nDefine message formats in a .proto file. Use the protocol buffer compiler. Use the Kotlin protocol buffer API to write and read messages. This isn’t a comprehensive guide to using protocol buffers in Kotlin. For more detailed reference information, see the Protocol Buffer Language Guide, the Kotlin API Reference, the Kotlin Generated Code Guide, and the Encoding Reference.\nThe Problem Domain The example we’re going to use is a very simple “address book” application that can read and write people’s contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.\nHow do you serialize and retrieve structured data like this? There are a few ways to solve this problem:\nUse kotlinx.serialization. This does not work very well if you need to share data with applications written in C++ or Python. kotlinx.serialization has a protobuf mode, but this does not offer the full features of protocol buffers. You can invent an ad-hoc way to encode the data items into a single string – such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing imposes a small run-time cost. This works best for encoding very simple data. Serialize the data to XML. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you want to share data with other applications/projects. However, XML is notoriously space intensive, and encoding/decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be. Protocol buffers are the flexible, efficient, automated solution to solve exactly this problem. With protocol buffers, you write a .proto description of the data structure you wish to store. From that, the protocol buffer compiler creates a class that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated class provides getters and setters for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code can still read data encoded with the old format.\nWhere to Find the Example Code Our example is a set of command-line applications for managing an address book data file, encoded using protocol buffers. The command add_person_kotlin adds a new entry to the data file. The command list_people_kotlin parses the data file and prints the data to the console.\nYou can find the complete example in the examples directory of the GitHub repository.\nDefining Your Protocol Format To create your address book application, you’ll need to start with a .proto file. The definitions in a .proto file are simple: you add a message for each data structure you want to serialize, then specify a name and a type for each field in the message. In our example, the .proto file that defines the messages is addressbook.proto.\nThe .proto file starts with a package declaration, which helps to prevent naming conflicts between different projects.\nsyntax = \"proto3\"; package tutorial; import \"google/protobuf/timestamp.proto\"; Next, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including bool, int32, float, double, and string. You can also add further structure to your messages by using other message types as field types.\nmessage Person { string name = 1; int32 id = 2; // Unique ID number for this person. string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { string number = 1; PhoneType type = 2; } repeated PhoneNumber phones = 4; google.protobuf.Timestamp last_updated = 5; } // Our address book file is just one of these. message AddressBook { repeated Person people = 1; } In the above example, the Person message contains PhoneNumber messages, while the AddressBook message contains Person messages. You can even define message types nested inside other messages – as you can see, the PhoneNumber type is defined inside Person. You can also define enum types if you want one of your fields to have one of a predefined list of values – here you want to specify that a phone number can be one of MOBILE, HOME, or WORK.\nThe \" = 1\", \" = 2\" markers on each element identify the unique “tag” that field uses in the binary encoding. Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the tag number, so repeated fields are particularly good candidates for this optimization.\nIf a field value isn’t set, a default value is used: zero for numeric types, the empty string for strings, false for bools. For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of a field which has not been explicitly set always returns that field’s default value.\nIf a field is repeated, the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays.\nYou’ll find a complete guide to writing .proto files – including all the possible field types – in the Protocol Buffer Language Guide. Don’t go looking for facilities similar to class inheritance, though – protocol buffers don’t do that.\nCompiling Your Protocol Buffers Now that you have a .proto, the next thing you need to do is generate the classes you’ll need to read and write AddressBook (and hence Person and PhoneNumber) messages. To do this, you need to run the protocol buffer compiler protoc on your .proto:\nIf you haven’t installed the compiler, download the package and follow the instructions in the README.\nNow run the compiler, specifying the source directory (where your application’s source code lives – the current directory is used if you don’t provide a value), the destination directory (where you want the generated code to go; often the same as $SRC_DIR), and the path to your .proto. In this case, you would invoke:\nprotoc -I=$SRC_DIR --java_out=$DST_DIR --kotlin_out=$DST_DIR $SRC_DIR/addressbook.proto Because you want Kotlin code, you use the --kotlin_out option – similar options are provided for other supported languages.\nNote that if you want to generate Kotlin code you must use both --java_out and --kotlin_out. This generates a com/example/tutorial/protos/ subdirectory in your specified Java destination directory, containing a few generated .java files and a com/example/tutorial/protos/ subdirectory in your specified Kotlin destination directory, containing a few generated .kt files.\nThe Protocol Buffer API The protocol buffer compiler for Kotlin generates Kotlin APIs that add to the existing APIs generated for protocol buffers for Java. This ensures that codebases written in a mix of Java and Kotlin can interact with the same protocol buffer message objects without any special handling or conversion.\nProtocol buffers for other Kotlin compilation targets, such as Javascript and native, are not currently supported.\nCompiling addressbook.proto gives you the following APIs in Java:\nThe AddressBook class which, from Kotlin, has the peopleList : List\u003cPerson\u003e property The Person class which, from Kotlin, has name, id, email, and phonesList properties the Person.PhoneNumber nested class with number and type properties the Person.PhoneType nested enum but also generates the following Kotlin APIs:\nThe addressBook { ... } and person { ... } factory methods A PersonKt object, with a phoneNumber { ... } factory method You can read more about the details of exactly what’s generated in the Kotlin Generated Code guide.\nWriting a Message Now let’s try using your protocol buffer classes. The first thing you want your address book application to be able to do is write personal details to your address book file. To do this, you need to create and populate instances of your protocol buffer classes and then write them to an output stream.\nHere is a program which reads an AddressBook from a file, adds one new Person to it based on user input, and writes the new AddressBook back out to the file again. The parts which directly call or reference code generated by the protocol compiler are highlighted.\nimport com.example.tutorial.Person import com.example.tutorial.AddressBook import com.example.tutorial.person import com.example.tutorial.addressBook import com.example.tutorial.PersonKt.phoneNumber import java.util.Scanner // This function fills in a Person message based on user input. fun promptPerson(): Person = person { print(\"Enter person ID: \") id = readLine().toInt() print(\"Enter name: \") name = readLine() print(\"Enter email address (blank for none): \") val email = readLine() if (email.isNotEmpty()) { this.email = email } while (true) { print(\"Enter a phone number (or leave blank to finish): \") val number = readLine() if (number.isEmpty()) break print(\"Is this a mobile, home, or work phone? \") val type = when (readLine()) { \"mobile\" -\u003e Person.PhoneType.MOBILE \"home\" -\u003e Person.PhoneType.HOME \"work\" -\u003e Person.PhoneType.WORK else -\u003e { println(\"Unknown phone type. Using home.\") Person.PhoneType.HOME } } phones += phoneNumber { this.number = number this.type = type } } } // Reads the entire address book from a file, adds one person based // on user input, then writes it back out to the same file. fun main(args: List) { if (arguments.size != 1) { println(\"Usage: add_person ADDRESS_BOOK_FILE\") exitProcess(-1) } val path = Path(arguments.single()) val initialAddressBook = if (!path.exists()) { println(\"File not found. Creating new file.\") addressBook {} } else { path.inputStream().use { AddressBook.newBuilder().mergeFrom(it).build() } } path.outputStream().use { initialAddressBook.copy { peopleList += promptPerson() }.writeTo(it) } } Reading a Message Of course, an address book wouldn’t be much use if you couldn’t get any information out of it! This example reads the file created by the above example and prints all the information in it.\nimport com.example.tutorial.Person import com.example.tutorial.AddressBook // Iterates though all people in the AddressBook and prints info about them. fun print(addressBook: AddressBook) { for (person in addressBook.peopleList) { println(\"Person ID: ${person.id}\") println(\" Name: ${person.name}\") if (person.hasEmail()) { println(\" Email address: ${person.email}\") } for (phoneNumber in person.phonesList) { val modifier = when (phoneNumber.type) { Person.PhoneType.MOBILE -\u003e \"Mobile\" Person.PhoneType.HOME -\u003e \"Home\" Person.PhoneType.WORK -\u003e \"Work\" else -\u003e \"Unknown\" } println(\" $modifier phone #: ${phoneNumber.number}\") } } } fun main(args: List) { if (arguments.size != 1) { println(\"Usage: list_person ADDRESS_BOOK_FILE\") exitProcess(-1) } Path(arguments.single()).inputStream().use { print(AddressBook.newBuilder().mergeFrom(it).build()) } } Extending a Protocol Buffer Sooner or later after you release the code that uses your protocol buffer, you will undoubtedly want to “improve” the protocol buffer’s definition. If you want your new buffers to be backwards-compatible, and your old buffers to be forward-compatible – and you almost certainly do want this – then there are some rules you need to follow. In the new version of the protocol buffer:\nyou must not change the tag numbers of any existing fields. you may delete fields. you may add new fields but you must use fresh tag numbers (i.e. tag numbers that were never used in this protocol buffer, not even by deleted fields). (There are some exceptions to these rules, but they are rarely used.)\nIf you follow these rules, old code will happily read new messages and simply ignore any new fields. To the old code, singular fields that were deleted will simply have their default value, and deleted repeated fields will be empty. New code will also transparently read old messages.\nHowever, keep in mind that new fields will not be present in old messages, so you will need to do something reasonable with the default value. A type-specific default value is used: for strings, the default value is the empty string. For booleans, the default value is false. For numeric types, the default value is zero.\n","categories":"","description":"This tutorial provides a basic Kotlin programmers introduction to working with protocol buffers.","excerpt":"This tutorial provides a basic Kotlin programmers introduction to …","ref":"/getting-started/kotlintutorial/","tags":"","title":"Protocol Buffer Basics: Kotlin"},{"body":"This tutorial provides a basic Python programmer’s introduction to working with protocol buffers. By walking through creating a simple example application, it shows you how to\nDefine message formats in a .proto file. Use the protocol buffer compiler. Use the Python protocol buffer API to write and read messages. This isn’t a comprehensive guide to using protocol buffers in Python. For more detailed reference information, see the Protocol Buffer Language Guide (proto2), the Protocol Buffer Language Guide (proto3), the Python API Reference, the Python Generated Code Guide, and the Encoding Reference.\nThe Problem Domain The example we’re going to use is a very simple “address book” application that can read and write people’s contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.\nHow do you serialize and retrieve structured data like this? There are a few ways to solve this problem:\nUse Python pickling. This is the default approach since it’s built into the language, but it doesn’t deal well with schema evolution, and also doesn’t work very well if you need to share data with applications written in C++ or Java. You can invent an ad-hoc way to encode the data items into a single string – such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing imposes a small run-time cost. This works best for encoding very simple data. Serialize the data to XML. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you want to share data with other applications/projects. However, XML is notoriously space intensive, and encoding/decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be. Instead of these options, you can use protocol buffers. Protocol buffers are the flexible, efficient, automated solution to solve exactly this problem. With protocol buffers, you write a .proto description of the data structure you wish to store. From that, the protocol buffer compiler creates a class that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated class provides getters and setters for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code can still read data encoded with the old format.\nWhere to Find the Example Code The example code is included in the source code package, under the “examples” directory. Download it here.\nDefining Your Protocol Format To create your address book application, you’ll need to start with a .proto file. The definitions in a .proto file are simple: you add a message for each data structure you want to serialize, then specify a name and a type for each field in the message. Here is the .proto file that defines your messages, addressbook.proto.\nsyntax = \"proto2\"; package tutorial; message Person { optional string name = 1; optional int32 id = 2; optional string email = 3; enum PhoneType { MOBILE = 0; HOME = 1; WORK = 2; } message PhoneNumber { optional string number = 1; optional PhoneType type = 2 [default = HOME]; } repeated PhoneNumber phones = 4; } message AddressBook { repeated Person people = 1; } As you can see, the syntax is similar to C++ or Java. Let’s go through each part of the file and see what it does.\nThe .proto file starts with a package declaration, which helps to prevent naming conflicts between different projects. In Python, packages are normally determined by directory structure, so the package you define in your .proto file will have no effect on the generated code. However, you should still declare one to avoid name collisions in the Protocol Buffers name space as well as in non-Python languages.\nNext, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including bool, int32, float, double, and string. You can also add further structure to your messages by using other message types as field types – in the above example the Person message contains PhoneNumber messages, while the AddressBook message contains Person messages. You can even define message types nested inside other messages – as you can see, the PhoneNumber type is defined inside Person. You can also define enum types if you want one of your fields to have one of a predefined list of values – here you want to specify that a phone number can be one of the following phone types: MOBILE, HOME, or WORK.\nThe \" = 1\", \" = 2\" markers on each element identify the unique “tag” that field uses in the binary encoding. Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the tag number, so repeated fields are particularly good candidates for this optimization.\nEach field must be annotated with one of the following modifiers:\noptional: the field may or may not be set. If an optional field value isn’t set, a default value is used. For simple types, you can specify your own default value, as we’ve done for the phone number type in the example. Otherwise, a system default is used: zero for numeric types, the empty string for strings, false for bools. For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of an optional (or required) field which has not been explicitly set always returns that field’s default value. repeated: the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays. required: a value for the field must be provided, otherwise the message will be considered “uninitialized”. Serializing an uninitialized message will raise an exception. Parsing an uninitialized message will fail. Other than this, a required field behaves exactly like an optional field. Important Required Is Forever You should be very careful about marking fields as required. If at some point you wish to stop writing or sending a required field, it will be problematic to change the field to an optional field – old readers will consider messages without this field to be incomplete and may reject or drop them unintentionally. You should consider writing application-specific custom validation routines for your buffers instead. Within Google, required fields are strongly disfavored; most messages defined in proto2 syntax use optional and repeated only. (Proto3 does not support required fields at all.) You’ll find a complete guide to writing .proto files – including all the possible field types – in the Protocol Buffer Language Guide. Don’t go looking for facilities similar to class inheritance, though – protocol buffers don’t do that.\nCompiling Your Protocol Buffers Now that you have a .proto, the next thing you need to do is generate the classes you’ll need to read and write AddressBook (and hence Person and PhoneNumber) messages. To do this, you need to run the protocol buffer compiler protoc on your .proto:\nIf you haven’t installed the compiler, download the package and follow the instructions in the README.\nNow run the compiler, specifying the source directory (where your application’s source code lives – the current directory is used if you don’t provide a value), the destination directory (where you want the generated code to go; often the same as $SRC_DIR), and the path to your .proto. In this case, you…:\nprotoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/addressbook.proto Because you want Python classes, you use the --python_out option – similar options are provided for other supported languages.\nThis generates addressbook_pb2.py in your specified destination directory.\nThe Protocol Buffer API Unlike when you generate Java and C++ protocol buffer code, the Python protocol buffer compiler doesn’t generate your data access code for you directly. Instead (as you’ll see if you look at addressbook_pb2.py) it generates special descriptors for all your messages, enums, and fields, and some mysteriously empty classes, one for each message type:\nclass Person(message.Message): __metaclass__ = reflection.GeneratedProtocolMessageType class PhoneNumber(message.Message): __metaclass__ = reflection.GeneratedProtocolMessageType DESCRIPTOR = _PERSON_PHONENUMBER DESCRIPTOR = _PERSON class AddressBook(message.Message): __metaclass__ = reflection.GeneratedProtocolMessageType DESCRIPTOR = _ADDRESSBOOK The important line in each class is __metaclass__ = reflection.GeneratedProtocolMessageType. While the details of how Python metaclasses work is beyond the scope of this tutorial, you can think of them as like a template for creating classes. At load time, the GeneratedProtocolMessageType metaclass uses the specified descriptors to create all the Python methods you need to work with each message type and adds them to the relevant classes. You can then use the fully-populated classes in your code.\nThe end effect of all this is that you can use the Person class as if it defined each field of the Message base class as a regular field. For example, you could write:\nimport addressbook_pb2 person = addressbook_pb2.Person() person.id = 1234 person.name = \"John Doe\" person.email = \"jdoe@example.com\" phone = person.phones.add() phone.number = \"555-4321\" phone.type = addressbook_pb2.Person.HOME Note that these assignments are not just adding arbitrary new fields to a generic Python object. If you were to try to assign a field that isn’t defined in the .proto file, an AttributeError would be raised. If you assign a field to a value of the wrong type, a TypeError will be raised. Also, reading the value of a field before it has been set returns the default value.\nperson.no_such_field = 1 # raises AttributeError person.id = \"1234\" # raises TypeError For more information on exactly what members the protocol compiler generates for any particular field definition, see the Python generated code reference.\nEnums Enums are expanded by the metaclass into a set of symbolic constants with integer values. So, for example, the constant addressbook_pb2.Person.PhoneType.WORK has the value 2.\nStandard Message Methods Each message class also contains a number of other methods that let you check or manipulate the entire message, including:\nIsInitialized(): checks if all the required fields have been set. __str__(): returns a human-readable representation of the message, particularly useful for debugging. (Usually invoked as str(message) or print message.) CopyFrom(other_msg): overwrites the message with the given message’s values. Clear(): clears all the elements back to the empty state. These methods implement the Message interface. For more information, see the complete API documentation for Message.\nParsing and Serialization Finally, each protocol buffer class has methods for writing and reading messages of your chosen type using the protocol buffer binary format. These include:\nSerializeToString(): serializes the message and returns it as a string. Note that the bytes are binary, not text; we only use the str type as a convenient container. ParseFromString(data): parses a message from the given string. These are just a couple of the options provided for parsing and serialization. Again, see the Message API reference for a complete list.\nImportant Protocol Buffers and Object Oriented Design Protocol buffer classes are basically data holders (like structs in C) that don’t provide additional functionality; they don’t make good first class citizens in an object model. If you want to add richer behavior to a generated class, the best way to do this is to wrap the generated protocol buffer class in an application-specific class. Wrapping protocol buffers is also a good idea if you don’t have control over the design of the .proto file (if, say, you’re reusing one from another project). In that case, you can use the wrapper class to craft an interface better suited to the unique environment of your application: hiding some data and methods, exposing convenience functions, etc. You should never add behavior to the generated classes by inheriting from them. This will break internal mechanisms and is not good object-oriented practice anyway. Writing a Message Now let’s try using your protocol buffer classes. The first thing you want your address book application to be able to do is write personal details to your address book file. To do this, you need to create and populate instances of your protocol buffer classes and then write them to an output stream.\nHere is a program which reads an AddressBook from a file, adds one new Person to it based on user input, and writes the new AddressBook back out to the file again. The parts which directly call or reference code generated by the protocol compiler are highlighted.\n#!/usr/bin/env python3 import addressbook_pb2 import sys # This function fills in a Person message based on user input. def PromptForAddress(person): person.id = int(input(\"Enter person ID number: \")) person.name = input(\"Enter name: \") email = input(\"Enter email address (blank for none): \") if email != \"\": person.email = email while True: number = input(\"Enter a phone number (or leave blank to finish): \") if number == \"\": break phone_number = person.phones.add() phone_number.number = number phone_type = input(\"Is this a mobile, home, or work phone? \") if phone_type == \"mobile\": phone_number.type = addressbook_pb2.Person.PhoneType.MOBILE elif phone_type == \"home\": phone_number.type = addressbook_pb2.Person.PhoneType.HOME elif phone_type == \"work\": phone_number.type = addressbook_pb2.Person.PhoneType.WORK else: print(\"Unknown phone type; leaving as default value.\") # Main procedure: Reads the entire address book from a file, # adds one person based on user input, then writes it back out to the same # file. if len(sys.argv) != 2: print(\"Usage:\", sys.argv[0], \"ADDRESS_BOOK_FILE\") sys.exit(-1) address_book = addressbook_pb2.AddressBook() # Read the existing address book. try: with open(sys.argv[1], \"rb\") as f: address_book.ParseFromString(f.read()) except IOError: print(sys.argv[1] + \": Could not open file. Creating a new one.\") # Add an address. PromptForAddress(address_book.people.add()) # Write the new address book back to disk. with open(sys.argv[1], \"wb\") as f: f.write(address_book.SerializeToString()) Reading a Message Of course, an address book wouldn’t be much use if you couldn’t get any information out of it! This example reads the file created by the above example and prints all the information in it.\n#!/usr/bin/env python3 import addressbook_pb2 import sys # Iterates though all people in the AddressBook and prints info about them. def ListPeople(address_book): for person in address_book.people: print(\"Person ID:\", person.id) print(\" Name:\", person.name) if person.HasField('email'): print(\" E-mail address:\", person.email) for phone_number in person.phones: if phone_number.type == addressbook_pb2.Person.PhoneType.MOBILE: print(\" Mobile phone #: \", end=\"\") elif phone_number.type == addressbook_pb2.Person.PhoneType.HOME: print(\" Home phone #: \", end=\"\") elif phone_number.type == addressbook_pb2.Person.PhoneType.WORK: print(\" Work phone #: \", end=\"\") print(phone_number.number) # Main procedure: Reads the entire address book from a file and prints all # the information inside. if len(sys.argv) != 2: print(\"Usage:\", sys.argv[0], \"ADDRESS_BOOK_FILE\") sys.exit(-1) address_book = addressbook_pb2.AddressBook() # Read the existing address book. with open(sys.argv[1], \"rb\") as f: address_book.ParseFromString(f.read()) ListPeople(address_book) Extending a Protocol Buffer Sooner or later after you release the code that uses your protocol buffer, you will undoubtedly want to “improve” the protocol buffer’s definition. If you want your new buffers to be backwards-compatible, and your old buffers to be forward-compatible – and you almost certainly do want this – then there are some rules you need to follow. In the new version of the protocol buffer:\nyou must not change the tag numbers of any existing fields. you must not add or delete any required fields. you may delete optional or repeated fields. you may add new optional or repeated fields but you must use fresh tag numbers (that is, tag numbers that were never used in this protocol buffer, not even by deleted fields). (There are some exceptions to these rules, but they are rarely used.)\nIf you follow these rules, old code will happily read new messages and simply ignore any new fields. To the old code, optional fields that were deleted will simply have their default value, and deleted repeated fields will be empty. New code will also transparently read old messages. However, keep in mind that new optional fields will not be present in old messages, so you will need to either check explicitly whether they’re set with has_, or provide a reasonable default value in your .proto file with [default = value] after the tag number. If the default value is not specified for an optional element, a type-specific default value is used instead: for strings, the default value is the empty string. For booleans, the default value is false. For numeric types, the default value is zero. Note also that if you added a new repeated field, your new code will not be able to tell whether it was left empty (by new code) or never set at all (by old code) since there is no has_ flag for it.\nAdvanced Usage Protocol buffers have uses that go beyond simple accessors and serialization. Be sure to explore the Python API reference to see what else you can do with them.\nOne key feature provided by protocol message classes is reflection. You can iterate over the fields of a message and manipulate their values without writing your code against any specific message type. One very useful way to use reflection is for converting protocol messages to and from other encodings, such as XML or JSON. A more advanced use of reflection might be to find differences between two messages of the same type, or to develop a sort of “regular expressions for protocol messages” in which you can write expressions that match certain message contents. If you use your imagination, it’s possible to apply Protocol Buffers to a much wider range of problems than you might initially expect!\nReflection is provided as part of the Message interface.\n","categories":"","description":"This tutorial provides a basic Python programmers introduction to working with protocol buffers.","excerpt":"This tutorial provides a basic Python programmers introduction to …","ref":"/getting-started/pythontutorial/","tags":"","title":"Protocol Buffer Basics: Python"},{"body":"This section contains reference documentation for working with protocol buffer classes in C++, Java, Python, Go, C#, Objective-C, Ruby, PHP, and Dart, as well as some reference documentation for Protocol Buffers itself. The documentation for each language includes (where available):\nA reference guide to the code generated by the protocol buffer compiler from your .proto files. Generated API documentation for the provided source code. Note that there are APIs for several more languages in the pipeline – for details, see Other Languages.\nC++ Reference C++ Generated Code Guide\nC++ Arena Allocation Guide\nC++ API\nC# Reference C# Generated Code Guide C# API Dart Reference Dart Generated Code Guide Dart API (Dartdoc) Go Reference Go Generated Code Guide\nGo API (godoc)\nGo FAQ\nJava Reference Java Generated Code Guide Java Proto Names Java API (Javadoc) Kotlin Reference Kotlin Generated Code Guide Kotlin API Objective-C Reference Objective-C Generated Code Guide PHP Reference PHP Generated Code Guide PHP API Python Reference Python Generated Code Guide Python API (Sphinx) Ruby Reference Ruby Generated Code Guide Protocol Buffers Reference Protocol Buffers Version 2 Language Specification Protocol Buffers Version 3 Language Specification Text Format Language Specification Other Other Languages ","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in C++, Java, Python, Go, C#, Objective-C, Ruby, PHP, and Dart, as well as some reference documentation for Protocol Buffers itself.","excerpt":"This section contains reference documentation for working with …","ref":"/reference/","tags":"","title":"Reference Guides"},{"body":" C++ Generated Code Guide\nC++ Arena Allocation Guide\nC++ API\n","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in C++.","excerpt":"This section contains reference documentation for working with …","ref":"/reference/cpp/","tags":"","title":"C++ Reference"},{"body":"This page describes exactly what C++ code the protocol buffer compiler generates for any given protocol definition. Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.\nCompiler Invocation The protocol buffer compiler produces C++ output when invoked with the --cpp_out= command-line flag. The parameter to the --cpp_out= option is the directory where you want the compiler to write your C++ output. The compiler creates a header file and an implementation file for each .proto file input. The names of the output files are computed by taking the name of the .proto file and making two changes:\nThe extension (.proto) is replaced with either .pb.h or .pb.cc for the header or implementation file, respectively. The proto path (specified with the --proto_path= or -I command-line flag) is replaced with the output path (specified with the --cpp_out= flag). So, for example, let’s say you invoke the compiler as follows:\nprotoc --proto_path=src --cpp_out=build/gen src/foo.proto src/bar/baz.proto The compiler will read the files src/foo.proto and src/bar/baz.proto and produce four output files: build/gen/foo.pb.h, build/gen/foo.pb.cc, build/gen/bar/baz.pb.h, build/gen/bar/baz.pb.cc. The compiler will automatically create the directory build/gen/bar if necessary, but it will not create build or build/gen; they must already exist.\nPackages If a .proto file contains a package declaration, the entire contents of the file will be placed in a corresponding C++ namespace. For example, given the package declaration:\npackage foo.bar; All declarations in the file will reside in the foo::bar namespace.\nMessages Given a simple message declaration:\nmessage Foo {} The protocol buffer compiler generates a class called Foo, which publicly derives from google::protobuf::Message. The class is a concrete class; no pure-virtual methods are left unimplemented. Methods that are virtual in Message but not pure-virtual may or may not be overridden by Foo, depending on the optimization mode. By default, Foo implements specialized versions of all methods for maximum speed. However, if the .proto file contains the line:\noption optimize_for = CODE_SIZE; then Foo will override only the minimum set of methods necessary to function and rely on reflection-based implementations of the rest. This significantly reduces the size of the generated code, but also reduces performance. Alternatively, if the .proto file contains:\noption optimize_for = LITE_RUNTIME; then Foo will include fast implementations of all methods, but will implement the google::protobuf::MessageLite interface, which only contains a subset of the methods of Message. In particular, it does not support descriptors or reflection. However, in this mode, the generated code only needs to link against libprotobuf-lite.so (libprotobuf-lite.lib on Windows) instead of libprotobuf.so (libprotobuf.lib). The “lite” library is much smaller than the full library, and is more appropriate for resource-constrained systems such as mobile phones.\nYou should not create your own Foo subclasses. If you subclass this class and override a virtual method, the override may be ignored, as many generated method calls are de-virtualized to improve performance.\nThe Message interface defines methods that let you check, manipulate, read, or write the entire message, including parsing from and serializing to binary strings.\nbool ParseFromString(const string\u0026 data): Parse the message from the given serialized binary string (also known as wire format). bool SerializeToString(string* output) const: Serialize the given message to a binary string. string DebugString(): Return a string giving the text_format representation of the proto (should only be used for debugging). In addition to these methods, the Foo class defines the following methods:\nFoo(): Default constructor. ~Foo(): Default destructor. Foo(const Foo\u0026 other): Copy constructor. Foo(Foo\u0026\u0026 other): Move constructor. Foo\u0026 operator=(const Foo\u0026 other): Assignment operator. Foo\u0026 operator=(Foo\u0026\u0026 other): Move-assignment operator. void Swap(Foo* other): Swap content with another message. const UnknownFieldSet\u0026 unknown_fields() const: Returns the set of unknown fields encountered while parsing this message. UnknownFieldSet* mutable_unknown_fields(): Returns a pointer to the mutable set of unknown fields encountered while parsing this message. The class also defines the following static methods:\nstatic const Descriptor* descriptor(): Returns the type’s descriptor. This contains information about the type, including what fields it has and what their types are. This can be used with reflection to inspect fields programmatically. static const Foo\u0026 default_instance(): Returns a const singleton instance of Foo which is identical to a newly-constructed instance of Foo (so all singular fields are unset and all repeated fields are empty). Note that the default instance of a message can be used as a factory by calling its New() method. Nested Types A message can be declared inside another message. For example:\nmessage Foo { message Bar {} } In this case, the compiler generates two classes: Foo and Foo_Bar. In addition, the compiler generates a typedef inside Foo as follows:\ntypedef Foo_Bar Bar; This means that you can use the nested type’s class as if it was the nested class Foo::Bar. However, note that C++ does not allow nested types to be forward-declared. If you want to forward-declare Bar in another file and use that declaration, you must identify it as Foo_Bar.\nFields In addition to the methods described in the previous section, the protocol buffer compiler generates a set of accessor methods for each field defined within the message in the .proto file. These methods are in lower-case/snake-case, such as has_foo() and clear_foo().\nAs well as accessor methods, the compiler generates an integer constant for each field containing its field number. The constant name is the letter k, followed by the field name converted to camel-case, followed by FieldNumber. For example, given the field optional int32 foo_bar = 5;, the compiler will generate the constant static const int kFooBarFieldNumber = 5;.\nFor field accessors returning a const reference, that reference may be invalidated when the next modifying access is made to the message. This includes calling any non-const accessor of any field, calling any non-const method inherited from Message or modifying the message through other ways (for example, by using the message as the argument of Swap()). Correspondingly, the address of the returned reference is only guaranteed to be the same across different invocations of the accessor if no modifying access was made to the message in the meantime.\nFor field accessors returning a pointer, that pointer may be invalidated when the next modifying or non-modifying access is made to the message. This includes, regardless of constness, calling any accessor of any field, calling any method inherited from Message or accessing the message through other ways (for example, by copying the message using the copy constructor). Correspondingly, the value of the returned pointer is never guaranteed to be the same across two different invocations of the accessor.\nSingular Numeric Fields (proto2) For either of these field definitions:\noptional int32 foo = 1; required int32 foo = 1; The compiler will generate the following accessor methods:\nbool has_foo() const: Returns true if the field is set. int32 foo() const: Returns the current value of the field. If the field is not set, returns the default value. void set_foo(int32 value): Sets the value of the field. After calling this, has_foo() will return true and foo() will return value. void clear_foo(): Clears the value of the field. After calling this, has_foo() will return false and foo() will return the default value. For other numeric field types (including bool), int32 is replaced with the corresponding C++ type according to the scalar value types table.\nSingular Numeric Fields (proto3) For this field definition:\nint32 foo = 1; The compiler will generate the following accessor methods:\nint32 foo() const: Returns the current value of the field. If the field is not set, returns 0. void set_foo(int32 value): Sets the value of the field. After calling this, foo() will return value. void clear_foo(): Clears the value of the field. After calling this, foo() will return 0. For other numeric field types (including bool), int32 is replaced with the corresponding C++ type according to the scalar value types table.\nSingular String Fields (proto2) For any of these field definitions:\noptional string foo = 1; required string foo = 1; optional bytes foo = 1; required bytes foo = 1; The compiler will generate the following accessor methods:\nbool has_foo() const: Returns true if the field is set. const string\u0026 foo() const: Returns the current value of the field. If the field is not set, returns the default value. void set_foo(const string\u0026 value): Sets the value of the field. After calling this, has_foo() will return true and foo() will return a copy of value. void set_foo(string\u0026\u0026 value) (C++11 and beyond): Sets the value of the field, moving from the passed string. After calling this, has_foo() will return true and foo() will return a copy of value. void set_foo(const char* value): Sets the value of the field using a C-style null-terminated string. After calling this, has_foo() will return true and foo() will return a copy of value. void set_foo(const char* value, int size): Like above, but the string size is given explicitly rather than determined by looking for a null-terminator byte. string* mutable_foo(): Returns a pointer to the mutable string object that stores the field’s value. If the field was not set prior to the call, then the returned string will be empty (not the default value). After calling this, has_foo() will return true and foo() will return whatever value is written into the given string. void clear_foo(): Clears the value of the field. After calling this, has_foo() will return false and foo() will return the default value. void set_allocated_foo(string* value): Sets the string object to the field and frees the previous field value if it exists. If the string pointer is not NULL, the message takes ownership of the allocated string object and has_foo() will return true. The message is free to delete the allocated string object at any time, so references to the object may be invalidated. Otherwise, if the value is NULL, the behavior is the same as calling clear_foo(). string* release_foo(): Releases the ownership of the field and returns the pointer of the string object. After calling this, caller takes the ownership of the allocated string object, has_foo() will return false, and foo() will return the default value. Singular String Fields (proto3) For any of these field definitions:\nstring foo = 1; bytes foo = 1; The compiler will generate the following accessor methods:\nconst string\u0026 foo() const: Returns the current value of the field. If the field is not set, returns the empty string/empty bytes. void set_foo(const string\u0026 value): Sets the value of the field. After calling this, foo() will return a copy of value. void set_foo(string\u0026\u0026 value) (C++11 and beyond): Sets the value of the field, moving from the passed string. After calling this, foo() will return a copy of value. void set_foo(const char* value): Sets the value of the field using a C-style null-terminated string. After calling this, foo() will return a copy of value. void set_foo(const char* value, int size): Like above, but the string size is given explicitly rather than determined by looking for a null-terminator byte. string* mutable_foo(): Returns a pointer to the mutable string object that stores the field’s value. If the field was not set prior to the call, then the returned string will be empty. After calling this, foo() will return whatever value is written into the given string. void clear_foo(): Clears the value of the field. After calling this, foo() will return the empty string/empty bytes. void set_allocated_foo(string* value): Sets the string object to the field and frees the previous field value if it exists. If the string pointer is not NULL, the message takes ownership of the allocated string object. The message is free to delete the allocated string object at any time, so references to the object may be invalidated. Otherwise, if the value is NULL, the behavior is the same as calling clear_foo(). string* release_foo(): Releases the ownership of the field and returns the pointer of the string object. After calling this, caller takes the ownership of the allocated string object and foo() will return the empty string/empty bytes. Singular Enum Fields (proto2) Given the enum type:\nenum Bar { BAR_VALUE = 0; OTHER_VALUE = 1; } For either of these field definitions:\noptional Bar foo = 1; required Bar foo = 1; The compiler will generate the following accessor methods:\nbool has_foo() const: Returns true if the field is set. Bar foo() const: Returns the current value of the field. If the field is not set, returns the default value. void set_foo(Bar value): Sets the value of the field. After calling this, has_foo() will return true and foo() will return value. In debug mode (i.e. NDEBUG is not defined), if value does not match any of the values defined for Bar, this method will abort the process. void clear_foo(): Clears the value of the field. After calling this, has_foo() will return false and foo() will return the default value. Singular Enum Fields (proto3) Given the enum type:\nenum Bar { BAR_VALUE = 0; OTHER_VALUE = 1; } For this field definitions:\nBar foo = 1; The compiler will generate the following accessor methods:\nBar foo() const: Returns the current value of the field. If the field is not set, returns the default value (0). void set_foo(Bar value): Sets the value of the field. After calling this, foo() will return value. void clear_foo(): Clears the value of the field. After calling this, foo() will return the default value. Singular Embedded Message Fields Given the message type:\nmessage Bar {} For any of these field definitions:\n//proto2 optional Bar foo = 1; required Bar foo = 1; //proto3 Bar foo = 1; The compiler will generate the following accessor methods:\nbool has_foo() const: Returns true if the field is set. const Bar\u0026 foo() const: Returns the current value of the field. If the field is not set, returns a Bar with none of its fields set (possibly Bar::default_instance()). Bar* mutable_foo(): Returns a pointer to the mutable Bar object that stores the field’s value. If the field was not set prior to the call, then the returned Bar will have none of its fields set (i.e. it will be identical to a newly-allocated Bar). After calling this, has_foo() will return true and foo() will return a reference to the same instance of Bar. void clear_foo(): Clears the value of the field. After calling this, has_foo() will return false and foo() will return the default value. void set_allocated_foo(Bar* bar): Sets the Bar object to the field and frees the previous field value if it exists. If the Bar pointer is not NULL, the message takes ownership of the allocated Bar object and has_foo() will return true. Otherwise, if the Bar is NULL, the behavior is the same as calling clear_foo(). Bar* release_foo(): Releases the ownership of the field and returns the pointer of the Bar object. After calling this, caller takes the ownership of the allocated Bar object, has_foo() will return false, and foo() will return the default value. Repeated Numeric Fields For this field definition:\nrepeated int32 foo = 1; The compiler will generate the following accessor methods:\nint foo_size() const: Returns the number of elements currently in the field. int32 foo(int index) const: Returns the element at the given zero-based index. Calling this method with index outside of [0, foo_size()) yields undefined behavior. void set_foo(int index, int32 value): Sets the value of the element at the given zero-based index. void add_foo(int32 value): Appends a new element to the end of the field with the given value. void clear_foo(): Removes all elements from the field. After calling this, foo_size() will return zero. const RepeatedField\u003cint32\u003e\u0026 foo() const: Returns the underlying RepeatedField that stores the field’s elements. This container class provides STL-like iterators and other methods. RepeatedField\u003cint32\u003e* mutable_foo(): Returns a pointer to the underlying mutable RepeatedField that stores the field’s elements. This container class provides STL-like iterators and other methods. For other numeric field types (including bool), int32 is replaced with the corresponding C++ type according to the scalar value types table.\nRepeated String Fields For either of these field definitions:\nrepeated string foo = 1; repeated bytes foo = 1; The compiler will generate the following accessor methods:\nint foo_size() const: Returns the number of elements currently in the field. const string\u0026 foo(int index) const: Returns the element at the given zero-based index. Calling this method with index outside of [0, foo_size()-1] yields undefined behavior. void set_foo(int index, const string\u0026 value): Sets the value of the element at the given zero-based index. void set_foo(int index, const char* value): Sets the value of the element at the given zero-based index using a C-style null-terminated string. void set_foo(int index, const char* value, int size): Like above, but the string size is given explicitly rather than determined by looking for a null-terminator byte. string* mutable_foo(int index): Returns a pointer to the mutable string object that stores the value of the element at the given zero-based index. Calling this method with index outside of [0, foo_size()) yields undefined behavior. void add_foo(const string\u0026 value): Appends a new element to the end of the field with the given value. void add_foo(const char* value): Appends a new element to the end of the field using a C-style null-terminated string. void add_foo(const char* value, int size): Like above, but the string size is given explicitly rather than determined by looking for a null-terminator byte. string* add_foo(): Adds a new empty string element to the end of the field and returns a pointer to it. void clear_foo(): Removes all elements from the field. After calling this, foo_size() will return zero. const RepeatedPtrField\u003cstring\u003e\u0026 foo() const: Returns the underlying RepeatedPtrField that stores the field’s elements. This container class provides STL-like iterators and other methods. RepeatedPtrField\u003cstring\u003e* mutable_foo(): Returns a pointer to the underlying mutable RepeatedPtrField that stores the field’s elements. This container class provides STL-like iterators and other methods. Repeated Enum Fields Given the enum type:\nenum Bar { BAR_VALUE = 0; OTHER_VALUE = 1; } For this field definition:\nrepeated Bar foo = 1; The compiler will generate the following accessor methods:\nint foo_size() const: Returns the number of elements currently in the field. Bar foo(int index) const: Returns the element at the given zero-based index. Calling this method with index outside of [0, foo_size()) yields undefined behavior. void set_foo(int index, Bar value): Sets the value of the element at the given zero-based index. In debug mode (i.e. NDEBUG is not defined), if value does not match any of the values defined for Bar, this method will abort the process. void add_foo(Bar value): Appends a new element to the end of the field with the given value. In debug mode (i.e. NDEBUG is not defined), if value does not match any of the values defined for Bar, this method will abort the process. void clear_foo(): Removes all elements from the field. After calling this, foo_size() will return zero. const RepeatedField\u003cint\u003e\u0026 foo() const: Returns the underlying RepeatedField that stores the field’s elements. This container class provides STL-like iterators and other methods. RepeatedField\u003cint\u003e* mutable_foo(): Returns a pointer to the underlying mutable RepeatedField that stores the field’s elements. This container class provides STL-like iterators and other methods. Repeated Embedded Message Fields Given the message type:\nmessage Bar {} For this field definitions:\nrepeated Bar foo = 1; The compiler will generate the following accessor methods:\nint foo_size() const: Returns the number of elements currently in the field. const Bar\u0026 foo(int index) const: Returns the element at the given zero-based index. Calling this method with index outside of [0, foo_size()) yields undefined behavior. Bar* mutable_foo(int index): Returns a pointer to the mutable Bar object that stores the value of the element at the given zero-based index. Calling this method with index outside of [0, foo_size()) yields undefined behavior. Bar* add_foo(): Adds a new element to the end of the field and returns a pointer to it. The returned Bar is mutable and will have none of its fields set (i.e. it will be identical to a newly-allocated Bar). void clear_foo(): Removes all elements from the field. After calling this, foo_size() will return zero. const RepeatedPtrField\u003cBar\u003e\u0026 foo() const: Returns the underlying RepeatedPtrField that stores the field’s elements. This container class provides STL-like iterators and other methods. RepeatedPtrField\u003cBar\u003e* mutable_foo(): Returns a pointer to the underlying mutable RepeatedPtrField that stores the field’s elements. This container class provides STL-like iterators and other methods. Oneof Numeric Fields For this oneof field definition:\noneof example_name { int32 foo = 1; ... } The compiler will generate the following accessor methods:\nbool has_foo() const (proto2 only): Returns true if oneof case is kFoo. int32 foo() const: Returns the current value of the field if oneof case is kFoo. Otherwise, returns the default value. void set_foo(int32 value): If any other oneof field in the same oneof is set, calls clear_example_name(). Sets the value of this field and sets the oneof case to kFoo. has_foo() (proto2 only) will return true, foo() will return value, and example_name_case() will return kFoo. void clear_foo(): Nothing will be changed if oneof case is not kFoo. If oneof case is kFoo, clears the value of the field and oneof case. has_foo() (proto2 only) will return false, foo() will return the default value and example_name_case() will return EXAMPLE_NAME_NOT_SET. For other numeric field types (including bool),int32 is replaced with the corresponding C++ type according to the scalar value types table.\nOneof String Fields For any of these oneof field definitions:\noneof example_name { string foo = 1; … } oneof example_name { bytes foo = 1; …. } The compiler will generate the following accessor methods:\nbool has_foo() const: Returns true if the oneof case is kFoo. const string\u0026 foo() const: Returns the current value of the field if the oneof case is kFoo. Otherwise, returns the default value. void set_foo(const string\u0026 value): If any other oneof field in the same oneof is set, calls clear_example_name(). Sets the value of this field and sets the oneof case to kFoo. has_foo() will return true, foo() will return a copy of value and example_name_case() will return kFoo. void set_foo(const char* value): If any other oneof field in the same oneof is set, calls clear_example_name(). Sets the value of the field using a C-style null-terminated string and set the oneof case to kFoo. has_foo() will return true, foo() will return a copy of value and example_name_case() will return kFoo. void set_foo(const char* value, int size): Like above, but the string size is given explicitly rather than determined by looking for a null-terminator byte. string* mutable_foo(): If any other oneof field in the same oneof is set, calls clear_example_name(). Sets the oneof case to kFoo and returns a pointer to the mutable string object that stores the field’s value. If the oneof case was not kFoo prior to the call, then the returned string will be empty (not the default value). has_foo() will return true, foo() will return whatever value is written into the given string and example_name_case() will return kFoo. void clear_foo(): If the oneof case is not kFoo, nothing will be changed . If the oneof case is kFoo, frees the field and clears the oneof case . has_foo() will return false, foo() will return the default value, and example_name_case() will return EXAMPLE_NAME_NOT_SET. void set_allocated_foo(string* value): Calls clear_example_name(). If the string pointer is not NULL: Sets the string object to the field and sets the oneof case to kFoo. The message takes ownership of the allocated string object, has_foo() will return true and example_name_case() will return kFoo. If the string pointer is NULL, has_foo() will return false and example_name_case() will return EXAMPLE_NAME_NOT_SET. string* release_foo(): Returns NULL if oneof case is not kFoo. Clears the oneof case, releases the ownership of the field and returns the pointer of the string object. After calling this, caller takes the ownership of the allocated string object, has_foo() will return false, foo() will return the default value, and example_name_case() will return EXAMPLE_NAME_NOT_SET. Oneof Enum Fields Given the enum type:\nenum Bar { BAR_VALUE = 0; OTHER_VALUE = 1; } For the oneof field definition:\noneof example_name { Bar foo = 1; ... } The compiler will generate the following accessor methods:\nbool has_foo() const (proto2 only): Returns true if oneof case is kFoo. Bar foo() const: Returns the current value of the field if oneof case is kFoo. Otherwise, returns the default value. void set_foo(Bar value): If any other oneof field in the same oneof is set, calls clear_example_name(). Sets the value of this field and sets the oneof case to kFoo. has_foo() (proto2 only) will return true, foo() will return value and example_name_case() will return kFoo. In debug mode (i.e. NDEBUG is not defined), if value does not match any of the values defined for Bar, this method will abort the process. void clear_foo(): Nothing will be changed if the oneof case is not kFoo. If the oneof case is kFoo, clears the value of the field and the oneof case. has_foo() (proto2 only) will return false, foo() will return the default value and example_name_case() will return EXAMPLE_NAME_NOT_SET. Oneof Embedded Message Fields Given the message type:\nmessage Bar {} For the oneof field definition:\noneof example_name { Bar foo = 1; ... } The compiler will generate the following accessor methods:\nbool has_foo() const: Returns true if oneof case is kFoo. const Bar\u0026 foo() const: Returns the current value of the field if oneof case is kFoo. Otherwise, returns Bar::default_instance(). Bar* mutable_foo(): If any other oneof field in the same oneof is set, calls clear_example_name(). Sets the oneof case to kFoo and returns a pointer to the mutable Bar object that stores the field’s value. If the oneof case was not kFoo prior to the call, then the returned Bar will have none of its fields set (i.e. it will be identical to a newly-allocated Bar). After calling this, has_foo() will return true, foo() will return a reference to the same instance of Bar and example_name_case() will return kFoo. void clear_foo(): Nothing will be changed if the oneof case is not kFoo. If the oneof case equals kFoo, frees the field and clears the oneof case. has_foo() will return false, foo() will return the default value and example_name_case() will return EXAMPLE_NAME_NOT_SET. void set_allocated_foo(Bar* bar): Calls clear_example_name(). If the Bar pointer is not NULL: Sets the Bar object to the field and sets the oneof case to kFoo. The message takes ownership of the allocated Bar object, has_foo() will return true and example_name_case() will return kFoo. If the pointer is NULL, has_foo() will return false and example_name_case() will return EXAMPLE_NAME_NOT_SET. (The behavior is like calling clear_example_name()) Bar* release_foo(): Returns NULL if oneof case is not kFoo. If the oneof case is kFoo, clears the oneof case, releases the ownership of the field and returns the pointer of the Bar object. After calling this, caller takes the ownership of the allocated Bar object, has_foo() will return false, foo() will return the default value and example_name_case() will return EXAMPLE_NAME_NOT_SET. Map Fields For this map field definition:\nmap\u003cint32, int32\u003e weight = 1; The compiler will generate the following accessor methods:\nconst google::protobuf::Map\u003cint32, int32\u003e\u0026 weight();: Returns an immutable Map. google::protobuf::Map\u003cint32, int32\u003e* mutable_weight();: Returns a mutable Map. A google::protobuf::Map is a special container type used in protocol buffers to store map fields. As you can see from its interface below, it uses a commonly-used subset of std::map and std::unordered_map methods.\ntemplate\u003ctypename Key, typename T\u003e { class Map { // Member types typedef Key key_type; typedef T mapped_type; typedef MapPair\u003c Key, T \u003e value_type; // Iterators iterator begin(); const_iterator begin() const; const_iterator cbegin() const; iterator end(); const_iterator end() const; const_iterator cend() const; // Capacity int size() const; bool empty() const; // Element access T\u0026 operator[](const Key\u0026 key); const T\u0026 at(const Key\u0026 key) const; T\u0026 at(const Key\u0026 key); // Lookup int count(const Key\u0026 key) const; const_iterator find(const Key\u0026 key) const; iterator find(const Key\u0026 key); // Modifiers pair\u003citerator, bool\u003e insert(const value_type\u0026 value); template\u003cclass InputIt\u003e void insert(InputIt first, InputIt last); size_type erase(const Key\u0026 Key); iterator erase(const_iterator pos); iterator erase(const_iterator first, const_iterator last); void clear(); // Copy Map(const Map\u0026 other); Map\u0026 operator=(const Map\u0026 other); } The easiest way to add data is to use normal map syntax, for example:\nstd::unique_ptr\u003cProtoName\u003e my_enclosing_proto(new ProtoName); (*my_enclosing_proto-\u003emutable_weight())[my_key] = my_value; pair\u003citerator, bool\u003e insert(const value_type\u0026 value) will implicitly cause a deep copy of the value_type instance. The most efficient way to insert a new value into a google::protobuf::Map is as follows:\nT\u0026 operator[](const Key\u0026 key): map[new_key] = new_mapped; Using google::protobuf::Map with standard maps google::protobuf::Map supports the same iterator API as std::map and std::unordered_map. If you don’t want to use google::protobuf::Map directly, you can convert a google::protobuf::Map to a standard map by doing the following:\nstd::map\u003cint32, int32\u003e standard_map(message.weight().begin(), message.weight().end()); Note that this will make a deep copy of the entire map.\nYou can also construct a google::protobuf::Map from a standard map as follows:\ngoogle::protobuf::Map\u003cint32, int32\u003e weight(standard_map.begin(), standard_map.end()); Parsing unknown values On the wire, a .proto map is equivalent to a map entry message for each key/value pair, while the map itself is a repeated field of map entries. Like ordinary message types, it’s possible for a parsed map entry message to have unknown fields: for example a field of type int64 in a map defined as map\u003cint32, string\u003e.\nIf there are unknown fields in the wire format of a map entry message, they will be discarded.\nIf there is an unknown enum value in the wire format of a map entry message, it’s handled differently in proto2 and proto3. In proto2, the whole map entry message is put into the unknown field set of the containing message. In proto3, it is put into a map field as if it is a known enum value.\nAny Given an Any field like this:\nimport \"google/protobuf/any.proto\"; message ErrorStatus { string message = 1; google.protobuf.Any details = 2; } In our generated code, the getter for the details field returns an instance of google::protobuf::Any. This provides the following special methods to pack and unpack the Any’s values:\nclass Any { public: // Packs the given message into this Any using the default type URL // prefix “type.googleapis.com”. Returns false if serializing the message failed. bool PackFrom(const google::protobuf::Message\u0026 message); // Packs the given message into this Any using the given type URL // prefix. Returns false if serializing the message failed. bool PackFrom(const google::protobuf::Message\u0026 message, const string\u0026 type_url_prefix); // Unpacks this Any to a Message. Returns false if this Any // represents a different protobuf type or parsing fails. bool UnpackTo(google::protobuf::Message* message) const; // Returns true if this Any represents the given protobuf type. template\u003ctypename T\u003e bool Is() const; } Oneof Given a oneof definition like this:\noneof example_name { int32 foo_int = 4; string foo_string = 9; ... } The compiler will generate the following C++ enum type:\nenum ExampleNameCase { kFooInt = 4, kFooString = 9, EXAMPLE_NAME_NOT_SET = 0 } In addition, it will generate these methods:\nExampleNameCase example_name_case() const: Returns the enum indicating which field is set. Returns EXAMPLE_NAME_NOT_SET if none of them is set. void clear_example_name(): Frees the object if the oneof field set uses a pointer (Message or String), and sets the oneof case to EXAMPLE_NAME_NOT_SET. Enumerations Given an enum definition like:\nenum Foo { VALUE_A = 0; VALUE_B = 5; VALUE_C = 1234; } The protocol buffer compiler will generate a C++ enum type called Foo with the same set of values. In addition, the compiler will generate the following functions:\nconst EnumDescriptor* Foo_descriptor(): Returns the type’s descriptor, which contains information about what values this enum type defines. bool Foo_IsValid(int value): Returns true if the given numeric value matches one of Foo’s defined values. In the above example, it would return true if the input were 0, 5, or 1234. const string\u0026 Foo_Name(int value): Returns the name for given numeric value. Returns an empty string if no such value exists. If multiple values have this number, the first one defined is returned. In the above example, Foo_Name(5) would return \"VALUE_B\". bool Foo_Parse(const string\u0026 name, Foo* value): If name is a valid value name for this enum, assigns that value into value and returns true. Otherwise returns false. In the above example, Foo_Parse(\"VALUE_C\", \u0026some_foo) would return true and set some_foo to 1234. const Foo Foo_MIN: the smallest valid value of the enum (VALUE_A in the example). const Foo Foo_MAX: the largest valid value of the enum (VALUE_C in the example). const int Foo_ARRAYSIZE: always defined as Foo_MAX + 1. Be careful when casting integers to proto2 enums. If an integer is cast to a proto2 enum value, the integer must be one of the valid values for that enum, or the results may be undefined. If in doubt, use the generated Foo_IsValid() function to test if the cast is valid. Setting an enum-typed field of a proto2 message to an invalid value may cause an assertion failure. If an invalid enum value is read when parsing a proto2 message, it will be treated as an unknown field. These semantics have been changed in proto3. It’s safe to cast any integer to a proto3 enum value as long as it fits into int32. Invalid enum values will also be kept when parsing a proto3 message and returned by enum field accessors.\nBe careful when using proto3 enums in switch statements. Proto3 enums are open enum types with possible values outside the range of specified symbols. Unrecognized enum values will be kept when parsing a proto3 message and returned by the enum field accessors. A switch statement on a proto3 enum without a default case will not be able to catch all cases even if all the known fields are listed. This could lead to unexpected behavior including data corruption and runtime crashes. Always add a default case or explicitly call Foo_IsValid(int) outside of the switch to handle unknown enum values.\nYou can define an enum inside a message type. In this case, the protocol buffer compiler generates code that makes it appear that the enum type itself was declared nested inside the message’s class. The Foo_descriptor() and Foo_IsValid() functions are declared as static methods. In reality, the enum type itself and its values are declared at the global scope with mangled names, and are imported into the class’s scope with a typedef and a series of constant definitions. This is done only to get around problems with declaration ordering. Do not depend on the mangled top-level names; pretend the enum really is nested in the message class.\nExtensions (proto2 only) Given a message with an extension range:\nmessage Foo { extensions 100 to 199; } The protocol buffer compiler will generate some additional methods for Foo: HasExtension(), ExtensionSize(), ClearExtension(), GetExtension(), SetExtension(), MutableExtension(), AddExtension(), SetAllocatedExtension() and ReleaseExtension(). Each of these methods takes, as its first parameter, an extension identifier (described below), which identifies an extension field. The remaining parameters and the return value are exactly the same as those for the corresponding accessor methods that would be generated for a normal (non-extension) field of the same type as the extension identifier. (GetExtension() corresponds to the accessors with no special prefix.)\nGiven an extension definition:\nextend Foo { optional int32 bar = 123; repeated int32 repeated_bar = 124; } For the singular extension field bar, the protocol buffer compiler generates an “extension identifier” called bar, which you can use with Foo’s extension accessors to access this extension, like so:\nFoo foo; assert(!foo.HasExtension(bar)); foo.SetExtension(bar, 1); assert(foo.HasExtension(bar)); assert(foo.GetExtension(bar) == 1); foo.ClearExtension(bar); assert(!foo.HasExtension(bar)); Similarly, for the repeated extension field repeated_bar, the compiler generates an extension identifier called repeated_bar, which you can also use with Foo’s extension accessors:\nFoo foo; for (int i = 0; i \u003c kSize; ++i) { foo.AddExtension(repeated_bar, i) } assert(foo.ExtensionSize(repeated_bar) == kSize) for (int i = 0; i \u003c kSize; ++i) { assert(foo.GetExtension(repeated_bar, i) == i) } (The exact implementation of extension identifiers is complicated and involves magical use of templates—however, you don’t need to worry about how extension identifiers work to use them.)\nExtensions can be declared nested inside of another type. For example, a common pattern is to do something like this:\nmessage Baz { extend Foo { optional Baz foo_ext = 124; } } In this case, the extension identifier foo_ext is declared nested inside Baz. It can be used as follows:\nFoo foo; Baz* baz = foo.MutableExtension(Baz::foo_ext); FillInMyBaz(baz); Arena Allocation Arena allocation is a C++-only feature that helps you optimize your memory usage and improve performance when working with protocol buffers. Enabling arena allocation in your .proto adds additional code for working with arenas to your C++ generated code. You can find out more about the arena allocation API in the Arena Allocation Guide.\nServices If the .proto file contains the following line:\noption cc_generic_services = true; then the protocol buffer compiler will generate code based on the service definitions found in the file as described in this section. However, the generated code may be undesirable as it is not tied to any particular RPC system, and thus requires more levels of indirection than code tailored to one system. If you do NOT want this code to be generated, add this line to the file:\noption cc_generic_services = false; If neither of the above lines are given, the option defaults to false, as generic services are deprecated. (Note that prior to 2.4.0, the option defaults to true)\nRPC systems based on .proto-language service definitions should provide plugins to generate code appropriate for the system. These plugins are likely to require that abstract services are disabled, so that they can generate their own classes of the same names.\nThe remainder of this section describes what the protocol buffer compiler generates when abstract services are enabled.\nInterface Given a service definition:\nservice Foo { rpc Bar(FooRequest) returns(FooResponse); } The protocol buffer compiler will generate a class Foo to represent this service. Foo will have a virtual method for each method defined in the service definition. In this case, the method Bar is defined as:\nvirtual void Bar(RpcController* controller, const FooRequest* request, FooResponse* response, Closure* done); The parameters are equivalent to the parameters of Service::CallMethod(), except that the method argument is implied and request and response specify their exact type.\nThese generated methods are virtual, but not pure-virtual. The default implementations simply call controller-\u003eSetFailed() with an error message indicating that the method is unimplemented, then invoke the done callback. When implementing your own service, you must subclass this generated service and implement its methods as appropriate.\nFoo subclasses the Service interface. The protocol buffer compiler automatically generates implementations of the methods of Service as follows:\nGetDescriptor: Returns the service’s ServiceDescriptor. CallMethod: Determines which method is being called based on the provided method descriptor and calls it directly, down-casting the request and response messages objects to the correct types. GetRequestPrototype and GetResponsePrototype: Returns the default instance of the request or response of the correct type for the given method. The following static method is also generated:\nstatic ServiceDescriptor descriptor(): Returns the type’s descriptor, which contains information about what methods this service has and what their input and output types are. Stub The protocol buffer compiler also generates a “stub” implementation of every service interface, which is used by clients wishing to send requests to servers implementing the service. For the Foo service (above), the stub implementation Foo_Stub will be defined. As with nested message types, a typedef is used so that Foo_Stub can also be referred to as Foo::Stub.\nFoo_Stub is a subclass of Foo which also implements the following methods:\nFoo_Stub(RpcChannel* channel): Constructs a new stub which sends requests on the given channel. Foo_Stub(RpcChannel* channel, ChannelOwnership ownership): Constructs a new stub which sends requests on the given channel and possibly owns that channel. If ownership is Service::STUB_OWNS_CHANNEL then when the stub object is deleted it will delete the channel as well. RpcChannel* channel(): Returns this stub’s channel, as passed to the constructor. The stub additionally implements each of the service’s methods as a wrapper around the channel. Calling one of the methods simply calls channel-\u003eCallMethod().\nThe Protocol Buffer library does not include an RPC implementation. However, it includes all of the tools you need to hook up a generated service class to any arbitrary RPC implementation of your choice. You need only provide implementations of RpcChannel and RpcController. See the documentation for service.h for more information.\nPlugin Insertion Points Code generator plugins which want to extend the output of the C++ code generator may insert code of the following types using the given insertion point names. Each insertion point appears in both the .pb.cc file and the .pb.h file unless otherwise noted.\nincludes: Include directives. namespace_scope: Declarations that belong in the file’s package/namespace, but not within any particular class. Appears after all other namespace-scope code. global_scope: Declarations that belong at the top level, outside of the file’s namespace. Appears at the very end of the file. class_scope:TYPENAME: Member declarations that belong in a message class. TYPENAME is the full proto name, e.g. package.MessageType. Appears after all other public declarations in the class. This insertion point appears only in the .pb.h file. Do not generate code which relies on private class members declared by the standard code generator, as these implementation details may change in future versions of Protocol Buffers.\n","categories":"","description":"This topic describes exactly what C++ code the protocol buffer compiler generates for any given protocol definition. ","excerpt":"This topic describes exactly what C++ code the protocol buffer …","ref":"/reference/cpp/cpp-generated/","tags":"","title":"C++ Generated Code Guide"},{"body":"Arena allocation is a C++-only feature that helps you optimize your memory usage and improve performance when working with protocol buffers. This page describes exactly what C++ code the protocol buffer compiler generates in addition to the code described in the C++ Generated Code Guide when arena allocation is enabled. It assumes that you are familiar with the material in the language guide and the C++ Generated Code Guide.\nWhy Use Arena Allocation? Memory allocation and deallocation constitutes a significant fraction of CPU time spent in protocol buffers code. By default, protocol buffers performs heap allocations for each message object, each of its subobjects, and several field types, such as strings. These allocations occur in bulk when parsing a message and when building new messages in memory, and associated deallocations happen when messages and their subobject trees are freed.\nArena-based allocation has been designed to reduce this performance cost. With arena allocation, new objects are allocated out of a large piece of preallocated memory called the arena. Objects can all be freed at once by discarding the entire arena, ideally without running destructors of any contained object (though an arena can still maintain a “destructor list” when required). This makes object allocation faster by reducing it to a simple pointer increment, and makes deallocation almost free. Arena allocation also provides greater cache efficiency: when messages are parsed, they are more likely to be allocated in continuous memory, which makes traversing messages more likely to hit hot cache lines.\nTo get these benefits you’ll need to be aware of object lifetimes and find a suitable granularity at which to use arenas (for servers, this is often per-request). You can find out more about how to get the most from arena allocation in Usage patterns and best practices.\nThis table summarizes the typical performance advantages and disadvantages of using arenas:\nOperation Heap-allocated proto messages Arena-allocated proto messages Message allocation Slower on average Faster on average Message destruction Slower on average Faster on average Message moves Always a move (equivalent to a shallow copy in cost) Sometimes a deep copy Getting Started The protocol buffer compiler generates code for arena allocation for the messages in your file, as used in the following example.\n#include \u003cgoogle/protobuf/arena.h\u003e { google::protobuf::Arena arena; MyMessage* message = google::protobuf::Arena::CreateMessage\u003cMyMessage\u003e(\u0026arena); // ... } The message object created by CreateMessage() exists for as long as arena exists, and you should not delete the returned message pointer. All of the message object’s internal storage (with a few exceptions1) and submessages (for example, submessages in a repeated field within MyMessage) are allocated on the arena as well.\nFor the most part, the rest of your code will be the same as if you weren’t using arena allocation.\nWe’ll look at the arena API in more detail in the following sections, and you can see a more extensive example at the end of the document.\nArena Class API You create message objects on the arena using the google::protobuf::Arena class. This class implements the following public methods.\nConstructors Arena(): Creates a new arena with default parameters, tuned for average use cases. Arena(const ArenaOptions\u0026 options): Creates a new arena that uses the specified allocation options. The options available in ArenaOptions include the ability to use an initial block of user-provided memory for allocations before resorting to the system allocator, control over the initial and maximum request sizes for blocks of memory, and allowing you to pass in custom block allocation and deallocation function pointers to build freelists and others on top of the blocks. Allocation Methods template\u003ctypename T\u003e static T* CreateMessage(Arena* arena): Creates a new protocol buffer object of message type T on the arena.\nIf arena is not NULL, the returned message object is allocated on the arena, its internal storage and submessages (if any) will be allocated on the same arena, and its lifetime is the same as that of the arena. The object must not be deleted/freed manually: the arena owns the message object for lifetime purposes.\nIf arena is NULL, the returned message object is allocated on the heap, and the caller owns the object upon return.\ntemplate\u003ctypename T\u003e static T* Create(Arena* arena, args...): Similar to CreateMessage() but lets you create an object of any class on the arena, not just protocol buffer message types. For example, let’s say you have this C++ class:\nclass MyCustomClass { MyCustomClass(int arg1, int arg2); // ... }; …you can create an instance of it on the arena like this:\nvoid func() { // ... google::protobuf::Arena arena; MyCustomClass* c = google::protobuf::Arena::Create\u003cMyCustomClass\u003e(\u0026arena, constructor_arg1, constructor_arg2); // ... } template\u003ctypename T\u003e static T* CreateArray(Arena* arena, size_t n): If arena is not NULL, this method allocates raw storage for n elements of type T and returns it. The arena owns the returned memory and will free it on its own destruction. If arena is NULL, this method allocates storage on the heap and the caller receives ownership.\nT must have a trivial constructor: constructors are not called when the array is created on the arena.\n“Owned list” Methods The following methods let you specify that particular objects or destructors are “owned” by the arena, ensuring that they are deleted or called when the arena itself is deleted\ntemplate\u003ctypename T\u003e void Own(T* object): Adds object to the arena’s list of owned heap objects. When the arena is destroyed, it traverses this list and frees each object using operator delete, i.e., the system memory allocator. This method is useful in cases when an object’s lifetime should be tied to the arena but, for whatever reason, the object itself cannot be or was not already allocated on the arena. template\u003ctypename T\u003e void OwnDestructor(T* object): Adds the destructor of object to the arena’s list of destructors to call. When the arena is destroyed, it traverses this list and calls each destructor in turn. It does not attempt to free the underlying memory of object. This method is useful when an object is embedded in arena-allocated storage but its destructor will not otherwise be called, for example because its containing class is a protobuf message whose destructor won’t be called, or because it was manually constructed in a block allocated by AllocateArray(). Other Methods uint64 SpaceUsed() const: Returns the total size of the arena, which is the sum of the sizes of the underlying blocks. This method is thread-safe; however, if there are concurrent allocations from multiple threads this method’s return value may not include the sizes of those new blocks. uint64 Reset(): Destroys the arena’s storage, first calling all registered destructors and freeing all registered heap objects and then discarding all arena blocks. This teardown procedure is equivalent to that which occurs when the arena’s destructor runs, except the arena is reusable for new allocations after this method returns. Returns the total size used by the arena: this information is useful for tuning performance. template\u003ctypename T\u003e Arena* GetArena(): Returns a pointer to this arena. Not directly very useful but allows Arena to be used in template instantiations that expect GetArena() methods to be present. Thread Safety google::protobuf::Arena’s allocation methods are thread-safe, and the underlying implementation goes to some length to make multithreaded allocation fast. The Reset() method is not thread-safe: the thread performing the arena reset must synchronize with all threads performing allocations or using objects allocated from that arena first.\nGenerated Message Class The following message class members are changed or added when you enable arena allocation.\nMessage Class Methods Message(Message\u0026\u0026 other): If the source message is not on arena, the move constructor efficiently moves all fields from one message to another without making copies or heap allocations (the time complexity of this operation is O(number-of-declared-fields)). However, if the source message is on arena, it performs a deep copy of the underlying data. In both cases the source message is left in a valid but unspecified state. Message\u0026 operator=(Message\u0026\u0026 other): If both messages are not on arena or are on the same arena, the move-assignment operator efficiently moves all fields from one message to another without making copies or heap allocations (the time complexity of this operation is O(number-of-declared-fields)). However, if only one message is on arena, or the messages are on different arenas, it performs a deep copy of the underlying data. In both cases the source message is left in a valid but unspecified state. void Swap(Message* other): If both messages to be swapped are not on arenas or are on the same arena, Swap() behaves as it does without having arena allocation enabled: it efficiently swaps the message objects’ contents, almost exclusively through cheap pointer swaps, avoiding copies. However, if only one message is on an arena, or the messages are on different arenas, Swap() performs deep copies of the underlying data. This new behavior is necessary because otherwise the swapped sub-objects could have differing lifetimes, leading potentially to use-after-free bugs. Message* New(Arena* arena): An alternate override for the standard New() method. It allows a new message object of this type to be created on the given arena. Its semantics are identical to Arena::CreateMessage\u003cT\u003e(arena) if the concrete message type on which it is called is generated with arena allocation enabled. If the message type is not generated with arena allocation enabled, then it is equivalent to an ordinary allocation followed by arena-\u003eOwn(message) if arena is not NULL. Arena* GetArena(): Returns the arena on which this message object was allocated, if any. void UnsafeArenaSwap(Message* other): Identical to Swap(), except it assumes both objects are on the same arena (or not on arenas at all) and always uses the efficient pointer-swapping implementation of this operation. Using this method can improve performance as, unlike Swap(), it doesn’t need to check which messages live on which arena before performing the swap. As the Unsafe prefix suggests, you should only use this method if you are sure the messages you want to swap aren’t on different arenas; otherwise this method could have unpredictable results. Embedded Message Fields When you allocate a message object on an arena, its embedded message field objects (submessages) are automatically owned by the arena as well. How these message objects are allocated depends on where they are defined:\nIf the message type is also defined in a .proto file with arena allocation enabled, the object is allocated on the arena directly. If the message type is from another .proto without arena allocation enabled, the object is heap-allocated but is “owned” by the parent message’s arena. This means that when the arena is destroyed, the object will be freed along with the objects on the arena itself. For either of these field definitions:\noptional Bar foo = 1; required Bar foo = 1; The following methods are added or have some special behavior when arena allocation is enabled. Otherwise, accessor methods just use the default behavior.\nBar* mutable_foo(): Returns a mutable pointer to the submessage instance. If the parent object is on an arena then the returned object will be as well. void set_allocated_foo(Bar* bar): Takes a new object and adopts it as the new value for the field. Arena support adds additional copying semantics to maintain proper ownership when objects cross arena/arena or arena/heap boundaries: If the parent object is on the heap and bar is on the heap, or if the parent and message are on the same arena, this method’s behavior is unchanged. If the parent is on an arena and bar is on the heap, the parent message adds bar to its arena’s ownership list with arena-\u003eOwn(). If the parent is on an arena and bar is on a different arena, this method makes a copy of message and takes the copy as the new field value. Bar* release_foo(): Returns the existing submessage instance of the field, if set, or a NULL pointer if not set, releasing ownership of this instance to the caller and clearing the parent message’s field. Arena support adds additional copying semantics to maintain the contract that the returned object is always heap-allocated: If the parent message is on an arena, this method will make a copy of the submessage on the heap, clear the field value, and return the copy. If the parent message is on the heap, the method behavior is unchanged. void unsafe_arena_set_allocated_foo(Bar* bar): Identical to set_allocated_foo, but assumes both parent and submessage are on the same arena. Using this version of the method can improve performance as it doesn’t need to check whether the messages are on a particular arena or the heap. See allocated/release patterns for details on safe ways to use this. Bar* unsafe_arena_release_foo(): Similar to release_foo(), but skips all ownership checking. See allocated/release patterns for details on safe ways to use this. String Fields Currently, string fields store their data on the heap even when their parent message is on the arena. Because of this, string accessor methods use the default behavior even when arena allocation is enabled.\nRepeated Fields Repeated fields allocate their internal array storage on the arena when the containing message is arena-allocated, and also allocate their elements on the arena when these elements are separate objects retained by pointer (messages or strings). At the message-class level, generated methods for repeated fields do not change. However, the RepeatedField and RepeatedPtrField objects that are returned by accessors do have new methods and modified semantics when arena support is enabled.\nRepeated Numeric Fields RepeatedField objects that contain primitive types have the following new/changed methods when arena allocation is enabled:\nvoid UnsafeArenaSwap(RepeatedField* other): Performs a swap of RepeatedField contents without validating that this repeated field and other are on the same arena. If they are not, the two repeated field objects must be on arenas with equivalent lifetimes. The case where one is on an arena and one is on the heap is checked and disallowed. void Swap(RepeatedField* other): Checks each repeated field object’s arena, and if one is on an arena while one is on the heap or if both are on arenas but on different ones, the underlying arrays are copied before the swap occurs. This means that after the swap, each repeated field object holds an array on its own arena or heap, as appropriate. Repeated Embedded Message Fields RepeatedPtrField objects that contain messages have the following new/changed methods when arena allocation is enabled.\nvoid UnsafeArenaSwap(RepeatedPtrField* other): Performs a swap of RepeatedPtrField contents without validating that this repeated field and other have the same arena pointer. If they do not, the two repeated field objects must have arena pointers with equivalent lifetimes. The case where one has a non-NULL arena pointer and one has a NULL arena pointer is checked and disallowed.\nvoid Swap(RepeatedPtrField* other): Checks each repeated field object’s arena pointer, and if one is non-NULL (contents on arena) while one is NULL (contents on heap) or if both are non-NULL but have different values, the underlying arrays and their pointed-to objects are copied before the swap occurs. This means that after the swap, each repeated field object holds an array on its own arena or on the heap, as appropriate.\nvoid AddAllocated(SubMessageType* value): Checks that the provided message object is on the same arena as the repeated field’s arena pointer.\nThe source and destination are both arena-allocated and on the same arena: the object pointer is added directly to the underlying array. The source and destination are both arena-allocated and on different arenas: a copy is made, the original is freed if it was heap-allocated, and the copy is placed on the array. The source is heap-allocated and the destination is arena-allocated: No copy is made. The source is arena-allocated and the destination is heap-allocated: A copy is made and placed on the array. Both source and destination are heap allocated: The object pointer is added directly to the underlying array. This maintains the invariant that all objects pointed to by a repeated field are in the same ownership domain (heap or specific arena) as indicated by the repeated field’s arena pointer.\nSubMessageType* ReleaseLast(): Returns a heap-allocated message equivalent to the last message in the repeated field, removing it from the repeated field. If the repeated field itself has a NULL arena pointer (and thus, all of its pointed-to messages are heap-allocated), then this method simply returns a pointer to the original object. Otherwise, if the repeated field has a non-NULL arena pointer, this method makes a copy that is heap-allocated and returns that copy. In both cases, the caller receives ownership of a heap-allocated object and is responsible for deleting the object.\nvoid UnsafeArenaAddAllocated(SubMessageType* value): Like AddAllocated(), but does not perform heap/arena checks or any message copies. It adds the provided pointer directly to the internal array of pointers for this repeated field. See allocated/release patterns for details on safe ways to use this.\nSubMessageType* UnsafeArenaReleaseLast(): Like ReleaseLast() but performs no copies, even if the repeated field has a non-NULL arena pointer. Instead, it directly returns the pointer to the object as it was in the repeated field. See allocated/release patterns for details on safe ways to use this.\nvoid ExtractSubrange(int start, int num, SubMessageType** elements): Removes num elements from the repeated field, starting from index start, and returns them in elements if it is not NULL. If the repeated field is on an arena, and elements are being returned, the elements are copied to the heap first. In both cases (arena or no arena), the caller owns the returned objects on the heap.\nvoid UnsafeArenaExtractSubrange(int start, int num, SubMessageType** elements): Removes num elements from the repeated field, starting from index start, and returns them in elements if it is not NULL. Unlike ExtractSubrange(), this method never copies the extracted elements. See allocated/release patterns for details on safe ways to use this.\nRepeated String Fields Repeated fields of strings have the same new methods and modified semantics as repeated fields of messages, because they also maintain their underlying objects (namely, strings) by pointer reference.\nUsage Patterns and Best Practices When using arena-allocated messages, several usage patterns can result in unintended copies or other negative performance effects. You should be aware of the following common patterns that may need to be altered when adapting code for arenas. (Note that we have taken care in the API design to ensure that correct behavior still occurs — but higher-performance solutions may require some reworking.)\nUnintended Copies Several methods that never create object copies when not using arena allocation may end up doing so when arena support is enabled. These unwanted copies can be avoided if you make sure that your objects are allocated appropriately and/or use provided arena-specific method versions, as described in more detail below.\nSet Allocated/Add Allocated/Release By default, the release_field() and set_allocated_field() methods (for singular message fields), and the ReleaseLast() and AddAllocated() methods (for repeated message fields) allow user code to directly attach and detach submessages, passing ownership of pointers without copying any data.\nHowever, when the parent message is on an arena, these methods now sometimes need to copy the passed in or returned object to maintain compatibility with existing ownership contracts. More specifically, methods that take ownership (set_allocated_field() and AddAllocated()) may copy data if the parent is on an arena and the new subobject is not, or vice versa, or they are on different arenas. Methods that release ownership (release_field() and ReleaseLast()) may copy data if the parent is on the arena, because the returned object must be on the heap, by contract.\nTo avoid such copies, we have added corresponding “unsafe arena” versions of these methods where copies are never performed: unsafe_arena_set_allocated_field(), unsafe_arena_release_field(), UnsafeArenaAddAllocated(), and UnsafeArenaRelease() for singular and repeated fields, respectively. These methods should be used only when you know they are safe to do so. There are two common patterns for these methods:\nMoving messages trees between parts of the same arena. Note that the messages must be on the same arena for this case to be safe. Temporarily loaning an owned message to a tree to avoid copies. Pairing an unsafe add/set method with an unsafe release method performs the loan in the cheapest way possible regardless of how either message is owned (this pattern works when they are on the same arena, different arena, or no arena at all). Note that between the unsafe add/set and its corresponding release, the borrower must not be swapped, moved, cleared or destroyed; the loaned message must not be swapped or moved; the loaned message must not be cleared or released by the borrower; and the loaned message must not be destroyed. Here’s an example of how you can avoid unnecessary copies with these methods. Let’s say you have created the following messages on an arena.\nArena* arena = new google::protobuf::Arena(); MyFeatureMessage* arena_message_1 = google::protobuf::Arena::CreateMessage\u003cMyFeatureMessage\u003e(arena); arena_message_1-\u003emutable_nested_message()-\u003eset_feature_id(11); MyFeatureMessage* arena_message_2 = google::protobuf::Arena::CreateMessage\u003cMyFeatureMessage\u003e(arena); The following code makes inefficient usage of the release_...() API:\narena_message_2-\u003eset_allocated_nested_message(arena_message_1-\u003erelease_nested_message()); arena_message_1-\u003erelease_message(); // returns a copy of the underlying nested_message and deletes underlying pointer Using the “unsafe arena” version instead avoids the copy:\narena_message_2-\u003eunsafe_arena_set_allocated_nested_message( arena_message_1-\u003eunsafe_arena_release_nested_message()); You can find out more about these methods in the Embedded message fields section above.\nSwap When two messages’ contents are swapped with Swap(), the underlying subobjects may be copied if the two messages live on different arenas, or if one is on the arena and the other is on the heap. If you want to avoid this copy and either (i) know that the two messages are on the same arena or different arenas but the arenas have equivalent lifetimes, or (ii) know that the two messages are on the heap, you can use a new method, UnsafeArenaSwap(). This method both avoids the overhead of performing the arena check and avoids the copy if one would have occurred.\nFor example, the following code incurs a copy in the Swap() call:\nMyFeatureMessage* message_1 = google::protobuf::Arena::CreateMessage\u003cMyFeatureMessage\u003e(arena); message_1-\u003emutable_nested_message()-\u003eset_feature_id(11); MyFeatureMessage* message_2 = new MyFeatureMessage; message_2-\u003emutable_nested_message()-\u003eset_feature_id(22); message_1-\u003eSwap(message_2); // Inefficient swap! To avoid the copy in this code, you allocate message_2 on the same arena as message_1:\nMyFeatureMessage* message_2 = google::protobuf::Arena::CreateMessage\u003cMyFeatureMessage\u003e(arena); Granularity We have found in most application server use cases that an “arena-per-request” model works well. You may be tempted to divide arena use further, either to reduce heap overhead (by destroying smaller arenas more often) or to reduce perceived thread-contention issues. However, the use of more fine-grained arenas may lead to unintended message copying, as we describe above. We have also spent effort to optimize the Arena implementation for the multithreaded use-case, so a single arena should be appropriate for use throughout a request lifetime even if multiple threads process that request.\nExample Here’s a simple complete example demonstrating some of the features of the arena allocation API.\n// my_feature.proto syntax = \"proto2\"; import \"nested_message.proto\"; package feature_package; // NEXT Tag to use: 4 message MyFeatureMessage { optional string feature_name = 1; repeated int32 feature_data = 2; optional NestedMessage nested_message = 3; }; // nested_message.proto syntax = \"proto2\"; package feature_package; // NEXT Tag to use: 2 message NestedMessage { optional int32 feature_id = 1; }; Message construction and deallocation:\n#include \u003cgoogle/protobuf/arena.h\u003e Arena arena; MyFeatureMessage* arena_message = google::protobuf::Arena::CreateMessage\u003cMyFeatureMessage\u003e(\u0026arena); arena_message-\u003eset_feature_name(\"Proto2 Arena\"); arena_message-\u003emutable_feature_data()-\u003eAdd(2); arena_message-\u003emutable_feature_data()-\u003eAdd(4); arena_message-\u003emutable_nested_message()-\u003eset_feature_id(247); Currently, string fields store their data on the heap even when the containing message is on the arena. Unknown fields are also heap-allocated. ↩︎\n","categories":"","description":"Arena allocation is a C++-only feature that helps you optimize your memory usage and improve performance when working with protocol buffers.","excerpt":"Arena allocation is a C++-only feature that helps you optimize your …","ref":"/reference/cpp/arenas/","tags":"","title":"C++ Arena Allocation Guide"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/cpp/api-docs-link/","tags":"","title":"C++ API"},{"body":" C# Generated Code Guide C# API ","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in C#","excerpt":"This section contains reference documentation for working with …","ref":"/reference/csharp/","tags":"","title":"C# Reference"},{"body":"This page describes exactly what C# code the protocol buffer compiler generates for protocol definitions using proto3 syntax. You should read the proto3 language guide before reading this document.\nNote The protobuf compiler can generate C# interfaces for definitions using proto2 syntax starting from release 3.10. Refer to the proto2 language guide for details of the semantics of proto2 definitions, and see docs/csharp/proto2.md (view on GitHub) for details on the generated C# code for proto2. Compiler Invocation The protocol buffer compiler produces C# output when invoked with the --csharp_out command-line flag. The parameter to the --csharp_out option is the directory where you want the compiler to write your C# output, although depending on other options the compiler may create subdirectories of the specified directory. The compiler creates a single source file for each .proto file input, defaulting to an extension of .cs but configurable via compiler options.\nOnly proto3 messages are supported by the C# code generator. Ensure that each .proto file begins with a declaration of:\nsyntax = \"proto3\"; C#-specific Options You can provide further C# options to the protocol buffer compiler using the --csharp_opt command-line flag. The supported options are:\nfile_extension: Sets the file extension for generated code. This defaults to .cs, but a common alternative is .g.cs to indicate that the file contains generated code.\nbase_namespace: When this option is specified, the generator creates a directory hierarchy for generated source code corresponding to the namespaces of the generated classes, using the value of the option to indicate which part of the namespace should be considered as the \"base\" for the output directory. For example, with the following command-line:\nprotoc --proto_path=bar --csharp_out=src --csharp_opt=base_namespace=Example player.proto where player.proto has a csharp_namespace option of Example.Game the protocol buffer compiler generates a file src/Game/Player.cs being created. This option would usually correspond with the default namespace option in a C# project in Visual Studio. If the option is specified but with an empty value, the full C# namespace as used in the generated file will be used for the directory hierarchy. If the option is not specified at all, the generated files are simply written into the directory specified by --csharp_out without any hierarchy being created.\ninternal_access: When this option is specified, the generator creates types with the internal access modifier instead of public.\nserializable: When this option is specified, the generator adds the [Serializable] attribute to generated message classes.\nMultiple options can be specified by separating them with commas, as in the following example:\nprotoc --proto_path=src --csharp_out=build/gen --csharp_opt=file_extension=.g.cs,base_namespace=Example,internal_access src/foo.proto File structure The name of the output file is derived from the .proto filename by converting it to Pascal-case, treating underscores as word separators. So, for example, a file called player_record.proto will result in an output file called PlayerRecord.cs (where the file extension can be specified using --csharp_opt, as shown above).\nEach generated file takes the following form, in terms of public members. (The implementation is not shown here.)\nnamespace [...] { public static partial class [... descriptor class name ...] { public static FileDescriptor Descriptor { get; } } [... Enums ...] [... Message classes ...] } The namespace is inferred from the proto’s package, using the same conversion rules as the file name. For example, a proto package of example.high_score would result in a namespace of Example.HighScore. You can override the default generated namespace for a particular .proto using the csharp_namespace file option.\nEach top-level enum and message results in an enum or class being declared as members of the namespace. Additionally, a single static partial class is always generated for the file descriptor. This is used for reflection-based operations. The descriptor class is given the same name as the file, without the extension. However, if there is a message with the same name (as is quite common), the descriptor class is placed in a nested Proto namespace to avoid colliding with the message.\nAs an example of all of these rules, consider the timestamp.proto file which is provided as part of Protocol Buffers. A cut down version of timestamp.proto looks like this:\nsyntax = \"proto3\"; package google.protobuf; option csharp_namespace = \"Google.Protobuf.WellKnownTypes\"; message Timestamp { ... } The generated Timestamp.cs file has the following structure:\nnamespace Google.Protobuf.WellKnownTypes { namespace Proto { public static partial class Timestamp { public static FileDescriptor Descriptor { get; } } } public sealed partial class Timestamp : IMessage\u003cTimestamp\u003e { [...] } } Messages Given a simple message declaration:\nmessage Foo {} The protocol buffer compiler generates a sealed, partial class called Foo, which implements the IMessage\u003cFoo\u003e interface, as shown below with member declarations. See the inline comments for more information.\npublic sealed partial class Foo : IMessage\u003cFoo\u003e { // Static properties for parsing and reflection public static MessageParser\u003cFoo\u003e Parser { get; } public static MessageDescriptor Descriptor { get; } // Explicit implementation of IMessage.Descriptor, to avoid conflicting with // the static Descriptor property. Typically the static property is used when // referring to a type known at compile time, and the instance property is used // when referring to an arbitrary message, such as during JSON serialization. MessageDescriptor IMessage.Descriptor { get; } // Parameterless constructor which calls the OnConstruction partial method if provided. public Foo(); // Deep-cloning constructor public Foo(Foo); // Partial method which can be implemented in manually-written code for the same class, to provide // a hook for code which should be run whenever an instance is constructed. partial void OnConstruction(); // Implementation of IDeepCloneable\u003cT\u003e.Clone(); creates a deep clone of this message. public Foo Clone(); // Standard equality handling; note that IMessage\u003cT\u003e extends IEquatable\u003cT\u003e public override bool Equals(object other); public bool Equals(Foo other); public override int GetHashCode(); // Converts the message to a JSON representation public override string ToString(); // Serializes the message to the protobuf binary format public void WriteTo(CodedOutputStream output); // Calculates the size of the message in protobuf binary format public int CalculateSize(); // Merges the contents of the given message into this one. Typically // used by generated code and message parsers. public void MergeFrom(Foo other); // Merges the contents of the given protobuf binary format stream // into this message. Typically used by generated code and message parsers. public void MergeFrom(CodedInputStream input); } Note that all of these members are always present; the optimize_for option does not affect the output of the C# code generator.\nNested Types A message can be declared inside another message. For example:\nmessage Foo { message Bar { } } In this case—or if a message contains a nested enum—the compiler generates a nested Types class, and then a Bar class within the Types class, so the full generated code would be:\nnamespace [...] { public sealed partial class Foo : IMessage\u003cFoo\u003e { public static partial class Types { public sealed partial class Bar : IMessage\u003cBar\u003e { ... } } } } Although the intermediate Types class is inconvenient, it is required to deal with the common scenario of a nested type having a corresponding field in the message. You would otherwise end up with both a property and a type with the same name nested within the same class—and that would be invalid C#.\nFields The protocol buffer compiler generates a C# property for each field defined within a message. The exact nature of the property depends on the nature of the field: its type, and whether it is singular, repeated, or a map field.\nSingular Fields Any singular field generates a read/write property. A string or bytes field will generate an ArgumentNullException if a null value is specified; fetching a value from a field which hasn’t been explicitly set will return an empty string or ByteString. Message fields can be set to null values, which is effectively clearing the field. This is not equivalent to setting the value to an \"empty\" instance of the message type.\nRepeated Fields Each repeated field generates a read-only property of type Google.Protobuf.Collections.RepeatedField\u003cT\u003e where T is the field’s element type. For the most part, this acts like List\u003cT\u003e, but it has an additional Add overload to allow a collection of items to be added in one go. This is convenient when populating a repeated field in an object initializer. Additionally, RepeatedField\u003cT\u003e has direct support for serialization, deserialization and cloning, but this is usually used by generated code instead of manually-written application code.\nRepeated fields cannot contain null values, even of message types, except for the nullable wrapper types explained below.\nMap Fields Each map field generates a read-only property of type Google.Protobuf.Collections.MapField\u003cTKey, TValue\u003e where TKey is the field’s key type and TValue is the field’s value type. For the most part, this acts like Dictionary\u003cTKey, TValue\u003e, but it has an additional Add overload to allow another dictionary to be added in one go. This is convenient when populating a repeated field in an object initializer. Additionally, MapField\u003cTKey, TValue\u003e has direct support for serialization, deserialization and cloning, but this is usually used by generated code instead of manually-written application code. Keys in the map are not permitted to be null; values may be if the corresponding singular field type would support null values.\nOneof Fields Each field within a oneof has a separate property, like a regular singular field. However, the compiler also generates an additional property to determine which field in the enum has been set, along with an enum and a method to clear the oneof. For example, for this oneof field definition\noneof avatar { string image_url = 1; bytes image_data = 2; } The compiler will generate these public members:\nenum AvatarOneofCase { None = 0, ImageUrl = 1, ImageData = 2 } public AvatarOneofCase AvatarCase { get; } public void ClearAvatar(); public string ImageUrl { get; set; } public ByteString ImageData { get; set; } If a property is the current oneof \"case\", fetching that property will return the value set for that property. Otherwise, fetching the property will return the default value for the property’s type—only one member of a oneof can be set at a time.\nSetting any constituent property of the oneof will change the reported \"case\" of the oneof. As with a regular singular field, you cannot set a oneof field with a string or bytes type to a null value. Setting a message-type field to null is equivalent to calling the oneof-specific Clear method.\nWrapper Type Fields Most of the well-known types in proto3 do not affect code generation, but the wrapper types (StringWrapper, Int32Wrapper etc) change the type and behaviour of the properties.\nAll of the wrapper types that correspond to C# value types (Int32Wrapper, DoubleWrapper, BoolWrapper etc) are mapped to Nullable\u003cT\u003e where T is the corresponding non-nullable type. For example, a field of type DoubleValue results in a C# property of type Nullable\u003cdouble\u003e.\nFields of type StringWrapper or BytesWrapper result in C# properties of type string and ByteString being generated, but with a default value of null, and allowing null to be set as the property value.\nFor all wrapper types, null values are not permitted in a repeated field, but are permitted as the values for map entries.\nEnumerations Given an enumeration definition like:\nenum Color { COLOR_RED = 0; COLOR_GREEN = 5; COLOR_BLUE = 1234; } The protocol buffer compiler will generate a C# enum type called Color with the same set of values. The names of the enum values are converted to make them more idiomatic for C# developers:\nIf the original name starts with the upper-cased form of the enum name itself, that is removed The result is converted into Pascal case The Color proto enum above would therefore become the following C# code:\nenum Color { Red = 0, Green = 5, Blue = 1234 } This name transformation does not affect the text used within the JSON representation of messages.\nNote that the .proto language allows multiple enum symbols to have the same numeric value. Symbols with the same numeric value are synonyms. These are represented in C# in exactly the same way, with multiple names corresponding to the same numeric value.\nA non-nested enumeration leads to a C# enum being generated as a new namespace member being generated; a nested enumeration lead to a C# enum being generated in the Types nested class within the class corresponding to the message the enumeration is nested within.\nServices The C# code generator ignores services entirely.\n","categories":"","description":"This topic describes exactly what C# code the protocol buffer compiler generates for protocol definitions using proto3 syntax.","excerpt":"This topic describes exactly what C# code the protocol buffer compiler …","ref":"/reference/csharp/csharp-generated/","tags":"","title":"C# Generated Code Guide"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/csharp/api-docs-link/","tags":"","title":"C# API"},{"body":" Dart Generated Code Guide Dart API ","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in Dart","excerpt":"This section contains reference documentation for working with …","ref":"/reference/dart/","tags":"","title":"Dart Reference"},{"body":"This page describes what Dart code the protocol buffer compiler generates for any given protocol definition. Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base API, which are the same in both versions. You should read the proto2 language guide and/or the proto3 language guide before reading this document.\nCompiler Invocation The protocol buffer compiler requires a plugin to generate Dart code. Installing it following the instructions provides a protoc-gen-dart binary which protoc uses when invoked with the --dart_out command-line flag. The --dart_out flag tells the compiler where to write the Dart source files. For a .proto file input, the compiler produces among others a .pb.dart file.\nThe name of the .pb.dart file is computed by taking the name of the .proto file and making two changes:\nThe extension (.proto) is replaced with .pb.dart. For example, a file called foo.proto results in an output file called foo.pb.dart. The proto path (specified with the --proto_path or -I command-line flag) is replaced with the output path (specified with the --dart_out flag). For example, when you invoke the compiler as follows:\nprotoc --proto_path=src --dart_out=build/gen src/foo.proto src/bar/baz.proto the compiler will read the files src/foo.proto and src/bar/baz.proto. It produces: build/gen/foo.pb.dart and build/gen/bar/baz.pb.dart. The compiler automatically creates the directory build/gen/bar if necessary, but it will not create build or build/gen; they must already exist.\nMessages Given a simple message declaration:\nmessage Foo {} The protocol buffer compiler generates a class called Foo, which extends the class GeneratedMessage.\nThe class GeneratedMessage defines methods that let you check, manipulate, read, or write the entire message. In addition to these methods, the Foo class defines the following methods and constructors:\nFoo(): Default constructor. Creates an instance where all singular fields are unset and repeated fields are empty. Foo.fromBuffer(...): Creates a Foo from serialized protocol buffer data representing the message. Foo.fromJson(...): Creates a Foo from a JSON string encoding the message. Foo clone(): Creates a deep clone of the fields in the message. Foo copyWith(void Function(Foo) updates): Makes a writable copy of this message, applies the updates to it, and marks the copy read-only before returning it. static Foo create(): Factory function to create a single Foo. static PbList\u003cFoo\u003e createRepeated(): Factory function to create a List implementing a mutable repeated field of Foo elements. static Foo getDefault(): Returns a singleton instance of Foo, which is identical to a newly-constructed instance of Foo (so all singular fields are unset and all repeated fields are empty). Nested Types A message can be declared inside another message. For example:\nmessage Foo { message Bar { } } In this case, the compiler generates two classes: Foo and Foo_Bar.\nFields In addition to the methods described in the previous section, the protocol buffer compiler generates accessor methods for each field defined within the message in the .proto file.\nNote that the generated names always use camel-case naming, even if the field name in the .proto file uses lower-case with underscores (as it should). The case-conversion works as follows:\nFor each underscore in the name, the underscore is removed, and the following letter is capitalized. If the name will have a prefix attached (e.g. \"has\"), the first letter is capitalized. Otherwise, it is lower-cased. Thus, for the field foo_bar_baz, the getter becomes get fooBarBaz and a method prefixed with has would be hasFooBarBaz.\nSingular Primitive Fields (proto2) For any of these field definitions:\noptional int32 foo = 1; required int32 foo = 1; The compiler will generate the following accessor methods in the message class:\nint get foo: Returns the current value of the field. If the field is not set, returns the default value. bool hasFoo(): Returns true if the field is set. set foo(int value): Sets the value of the field. After calling this, hasFoo() will return true and get foo will return value. void clearFoo(): Clears the value of the field. After calling this, hasFoo() will return false and get foo will return the default value. For other simple field types, the corresponding Dart type is chosen according to the scalar value types table. For message and enum types, the value type is replaced with the message or enum class.\nSingular Primitive Fields (proto3) For this field definition:\nint32 foo = 1; The compiler will generate the following accessor methods in the message class:\nint get foo: Returns the current value of the field. If the field is not set, returns the default value. set foo(int value): Sets the value of the field. After calling this, get foo will return value. void clearFoo(): Clears the value of the field. After calling this,get foo will return the default value. Singular Message Fields Given the message type:\nmessage Bar {} For a message with a Bar field:\n// proto2 message Baz { optional Bar bar = 1; // The generated code is the same result if required instead of optional. } // proto3 message Baz { Bar bar = 1; } The compiler will generate the following accessor methods in the message class:\nBar get bar: Returns the current value of the field. If the field is not set, returns the default value. set bar(Bar value): Sets the value of the field. After calling this, hasBar() will return true and get bar will return value. bool hasBar(): Returns true if the field is set. void clearBar(): Clears the value of the field. After calling this, hasBar() will return false and get bar will return the default value. Bar ensureBar(): Sets bar to the empty instance if hasBar() returns false, and then returns the value of bar. After calling this, hasBar() will return true. Repeated Fields For this field definition:\nrepeated int32 foo = 1; The compiler will generate:\nList\u003cint\u003e get foo: Returns the list backing the field. If the field is not set, returns an empty list. Modifications to the list are reflected in the field. Int64 Fields For this field definition:\n// proto2 optional int64 bar = 1; // proto3 int64 bar = 1; The compiler will generate:\nInt64 get bar: Returns an Int64 object containing the field value. Note that Int64 is not built into the Dart core libraries. To work with these objects, you may need to import the Dart fixnum library:\nimport 'package:fixnum/fixnum.dart'; Map Fields Given a map field definition like this:\nmap\u003cint32, int32\u003e map_field = 1; The compiler will generate the following getter:\nMap\u003cint, int\u003e get mapField: Returns the Dart map backing the field. If the field is not set, returns an empty map. Modifications to the map are reflected in the field. Any Given an Any field like this:\nimport \"google/protobuf/any.proto\"; message ErrorStatus { string message = 1; google.protobuf.Any details = 2; } In our generated code, the getter for the details field returns an instance of com.google.protobuf.Any. This provides the following special methods to pack and unpack the Any’s values:\n/// Unpacks the message in [value] into [instance]. /// /// Throws a [InvalidProtocolBufferException] if [typeUrl] does not correspond /// to the type of [instance]. /// /// A typical usage would be `any.unpackInto(new Message())`. /// /// Returns [instance]. T unpackInto\u003cT extends GeneratedMessage\u003e(T instance, {ExtensionRegistry extensionRegistry = ExtensionRegistry.EMPTY}); /// Returns `true` if the encoded message matches the type of [instance]. /// /// Can be used with a default instance: /// `any.canUnpackInto(Message.getDefault())` bool canUnpackInto(GeneratedMessage instance); /// Creates a new [Any] encoding [message]. /// /// The [typeUrl] will be [typeUrlPrefix]/`fullName` where `fullName` is /// the fully qualified name of the type of [message]. static Any pack(GeneratedMessage message, {String typeUrlPrefix = 'type.googleapis.com'}); Oneof Given a oneof definition like this:\nmessage Foo { oneof test { string name = 1; SubMessage sub_message = 2; } } The compiler will generate the following Dart enum type:\nenum Foo_Test { name, subMessage, notSet } In addition, it will generate these methods:\nFoo_Test whichTest(): Returns the enum indicating which field is set. Returns Foo_Test.notSet if none of them is set. void clearTest(): Clears the value of the oneof field which is currently set (if any), and sets the oneof case to Foo_Test.notSet. For each field inside the oneof definition the regular field accessor methods are generated. For instance for name:\nString get name: Returns the current value of the field if the oneof case is Foo_Test.name. Otherwise, returns the default value. set name(String value): Sets the value of the field and sets the oneof case to Foo_Test.name. After calling this, get name will return value and whichTest() will return Foo_Test.name. void clearName(): Nothing will be changed if the oneof case is not Foo_Test.name. Otherwise, clears the value of the field. After calling this, get name will return the default value and whichTest() will return Foo_Test.notSet. Enumerations Given an enum definition like:\nenum Color { RED = 0; GREEN = 1; BLUE = 2; } The protocol buffer compiler will generate a class called Color, which extends the ProtobufEnum class. The class will include a static const Color for each of the three values defined as well as a static const List\u003cColor\u003e containing all the three values. It will also include the following method:\nstatic Color valueOf(int value): Returns the Color corresponding to the given numeric value. Each value will have the following properties:\nname: The enum’s name, as specified in the .proto file. value: The enum’s integer value, as specified in the .proto file. Note that the .proto language allows multiple enum symbols to have the same numeric value. Symbols with the same numeric value are synonyms. For example:\nenum Foo { BAR = 0; BAZ = 0; } In this case, BAZ is a synonym for BAR and will be defined like so:\nstatic const Foo BAZ = BAR; An enum can be defined nested within a message type. For instance, given an enum definition like:\nmessage Bar { enum Color { RED = 0; GREEN = 1; BLUE = 2; } } The protocol buffer compiler will generate a class called Bar, which extends GeneratedMessage, and a class called Bar_Color, which extends ProtobufEnum.\nExtensions (proto2 only) Given a file foo_test.proto including a message with an extension range and a top-level extension definition:\nmessage Foo { extensions 100 to 199; } extend Foo { optional int32 bar = 101; } The protocol buffer compiler will generate, in addition to the Foo class, a class Foo_test which will contain a static Extension for each extension field in the file along with a method for registering all the exensions in an ExtensionRegistry :\nstatic final Extension bar static void registerAllExtensions(ExtensionRegistry registry) : Registers all the defined extensions in the given registry. The extension accessors of Foo can be used as follows:\nFoo foo = Foo(); foo.setExtension(Foo_test.bar, 1); assert(foo.hasExtension(Foo_test.bar)); assert(foo.getExtension(Foo_test.bar)) == 1); Extensions can also be declared nested inside of another message:\nmessage Baz { extend Foo { optional int32 bar = 124; } } In this case, the extension bar is instead declared as a static member of the Baz class.\nWhen parsing a message that might have extensions, you must provide an ExtensionRegistry in which you have registered any extensions that you want to be able to parse. Otherwise, those extensions will just be treated like unknown fields. For example:\nExtensionRegistry registry = ExtensionRegistry(); registry.add(Baz.bar); Foo foo = Foo.fromBuffer(input, registry); If you already have a parsed message with unknown fields, you can use reparseMessage on an ExtensionRegistry to reparse the message. If the set of unknown fields contains extensions that are present in the registry, these extensions are parsed and removed from the unknown field set. Extensions already present in the message are preserved.\nFoo foo = Foo.fromBuffer(input); ExtensionRegistry registry = ExtensionRegistry(); registry.add(Baz.bar); Foo reparsed = registry.reparseMessage(foo); Be aware that this method to retrieve extensions is more expensive overall. Where possible we recommend using ExtensionRegistry with all the needed extensions when doing GeneratedMessage.fromBuffer.\nServices Given a service definition:\nservice Foo { rpc Bar(FooRequest) returns(FooResponse); } The protocol buffer compiler can be invoked with the `grpc` option (e.g. --dart_out=grpc:output_folder), in which case it will generate code to support gRPC. See the gRPC Dart Quickstart guide for more details.\n","categories":"","description":"This topic describes what Dart code the protocol buffer compiler generates for any given protocol definition.","excerpt":"This topic describes what Dart code the protocol buffer compiler …","ref":"/reference/dart/dart-generated/","tags":"","title":"Dart Generated Code Guide"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/dart/api-docs-link/","tags":"","title":"Dart API"},{"body":" Go Generated Code Guide\nGo API (godoc)\nGo FAQ\n","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in Go","excerpt":"This section contains reference documentation for working with …","ref":"/reference/go/","tags":"","title":"Go Reference"},{"body":"This page describes exactly what Go code the protocol buffer compiler generates for any given protocol definition. Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base API, which are the same in both versions. You should read the proto2 language guide and/or the proto3 language guide before reading this document.\nCompiler Invocation The protocol buffer compiler requires a plugin to generate Go code. Install it using Go 1.16 or higher by running:\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest This will install a protoc-gen-go binary in $GOBIN. Set the $GOBIN environment variable to change the installation location. It must be in your $PATH for the protocol buffer compiler to find it.\nThe protocol buffer compiler produces Go output when invoked with the go_out flag. The argument to the go_out flag is the directory where you want the compiler to write your Go output. The compiler creates a single source file for each .proto file input. The name of the output file is created by replacing the .proto extension with .pb.go.\nWhere in the output directory the generated .pb.go file is placed depends on the compiler flags. There are several output modes:\nIf the paths=import flag is specified, the output file is placed in a directory named after the Go package’s import path. For example, an input file protos/buzz.proto with a Go import path of example.com/project/protos/fizz results in an output file at example.com/project/protos/fizz/buzz.pb.go. This is the default output mode if a paths flag is not specified. If the module=$PREFIX flag is specified, the output file is placed in a directory named after the Go package’s import path, but with the specified directory prefix removed from the output filename. For example, an input file protos/buzz.proto with a Go import path of example.com/project/protos/fizz and example.com/project specified as the module prefix results in an output file at protos/fizz/buzz.pb.go. Generating any Go packages outside the module path results in an error. This mode is useful for outputting generated files directly into a Go module. If the paths=source_relative flag is specified, the output file is placed in the same relative directory as the input file. For example, an input file protos/buzz.proto results in an output file at protos/buzz.pb.go. Flags specific to protoc-gen-go are provided by passing a go_opt flag when invoking protoc. Multiple go_opt flags may be passed. For example, when running:\nprotoc --proto_path=src --go_out=out --go_opt=paths=source_relative foo.proto bar/baz.proto the compiler will read input files foo.proto and bar/baz.proto from within the src directory, and write output files foo.pb.go and bar/baz.pb.go to the out directory. The compiler automatically creates nested output sub-directories if necessary, but will not create the output directory itself.\nPackages In order to generate Go code, the Go package’s import path must be provided for every .proto file (including those transitively depended upon by the .proto files being generated). There are two ways to specify the Go import path:\nby declaring it within the .proto file, or by declaring it on the command line when invoking protoc. We recommend declaring it within the .proto file so that the Go packages for .proto files can be centrally identified with the .proto files themselves and to simplify the set of flags passed when invoking protoc. If the Go import path for a given .proto file is provided by both the .proto file itself and on the command line, then the latter takes precedence over the former.\nThe Go import path is locally specified in a .proto file by declaring a go_package option with the full import path of the Go package. Example usage:\noption go_package = \"example.com/project/protos/fizz\"; The Go import path may be specified on the command line when invoking the compiler, by passing one or more M${PROTO_FILE}=${GO_IMPORT_PATH} flags. Example usage:\nprotoc --proto_path=src \\ --go_opt=Mprotos/buzz.proto=example.com/project/protos/fizz \\ --go_opt=Mprotos/bar.proto=example.com/project/protos/foo \\ protos/buzz.proto protos/bar.proto Since the mapping of all .proto files to their Go import paths can be quite large, this mode of specifying the Go import paths is generally performed by some build tool (e.g., Bazel) that has control over the entire dependency tree. If there are duplicate entries for a given .proto file, then the last one specified takes precedence.\nFor both the go_package option and the M flag, the value may include an explicit package name separated from the import path by a semicolon. For example: \"example.com/protos/foo;package_name\". This usage is discouraged since the package name will be derived by default from the import path in a reasonable manner.\nThe import path is used to determine which import statements must be generated when one .proto file imports another .proto file. For example, if a.proto imports b.proto, then the generated a.pb.go file needs to import the Go package which contains the generated b.pb.go file (unless both files are in the same package). The import path is also used to construct output filenames. See the \"Compiler Invocation\" section above for details.\nThere is no correlation between the Go import path and the package specifier in the .proto file. The latter is only relevant to the protobuf namespace, while the former is only relevant to the Go namespace. Also, there is no correlation between the Go import path and the .proto import path.\nMessages Given a simple message declaration:\nmessage Artist {} the protocol buffer compiler generates a struct called Artist. An *Artist implements the proto.Message interface.\nThe proto package provides functions which operate on messages, including conversion to and from binary format.\nThe proto.Message interface defines a ProtoReflect method. This method returns a protoreflect.Message which provides a reflection-based view of the message.\nThe optimize_for option does not affect the output of the Go code generator.\nNested Types A message can be declared inside another message. For example:\nmessage Artist { message Name { } } In this case, the compiler generates two structs: Artist and Artist_Name.\nFields The protocol buffer compiler generates a struct field for each field defined within a message. The exact nature of this field depends on its type and whether it is a singular, repeated, map, or oneof field.\nNote that the generated Go field names always use camel-case naming, even if the field name in the .proto file uses lower-case with underscores (as it should). The case-conversion works as follows:\nThe first letter is capitalized for export. If the first character is an underscore, it is removed and a capital X is prepended. If an interior underscore is followed by a lower-case letter, the underscore is removed, and the following letter is capitalized. Thus, the proto field birth_year becomes BirthYear in Go, and _birth_year_2 becomes XBirthYear_2.\nSingular Scalar Fields (proto2) For either of these field definitions:\noptional int32 birth_year = 1; required int32 birth_year = 1; the compiler generates a struct with an *int32 field named BirthYear and an accessor method GetBirthYear() which returns the int32 value in Artist or the default value if the field is unset. If the default is not explicitly set, the zero value of that type is used instead (0 for numbers, the empty string for strings).\nFor other scalar field types (including bool, bytes, and string), *int32 is replaced with the corresponding Go type according to the scalar value types table.\nSingular Scalar Fields (proto3) For this field definition:\nint32 birth_year = 1; optional int32 first_active_year = 2; The compiler will generate a struct with an int32 field named BirthYear and an accessor method GetBirthYear() which returns the int32 value in birth_year or the zero value of that type if the field is unset (0 for numbers, the empty string for strings).\nThe FirstActiveYear struct field will be of type *int32, and additionally have the HasFirstActiveYear() and ClearFirstActiveYear() accessors, because it is marked optional.\nFor other scalar field types (including bool, bytes, and string), int32 is replaced with the corresponding Go type according to the scalar value types table. Unset values in the proto will be represented as the zero value of that type (0 for numbers, the empty string for strings).\nSingular Message Fields Given the message type:\nmessage Band {} For a message with a Band field:\n// proto2 message Concert { optional Band headliner = 1; // The generated code is the same result if required instead of optional. } // proto3 message Concert { Band headliner = 1; } The compiler will generate a Go struct\ntype Concert struct { Headliner *Band } Message fields can be set to nil, which means that the field is unset, effectively clearing the field. This is not equivalent to setting the value to an \"empty\" instance of the message struct.\nThe compiler also generates a func (m *Concert) GetHeadliner() *Band helper function. This function returns a nil *Band if m is nil or headliner is unset. This makes it possible to chain get calls without intermediate nil checks:\nvar m *Concert // defaults to nil log.Infof(\"GetFoundingYear() = %d (no panic!)\", m.GetHeadliner().GetFoundingYear()) Repeated Fields Each repeated field generates a slice of T field in the struct in Go, where T is the field’s element type. For this message with a repeated field:\nmessage Concert { // Best practice: use pluralized names for repeated fields: // /programming-guides/style#repeated-fields repeated Band support_acts = 1; } the compiler generates the Go struct:\ntype Concert struct { SupportActs []*Band } Likewise, for the field definition repeated bytes band_promo_images = 1; the compiler will generate a Go struct with a [][]byte field named BandPromoImage. For a repeated enumeration like repeated MusicGenre genres = 2;, the compiler generates a struct with a []MusicGenre field called Genre.\nThe following example shows how to set the field:\nconcert := \u0026Concert{ SupportActs: []*Band{ {}, // First element. {}, // Second element. }, } To access the field, you can do the following:\nsupport := concert.GetSupportActs() // support type is []*Band. b1 := support[0] // b1 type is *Band, the first element in support_acts. Map Fields Each map field generates a field in the struct of type map[TKey]TValue where TKey is the field’s key type and TValue is the field’s value type. For this message with a map field:\nmessage MerchItem {} message MerchBooth { // items maps from merchandise item name (\"Signed T-Shirt\") to // a MerchItem message with more details about the item. map\u003cstring, MerchItem\u003e items = 1; } the compiler generates the Go struct:\ntype MerchBooth struct { Items map[string]*MerchItem } Oneof Fields For a oneof field, the protobuf compiler generates a single field with an interface type isMessageName_MyField. It also generates a struct for each of the singular fields within the oneof. These all implement this isMessageName_MyField interface.\nFor this message with a oneof field:\npackage account; message Profile { oneof avatar { string image_url = 1; bytes image_data = 2; } } the compiler generates the structs:\ntype Profile struct { // Types that are valid to be assigned to Avatar: // *Profile_ImageUrl // *Profile_ImageData Avatar isProfile_Avatar `protobuf_oneof:\"avatar\"` } type Profile_ImageUrl struct { ImageUrl string } type Profile_ImageData struct { ImageData []byte } Both *Profile_ImageUrl and *Profile_ImageData implement isProfile_Avatar by providing an empty isProfile_Avatar() method.\nThe following example shows how to set the field:\np1 := \u0026account.Profile{ Avatar: \u0026account.Profile_ImageUrl{\"http://example.com/image.png\"}, } // imageData is []byte imageData := getImageData() p2 := \u0026account.Profile{ Avatar: \u0026account.Profile_ImageData{imageData}, } To access the field, you can use a type switch on the value to handle the different message types.\nswitch x := m.Avatar.(type) { case *account.Profile_ImageUrl: // Load profile image based on URL // using x.ImageUrl case *account.Profile_ImageData: // Load profile image based on bytes // using x.ImageData case nil: // The field is not set. default: return fmt.Errorf(\"Profile.Avatar has unexpected type %T\", x) } The compiler also generates get methods func (m *Profile) GetImageUrl() string and func (m *Profile) GetImageData() []byte. Each get function returns the value for that field or the zero value if it is not set.\nEnumerations Given an enumeration like:\nmessage Venue { enum Kind { KIND_UNSPECIFIED = 0; KIND_CONCERT_HALL = 1; KIND_STADIUM = 2; KIND_BAR = 3; KIND_OPEN_AIR_FESTIVAL = 4; // ... } Kind kind = 1; // ... } the protocol buffer compiler generates a type and a series of constants with that type.\nFor enums within a message (like the one above), the type name begins with the message name:\ntype Venue_Kind int32 For a package-level enum:\nenum Genre { GENRE_UNSPECIFIED = 0; GENRE_ROCK = 1; GENRE_INDIE = 2; GENRE_DRUM_AND_BASS = 3; // ... } the Go type name is unmodified from the proto enum name:\ntype Genre int32 This type has a String() method that returns the name of a given value.\nThe Enum() method initializes freshly allocated memory with a given value and returns the corresponding pointer:\nfunc (Genre) Enum() *Genre If you use proto3 syntax for your .proto definition, the Enum() method is not generated.\nThe protocol buffer compiler generates a constant for each value in the enum. For enums within a message, the constants begin with the enclosing message’s name:\nconst ( Venue_KIND_UNSPECIFIED Venue_Kind = 0 Venue_KIND_CONCERT_HALL Venue_Kind = 1 Venue_KIND_STADIUM Venue_Kind = 2 Venue_KIND_BAR Venue_Kind = 3 Venue_KIND_OPEN_AIR_FESTIVAL Venue_Kind = 4 ) For a package-level enum, the constants begin with the enum name instead:\nconst ( Genre_GENRE_UNSPECIFIED Genre = 0 Genre_GENRE_ROCK Genre = 1 Genre_GENRE_INDIE Genre = 2 Genre_GENRE_DRUM_AND_BASS Genre = 3 ) The protobuf compiler also generates a map from integer values to the string names and a map from the names to the values:\nvar Genre_name = map[int32]string{ 0: \"GENRE_UNSPECIFIED\", 1: \"GENRE_ROCK\", 2: \"GENRE_INDIE\", 3: \"GENRE_DRUM_AND_BASS\", } var Genre_value = map[string]int32{ \"GENRE_UNSPECIFIED\": 0, \"GENRE_ROCK\": 1, \"GENRE_INDIE\": 2, \"GENRE_DRUM_AND_BASS\": 3, } Note that the .proto language allows multiple enum symbols to have the same numeric value. Symbols with the same numeric value are synonyms. These are represented in Go in exactly the same way, with multiple names corresponding to the same numeric value. The reverse mapping contains a single entry for the numeric value to the name which appears first in the .proto file.\nExtensions (proto2) Given an extension definition:\nextend Concert { optional int32 promo_id = 123; } The protocol buffer compiler will generate a protoreflect.ExtensionType value named E_Promo_id. This value may be used with the proto.GetExtension, proto.SetExtension, proto.HasExtension, and proto.ClearExtension functions to access an extension in a message. The GetExtension function and SetExtension functions respectively return and accept an interface{} value containing the extension value type.\nFor singular scalar extension fields, the extension value type is the corresponding Go type from the scalar value types table.\nFor singular embedded message extension fields, the extension value type is *M, where M is the field message type.\nFor repeated extension fields, the extension value type is a slice of the singular type.\nFor example, given the following definition:\nextend Concert { optional int32 singular_int32 = 1; repeated bytes repeated_strings = 2; optional Band singular_message = 3; } Extension values may be accessed as:\nm := \u0026somepb.Concert{} proto.SetExtension(m, extpb.E_SingularInt32, int32(1)) proto.SetExtension(m, extpb.E_RepeatedString, []string{\"a\", \"b\", \"c\"}) proto.SetExtension(m, extpb.E_SingularMessage, \u0026extpb.Band{}) v1 := proto.GetExtension(m, extpb.E_SingularInt32).(int32) v2 := proto.GetExtension(m, extpb.E_RepeatedString).([][]byte) v3 := proto.GetExtension(m, extpb.E_SingularMessage).(*extpb.Band) Extensions can be declared nested inside of another type. For example, a common pattern is to do something like this:\nmessage Promo { extend Concert { optional int32 promo_id = 124; } } In this case, the ExtensionType value is named E_Promo_Concert.\nServices The Go code generator does not produce output for services by default. If you enable the gRPC plugin (see the gRPC Go Quickstart guide) then code will be generated to support gRPC.\n","categories":"","description":"This topic describes exactly what Go code the protocol buffer compiler generates for any given protocol definition.","excerpt":"This topic describes exactly what Go code the protocol buffer compiler …","ref":"/reference/go/go-generated/","tags":"","title":"Go Generated Code Guide"},{"body":"Versions What’s the difference between github.com/golang/protobuf and google.golang.org/protobuf? The github.com/golang/protobuf module is the original Go protocol buffer API.\nThe google.golang.org/protobuf module is an updated version of this API designed for simplicity, ease of use, and safety. The flagship features of the updated API are support for reflection and a separation of the user-facing API from the underlying implementation.\nWe recommend that you use google.golang.org/protobuf in new code.\nVersion v1.4.0 and higher of github.com/golang/protobuf wrap the new implementation and permit programs to adopt the new API incrementally. For example, the well-known types defined in github.com/golang/protobuf/ptypes are simply aliases of those defined in the newer module. Thus, google.golang.org/protobuf/types/known/emptypb and github.com/golang/protobuf/ptypes/empty may be used interchangeably.\nWhat are proto1, proto2, and proto3? These are revisions of the protocol buffer language. It is different from the Go implementation of protobufs.\nproto3 is the current version of the language. This is the most commonly used version of the language. We encourage new code to use proto3.\nproto2 is an older version of the language. Despite being superseded by proto3, proto2 is still fully supported.\nproto1 is an obsolete version of the language. It was never released as open source.\nThere are several different Message types. Which should I use? \"google.golang.org/protobuf/proto\".Message is an interface type implemented by all messages generated by the current version of the protocol buffer compiler. Functions that operate on arbitrary messages, such as proto.Marshal or proto.Clone, accept or return this type.\n\"google.golang.org/protobuf/reflect/protoreflect\".Message is an interface type describing a reflection view of a message.\nCall the ProtoReflect method on a proto.Message to get a protoreflect.Message.\n\"google.golang.org/protobuf/reflect/protoreflect\".ProtoMessage is an alias of \"google.golang.org/protobuf/proto\".Message. The two types are interchangeable.\n\"github.com/golang/protobuf/proto\".Message is an interface type defined by the legacy Go protocol buffer API. All generated message types implement this interface, but the interface does not describe the behavior expected from these messages. New code should avoid using this type.\nCommon problems “go install”: working directory is not part of a module On Go 1.15 and below, you have set the environment variable GO111MODULE=on and are running the go install command outside of a module directory. Set GO111MODULE=auto, or unset the environment variable.\nOn Go 1.16 and above, go install can be invoked outside of a module by specifying an explicit version: go install google.golang.org/protobuf/cmd/protoc-gen-go@latest\nconstant -1 overflows protoimpl.EnforceVersion You are using a generated .pb.go file which requires a newer version of the \"google.golang.org/protobuf\" module.\nUpdate to a newer version with:\ngo get -u google.golang.org/protobuf/proto undefined: \"github.com/golang/protobuf/proto\".ProtoPackageIsVersion4 You are using a generated .pb.go file which requires a newer version of the \"github.com/golang/protobuf\" module.\nUpdate to a newer version with:\ngo get -u github.com/golang/protobuf/proto What is a protocol buffer namespace conflict? All protocol buffers declarations linked into a Go binary are inserted into a global registry.\nEvery protobuf declaration (for example, enums, enum values, or messages) has an absolute name, which is the concatenation of the package name with the relative name of the declaration in the .proto source file (for example, my.proto.package.MyMessage.NestedMessage). The protobuf language assumes that all declarations are universally unique.\nIf two protobuf declarations linked into a Go binary have the same name, then this leads to a namespace conflict, and it is impossible for the registry to properly resolve that declaration by name. Depending on which version of Go protobufs is being used, this will either panic at init-time or silently drop the conflict and lead to a potential bug later during runtime.\nHow do I fix a protocol buffer namespace conflict? The way to best fix a namespace conflict depends on the reason why a conflict is occurring.\nCommon ways that namespace conflicts occur:\nVendored .proto files. When a single .proto file is generated into two or more Go packages and linked into the same Go binary, it conflicts on every protobuf declaration in the generated Go packages. This typically occurs when a .proto file is vendored and a Go package is generated from it, or the generated Go package itself is vendored. Users should avoid vendoring and instead depend on a centralized Go package for that .proto file.\nIf a .proto file is owned by an external party and is lacking a go_package option, then you should coordinate with the owner of that .proto file to specify a centralized Go package that a plurality of users can all depend on. Missing or generic proto package names. If a .proto file does not specify a package name or uses an overly generic package name (for example, “my_service”), then there is a high probability that declarations within that file will conflict with other declarations elsewhere in the universe. We recommend that every .proto file have a package name that is deliberately chosen to be universally unique (for example, prefixed with the name of a company).\nWarning: Retroactively changing the package name on a .proto file can potentially cause the use of extension fields or messages stored in google.protobuf.Any to stop working properly. Starting with v1.26.0 of the google.golang.org/protobuf module, a hard error will be reported when a Go program starts up that has multiple conflicting protobuf names linked into it. While it is preferable that the source of the conflict be fixed, the fatal error can be immediately worked around in one of two ways:\nAt compile time. The default behavior for handling conflicts can be specified at compile time with a linker-initialized variable: go build -ldflags \"-X google.golang.org/protobuf/reflect/protoregistry.conflictPolicy=warn\"\nAt program execution. The behavior for handling conflicts when executing a particular Go binary can be set with an environment variable: GOLANG_PROTOBUF_REGISTRATION_CONFLICT=warn ./main\nWhy does reflect.DeepEqual behave unexpectedly with protobuf messages? Generated protocol buffer message types include internal state which can vary even between equivalent messages.\nIn addition, the reflect.DeepEqual function is not aware of the semantics of protocol buffer messages, and can report differences where none exist. For example, a map field containing a nil map and one containing a zero-length, non-nil map are semantically equivalent, but will be reported as unequal by reflect.DeepEqual.\nUse the proto.Equal function to compare message values.\nIn tests, you can also use the \"github.com/google/go-cmp/cmp\" package with the protocmp.Transform() option. The cmp package can compare arbitrary data structures, and cmp.Diff produces human-readable reports of the differences between values.\nif diff := cmp.Diff(a, b, protocmp.Transform()); diff != \"\" { t.Errorf(\"unexpected difference:\\n%v\", diff) } Hyrum’s Law What is Hyrum’s Law, and why is it in this FAQ? Hyrum’s Law states:\nWith a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.\nA design goal of the latest version of the Go protocol buffer API is to avoid, where possible, providing observable behaviors that we cannot promise to keep stable in the future. It is our philosophy that deliberate instability in areas where we make no promises is better than giving the illusion of stability, only for that to change in the future after a project has potentially been long depending on that false assumption.\nWhy does the text of errors keep changing? Tests depending on the exact text of errors are brittle and break often when that text changes. To discourage unsafe use of error text in tests, the text of errors produced by this module is deliberately unstable.\nIf you need to identify whether an error is produced by the protobuf module, we guarantee that all errors will match proto.Error according to errors.Is.\nWhy does the output of protojson keep changing? We make no promises about the long-term stability of Go’s implementation of the JSON format for protocol buffers. The specification only specifies what is valid JSON, but provides no specification for a canonical format for how a marshaler ought to exactly format a given message. To avoid giving the illusion that the output is stable, we deliberately introduce minor differences so that byte-for-byte comparisons are likely to fail.\nTo gain some degree of output stability, we recommend running the output through a JSON formatter.\nWhy does the output of prototext keep changing? We make no promises about the long-term stability of Go’s implementation of the text format. There is no canonical specification of the protobuf text format, and we would like to preserve the ability to make improvements in the prototext package output in the future. Since we don’t promise stability in the package’s output, we’ve deliberately introduced instability to discourage users from depending on it.\nTo obtain some degree of stability, we recommend passing the output of prototext through the txtpbfmt program. The formatter can be directly invoked in Go using parser.Format.\nMiscellaneous How do I use a protocol buffer message as a hash key? You need canonical serialization, where the marshaled output of a protocol buffer message is guaranteed to be stable over time. Unfortunately, no specification for canonical serialization exists at this time. You’ll need to write your own or find a way to avoid needing one.\nCan I add a new feature to the Go protocol buffer implementation? Maybe. We always like suggestions, but we’re very cautious about adding new things.\nThe Go implementation of protocol buffers strives to be consistent with the other language implementations. As such, we tend to shy away from feature that are overly specialized to just Go. Go-specific features hinder the goal of protocol buffers being a language-neutral data interchange format.\nUnless your idea is specific to the Go implementation, you should join the protobuf discussion group and suggest it there.\nIf you have an idea for the Go implementation, file an issue on our issue tracker: https://github.com/golang/protobuf/issues\nCan I add an option to Marshal or Unmarshal to customize it? Only if that option exists in other implementations (e.g., C++, Java). The encoding of protocol buffers (binary, JSON, and text) must be consistent across implementations, so a program written in one language is able to read messages written by another one.\nWe will not add any options to the Go implementation that affect the data output by Marshal functions or read by Unmarshal functions unless an equivalent option exist in at least one other supported implementation.\nCan I customize the code generated by protoc-gen-go? In general, no. Protocol buffers are intended to be a language-agnostic data interchange format, and implementation-specific customizations run counter to that intent.\n","categories":"","description":"This topic has a list of frequently asked questions about implementing protocol buffers in Go, with answer for each.","excerpt":"This topic has a list of frequently asked questions about implementing …","ref":"/reference/go/faq/","tags":"","title":"Go FAQ"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/go/api-docs-link/","tags":"","title":"Go API"},{"body":" Java Generated Code Guide Java Proto Names Java API (Javadoc) ","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in Java","excerpt":"This section contains reference documentation for working with …","ref":"/reference/java/","tags":"","title":"Java Reference"},{"body":"This page describes exactly what Java code the protocol buffer compiler generates for any given protocol definition. Any differences between proto2 and proto3 generated code are highlighted—note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.\nNote that no Java protocol buffer methods accept or return nulls unless otherwise specified.\nCompiler Invocation The protocol buffer compiler produces Java output when invoked with the --java_out= command-line flag. The parameter to the --java_out= option is the directory where you want the compiler to write your Java output. For each .proto file input, the compiler creates a wrapper .java file containing a Java class which represents the .proto file itself.\nIf the .proto file contains a line like the following:\noption java_multiple_files = true; Then the compiler will also create separate .java files for each of the classes/enums which it will generate for each top-level message, enumeration, and service declared in the .proto file.\nOtherwise (i.e. when the java_multiple_files option is disabled; which is the default), the aforementioned wrapper class will also be used as an outer class, and the generated classes/enums for each top-level message, enumeration, and service declared in the .proto file will all be nested within the outer wrapper class. Thus the compiler will only generate a single .java file for the entire .proto file.\nThe wrapper class’s name is chosen as follows: If the .proto file contains a line like the following:\noption java_outer_classname = \"Foo\"; Then the wrapper class name will be Foo. Otherwise, the wrapper class name is determined by converting the .proto file base name to camel case. For example, foo_bar.proto will generate a class name of FooBar. If there’s a service, enum, or message (including nested types) in the file with the same name, “OuterClass” will be appended to the wrapper class’s name. Examples:\nIf foo_bar.proto contains a message called FooBar, the wrapper class will generate a class name of FooBarOuterClass. If foo_bar.proto contains a service called FooService, and java_outer_classname is also set to the string FooService, then the wrapper class will generate a class name of FooServiceOuterClass. In addition to any nested classes, the wrapper class itself will have the following API (assuming the wrapper class is named Foo and was generated from foo.proto):\npublic final class Foo { private Foo() {} // Not instantiable. /** Returns a FileDescriptor message describing the contents of {@code foo.proto}. */ public static com.google.protobuf.Descriptors.FileDescriptor getDescriptor(); /** Adds all extensions defined in {@code foo.proto} to the given registry. */ public static void registerAllExtensions(com.google.protobuf.ExtensionRegistry registry); public static void registerAllExtensions(com.google.protobuf.ExtensionRegistryLite registry); // (Nested classes omitted) } The Java package name is chosen as described under Packages, below.\nThe output file is chosen by concatenating the parameter to --java_out=, the package name (with .s replaced with /s), and the .java file name.\nSo, for example, let’s say you invoke the compiler as follows:\nprotoc --proto_path=src --java_out=build/gen src/foo.proto If foo.proto’s Java package is com.example and it doesn’t enable java_multiple_files and its outer classname is FooProtos, then the protocol buffer compiler will generate the file build/gen/com/example/FooProtos.java. The protocol buffer compiler will automatically create the build/gen/com and build/gen/com/example directories if needed. However, it will not create build/gen or build; they must already exist. You can specify multiple .proto files in a single invocation; all output files will be generated at once.\nWhen outputting Java code, the protocol buffer compiler’s ability to output directly to JAR archives is particularly convenient, as many Java tools are able to read source code directly from JAR files. To output to a JAR file, simply provide an output location ending in .jar. Note that only the Java source code is placed in the archive; you must still compile it separately to produce Java class files.\nPackages The generated class is placed in a Java package based on the java_package option. If the option is omitted, the package declaration is used instead.\nFor example, if the .proto file contains:\npackage foo.bar; Then the resulting Java class will be placed in Java package foo.bar. However, if the .proto file also contains a java_package option, like so:\npackage foo.bar; option java_package = \"com.example.foo.bar\"; Then the class is placed in the com.example.foo.bar package instead. The java_package option is provided because normal .proto package declarations are not expected to start with a backwards domain name.\nMessages Given a simple message declaration:\nmessage Foo {} The protocol buffer compiler generates a class called Foo, which implements the Message interface. The class is declared final; no further subclassing is allowed. Foo extends GeneratedMessage, but this should be considered an implementation detail. By default, Foo overrides many methods of GeneratedMessage with specialized versions for maximum speed. However, if the .proto file contains the line:\noption optimize_for = CODE_SIZE; then Foo will override only the minimum set of methods necessary to function and rely on GeneratedMessage’s reflection-based implementations of the rest. This significantly reduces the size of the generated code, but also reduces performance. Alternatively, if the .proto file contains:\noption optimize_for = LITE_RUNTIME; then Foo will include fast implementations of all methods, but will implement the MessageLite interface, which only contains a subset of the methods of Message. In particular, it does not support descriptors or reflection. However, in this mode, the generated code only needs to link against libprotobuf-lite.jar instead of libprotobuf.jar. The “lite” library is much smaller than the full library, and is more appropriate for resource-constrained systems such as mobile phones.\nThe Message interface defines methods that let you check, manipulate, read, or write the entire message. In addition to these methods, the Foo class defines the following static methods:\nstatic Foo getDefaultInstance(): Returns the singleton instance of Foo. This instance’s contents are identical to what you’d get if you called Foo.newBuilder().build() (so all singular fields are unset and all repeated fields are empty). Note that the default instance of a message can be used as a factory by calling its newBuilderForType() method. static Descriptor getDescriptor(): Returns the type’s descriptor. This contains information about the type, including what fields it has and what their types are. This can be used with the reflection methods of the Message, such as getField(). static Foo parseFrom(...): Parses a message of type Foo from the given source and returns it. There is one parseFrom method corresponding to each variant of mergeFrom() in the Message.Builder interface. Note that parseFrom() never throws UninitializedMessageException; it throws InvalidProtocolBufferException if the parsed message is missing required fields. This makes it subtly different from calling Foo.newBuilder().mergeFrom(...).build(). static Parser parser(): Returns an instance of the Parser, which implements various parseFrom() methods. Foo.Builder newBuilder(): Creates a new builder (described below). Foo.Builder newBuilder(Foo prototype): Creates a new builder with all fields initialized to the same values that they have in prototype. Since embedded message and string objects are immutable, they are shared between the original and the copy. Builders Message objects—such as instances of the Foo class described above—are immutable, just like a Java String. To construct a message object, you need to use a builder. Each message class has its own builder class—so in our Foo example, the protocol buffer compiler generates a nested class Foo.Builder which can be used to build a Foo. Foo.Builder implements the Message.Builder interface. It extends the GeneratedMessage.Builder class, but, again, this should be considered an implementation detail. Like Foo, Foo.Builder may rely on generic method implementations in GeneratedMessage.Builder or, when the optimize_for option is used, generated custom code that is much faster.\nFoo.Builder does not define any static methods. Its interface is exactly as defined by the Message.Builder interface, with the exception that return types are more specific: methods of Foo.Builder that modify the builder return type Foo.Builder, and build() returns type Foo.\nMethods that modify the contents of a builder—including field setters—always return a reference to the builder (i.e. they “return this;”). This allows multiple method calls to be chained together in one line. For example: builder.mergeFrom(obj).setFoo(1).setBar(\"abc\").clearBaz();\nNote that builders are not thread-safe, so Java synchronization should be used whenever it is necessary for multiple different threads to be modifying the contents of a single builder.\nSub-Builders For messages containing sub-messages, the compiler also generates sub-builders. This allows you to repeatedly modify deep-nested sub-messages without rebuilding them. For example:\nmessage Foo { optional int32 val = 1; // some other fields. } message Bar { optional Foo foo = 1; // some other fields. } message Baz { optional Bar bar = 1; // some other fields. } If you have a Baz message already, and want to change the deeply nested val in Foo. Instead of:\nbaz = baz.toBuilder().setBar( baz.getBar().toBuilder().setFoo( baz.getBar().getFoo().toBuilder().setVal(10).build() ).build()).build(); You can write:\nBaz.Builder builder = baz.toBuilder(); builder.getBarBuilder().getFooBuilder().setVal(10); baz = builder.build(); Nested Types A message can be declared inside another message. For example:\nmessage Foo { message Bar { } } In this case, the compiler simply generates Bar as an inner class nested inside Foo.\nFields In addition to the methods described in the previous section, the protocol buffer compiler generates a set of accessor methods for each field defined within the message in the .proto file. The methods that read the field value are defined both in the message class and its corresponding builder; the methods that modify the value are defined in the builder only.\nNote that method names always use camel-case naming, even if the field name in the .proto file uses lower-case with underscores (as it should). The case-conversion works as follows:\nFor each underscore in the name, the underscore is removed, and the following letter is capitalized. If the name will have a prefix attached (e.g. “get”), the first letter is capitalized. Otherwise, it is lower-cased. Thus, the field foo_bar_baz becomes fooBarBaz. If prefixed with get, it would be getFooBarBaz.\nAs well as accessor methods, the compiler generates an integer constant for each field containing its field number. The constant name is the field name converted to upper-case followed by _FIELD_NUMBER. For example, given the field optional int32 foo_bar = 5;, the compiler will generate the constant public static final int FOO_BAR_FIELD_NUMBER = 5;.\nSingular Fields (proto2) For any of these field definitions:\noptional int32 foo = 1; required int32 foo = 1; The compiler will generate the following accessor methods in both the message class and its builder:\nboolean hasFoo(): Returns true if the field is set. int getFoo(): Returns the current value of the field. If the field is not set, returns the default value. The compiler will generate the following methods only in the message’s builder:\nBuilder setFoo(int value): Sets the value of the field. After calling this, hasFoo() will return true and getFoo() will return value. Builder clearFoo(): Clears the value of the field. After calling this, hasFoo() will return false and getFoo() will return the default value. For other simple field types, the corresponding Java type is chosen according to the scalar value types table. For message and enum types, the value type is replaced with the message or enum class.\nEmbedded Message Fields For message types, setFoo() also accepts an instance of the message’s builder type as the parameter. This is just a shortcut which is equivalent to calling .build() on the builder and passing the result to the method.\nIf the field is not set, getFoo() will return a Foo instance with none of its fields set (possibly the instance returned by Foo.getDefaultInstance()).\nIn addition, the compiler generates two accessor methods that allow you to access the relevant sub-builders for message types. The following method is generated in both the message class and its builder:\nFooOrBuilder getFooOrBuilder(): Returns the builder for the field, if it already exists, or the message if not. Calling this method on builders will not create a sub-builder for the field. The compiler generates the following method only in the message’s builder.\nBuilder getFooBuilder(): Returns the builder for the field. Singular Fields (proto3) For this field definition:\nint32 foo = 1; The compiler will generate the following accessor method in both the message class and its builder:\nint getFoo(): Returns the current value of the field. If the field is not set, returns the default value for the field’s type. The compiler will generate the following methods only in the message’s builder:\nBuilder setFoo(int value): Sets the value of the field. After calling this, getFoo() will return value. Builder clearFoo(): Clears the value of the field. After calling this, getFoo() will return the default value for the field’s type. For other simple field types, the corresponding Java type is chosen according to the scalar value types table. For message and enum types, the value type is replaced with the message or enum class.\nEmbedded Message Fields For message field types, an additional accessor method is generated in both the message class and its builder:\nboolean hasFoo(): Returns true if the field has been set. setFoo() also accepts an instance of the message’s builder type as the parameter. This is just a shortcut which is equivalent to calling .build() on the builder and passing the result to the method.\nIf the field is not set, getFoo() will return a Foo instance with none of its fields set (possibly the instance returned by Foo.getDefaultInstance()).\nIn addition, the compiler generates two accessor methods that allow you to access the relevant sub-builders for message types. The following method is generated in both the message class and its builder:\nFooOrBuilder getFooOrBuilder(): Returns the builder for the field, if it already exists, or the message if not. Calling this method on builders will not create a sub-builder for the field. The compiler generates the following method only in the message’s builder.\nBuilder getFooBuilder(): Returns the builder for the field. Enum Fields For enum field types, an additional accessor method is generated in both the message class and its builder:\nint getFooValue(): Returns the integer value of the enum. The compiler will generate the following additional method only in the message’s builder:\nBuilder setFooValue(int value): Sets the integer value of the enum. In addition, getFoo() will return UNRECOGNIZED if the enum value is unknown—this is a special additional value added by the proto3 compiler to the generated enum type.\nRepeated Fields For this field definition:\nrepeated string foos = 1; The compiler will generate the following accessor methods in both the message class and its builder:\nint getFoosCount(): Returns the number of elements currently in the field. String getFoos(int index): Returns the element at the given zero-based index. ProtocolStringList getFoosList(): Returns the entire field as a ProtocolStringList. If the field is not set, returns an empty list. The compiler will generate the following methods only in the message’s builder:\nBuilder setFoos(int index, String value): Sets the value of the element at the given zero-based index. Builder addFoos(String value): Appends a new element to the field with the given value. Builder addAllFoos(Iterable\u003c? extends String\u003e value): Appends all elements in the given Iterable to the field. Builder clearFoos(): Removes all elements from the field. After calling this, getFoosCount() will return zero. For other simple field types, the corresponding Java type is chosen according to the scalar value types table. For message and enum types, the type is the message or enum class.\nRepeated Embedded Message Fields For message types, setFoos() and addFoos() also accept an instance of the message’s builder type as the parameter. This is just a shortcut which is equivalent to calling .build() on the builder and passing the result to the method. There is also an additional generated method:\nBuilder addFoos(int index, Field value): Inserts a new element at the given zero-based index. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). In addition, the compiler generates the following additional accessor methods in both the message class and its builder for message types, allowing you to access the relevant sub-builders:\nFooOrBuilder getFoosOrBuilder(int index): Returns the builder for the specified element, if it already exists, or throws IndexOutOfBoundsException if not. If this is called from a message class, it will always return a message (or throw an exception) rather than a builder. Calling this method on builders will not create a sub-builder for the field. List\u003cFooOrBuilder\u003e getFoosOrBuilderList(): Returns the entire field as an unmodifiable list of builders (if available) or messages if not. If this is called from a message class, it will always return an immutable list of messages rather than an unmodifiable list of builders. The compiler will generate the following methods only in the message’s builder:\nBuilder getFoosBuilder(int index): Returns the builder for the element at the specified index, or throws IndexOutOfBoundsException if the index is out of bounds. Builder addFoosBuilder(int index): Inserts and returns a builder for a default message instance at the specified index. The existing entries are shifted to higher indices to make room for the inserted builder. Builder addFoosBuilder(): Appends and returns a builder for a default message instance. Builder removeFoos(int index): Removes the element at the given zero-based index. List\u003cBuilder\u003e getFoosBuilderList(): Returns the entire field as an unmodifiable list of builders. Repeated Enum Fields (proto3 only) The compiler will generate the following additional methods in both the message class and its builder:\nint getFoosValue(int index): Returns the integer value of the enum at the specified index. List\u003cjava.lang.Integer\u003e getFoosValueList(): Returns the entire field as a list of Integers. The compiler will generate the following additional method only in the message’s builder:\nBuilder setFoosValue(int index, int value): Sets the integer value of the enum at the specified index. Name Conflicts If another non-repeated field has a name that conflicts with one of the repeated field’s generated methods, then both field names will have their protobuf field number appended to the end.\nFor these field definitions:\nint32 foos_count = 1; repeated string foos = 2; The compiler will first rename them to the following:\nint32 foos_count_1 = 1; repeated string foos_2 = 2; The accessor methods will subsequently be generated as described above.\nOneof Fields For this oneof field definition:\noneof example_name { int32 foo = 1; ... } The compiler will generate the following accessor methods in both the message class and its builder:\nboolean hasFoo() (proto2 only): Returns true if the oneof case is FOO. int getFoo(): Returns the current value of example_name if the oneof case is FOO. Otherwise, returns the default value of this field. The compiler will generate the following methods only in the message’s builder:\nBuilder setFoo(int value): Sets example_name to this value and sets the oneof case to FOO. After calling this, hasFoo() will return true, getFoo() will return value and getExampleNameCase() will return FOO. Builder clearFoo(): Nothing will be changed if the oneof case is not FOO. If the oneof case is FOO, sets example_name to null and the oneof case to EXAMPLENAME_NOT_SET. After calling this, hasFoo() will return false, getFoo() will return the default value and getExampleNameCase() will return EXAMPLENAME_NOT_SET. For other simple field types, the corresponding Java type is chosen according to the scalar value types table. For message and enum types, the value type is replaced with the message or enum class.\nMap Fields For this map field definition:\nmap\u003cint32, int32\u003e weight = 1; The compiler will generate the following accessor methods in both the message class and its builder:\nMap\u003cInteger, Integer\u003e getWeightMap();: Returns an unmodifiable Map. int getWeightOrDefault(int key, int default);: Returns the value for key or the default value if not present. int getWeightOrThrow(int key);: Returns the value for key or throws IllegalArgumentException if not present. boolean containsWeight(int key);: Indicates if the key is present in this field. int getWeightCount();: Returns the number of elements in the map. The compiler will generate the following methods only in the message’s builder:\nBuilder putWeight(int key, int value);: Add the weight to this field. Builder putAllWeight(Map\u003cInteger, Integer\u003e value);: Adds all entries in the given map to this field. Builder removeWeight(int key);: Removes the weight from this field. Builder clearWeight();: Removes all weights from this field. @Deprecated Map\u003cInteger, Integer\u003e getMutableWeight();: Returns a mutable Map. Note that multiple calls to this method may return different map instances. The returned map reference may be invalidated by any subsequent method calls to the Builder. Any Given an Any field like this:\nimport \"google/protobuf/any.proto\"; message ErrorStatus { string message = 1; google.protobuf.Any details = 2; } In our generated code, the getter for the details field returns an instance of com.google.protobuf.Any. This provides the following special methods to pack and unpack the Any’s values:\nclass Any { // Packs the given message into an Any using the default type URL // prefix “type.googleapis.com”. public static Any pack(Message message); // Packs the given message into an Any using the given type URL // prefix. public static Any pack(Message message, String typeUrlPrefix); // Checks whether this Any message’s payload is the given type. public \u003cT extends Message\u003e boolean is(class\u003cT\u003e clazz); // Unpacks Any into the given message type. Throws exception if // the type doesn’t match or parsing the payload has failed. public \u003cT extends Message\u003e T unpack(class\u003cT\u003e clazz) throws InvalidProtocolBufferException; } Oneofs Given a oneof definition like this:\noneof example_name { int32 foo_int = 4; string foo_string = 9; ... } All the fields in the example_name oneof will use a single private field for their value. In addition, the protocol buffer compiler will generate a Java enum type for the oneof case, as follows:\npublic enum ExampleNameCase implements com.google.protobuf.Internal.EnumLite { FOO_INT(4), FOO_STRING(9), ... EXAMPLENAME_NOT_SET(0); ... }; The values of this enum type have the following special methods:\nint getNumber(): Returns the object’s numeric value as defined in the .proto file. static ExampleNameCase forNumber(int value): Returns the enum object corresponding to the given numeric value (or null for other numeric values). The compiler will also generate the following accessor method in both the message class and its builder:\nExampleNameCase getExampleNameCase(): Returns the enum indicating which field is set. Returns EXAMPLENAME_NOT_SET if none of them is set. The compiler will generate the following method only in the message’s builder:\nBuilder clearExampleName(): Resets the oneof’s private field to null, and sets the oneof case to EXAMPLENAME_NOT_SET. Enumerations Given an enum definition like:\nenum Foo { VALUE_A = 0; VALUE_B = 5; VALUE_C = 1234; } The protocol buffer compiler will generate a Java enum type called Foo with the same set of values. If you are using proto3, it also adds the special value UNRECOGNIZED to the enum type. The values of the generated enum type have the following special methods:\nint getNumber(): Returns the object’s numeric value as defined in the .proto file. EnumValueDescriptor getValueDescriptor(): Returns the value’s descriptor, which contains information about the value’s name, number, and type. EnumDescriptor getDescriptorForType(): Returns the enum type’s descriptor, which contains e.g. information about each defined value. Additionally, the Foo enum type contains the following static methods:\nstatic Foo forNumber(int value): Returns the enum object corresponding to the given numeric value. Returns null when there is no corresponding enum object. static Foo valueOf(int value): Returns the enum object corresponding to the given numeric value. This method is deprecated in favor of forNumber(int value) and will be removed in an upcoming release. static Foo valueOf(EnumValueDescriptor descriptor): Returns the enum object corresponding to the given value descriptor. May be faster than valueOf(int). In proto3 returns UNRECOGNIZED if passed an unknown value descriptor. EnumDescriptor getDescriptor(): Returns the enum type’s descriptor, which contains e.g. information about each defined value. (This differs from getDescriptorForType() only in that it is a static method.) An integer constant is also generated with the suffix _VALUE for each enum value.\nNote that the .proto language allows multiple enum symbols to have the same numeric value. Symbols with the same numeric value are synonyms. For example:\nenum Foo { BAR = 0; BAZ = 0; } In this case, BAZ is a synonym for BAR. In Java, BAZ will be defined as a static final field like so:\nstatic final Foo BAZ = BAR; Thus, BAR and BAZ compare equal, and BAZ should never appear in switch statements. The compiler always chooses the first symbol defined with a given numeric value to be the “canonical” version of that symbol; all subsequent symbols with the same number are just aliases.\nAn enum can be defined nested within a message type. The compiler generates the Java enum definition nested within that message type’s class.\nCaution: when generating Java code, the maximum number of values in a protobuf enum may be surprisingly low—in the worst case, the maximum is slightly over 1,700 values. This limit is due to per-method size limits for Java bytecode, and it varies across Java implementations, different versions of the protobuf suite, and any options set on the enum in the .proto file.\nExtensions (proto2 only) Given a message with an extension range:\nmessage Foo { extensions 100 to 199; } The protocol buffer compiler will make Foo extend GeneratedMessage.ExtendableMessage instead of the usual GeneratedMessage. Similarly, Foo’s builder will extend GeneratedMessage.ExtendableBuilder. You should never refer to these base types by name (GeneratedMessage is considered an implementation detail). However, these superclasses define a number of additional methods that you can use to manipulate extensions.\nIn particular Foo and Foo.Builder will inherit the methods hasExtension(), getExtension(), and getExtensionCount(). Additionally, Foo.Builder will inherit methods setExtension() and clearExtension(). Each of these methods takes, as its first parameter, an extension identifier (described below), which identifies an extension field. The remaining parameters and the return value are exactly the same as those for the corresponding accessor methods that would be generated for a normal (non-extension) field of the same type as the extension identifier.\nGiven an extension definition:\nextend Foo { optional int32 bar = 123; } The protocol buffer compiler generates an “extension identifier” called bar, which you can use with Foo’s extension accessors to access this extension, like so:\nFoo foo = Foo.newBuilder() .setExtension(bar, 1) .build(); assert foo.hasExtension(bar); assert foo.getExtension(bar) == 1; (The exact implementation of extension identifiers is complicated and involves magical use of generics—however, you don’t need to worry about how extension identifiers work to use them.)\nNote that bar would be declared as a static field of the wrapper class for the .proto file, as described above; we have omitted the wrapper class name in the example.\nExtensions can be declared inside the scope of another type to prefix their generated symbol names. For example, a common pattern is to extend a message by a field inside the declaration of the field’s type:\nmessage Baz { extend Foo { optional Baz foo_ext = 124; } } In this case, an extension with identifier foo_ext and type Baz is declared inside the declaration of Baz, and referring to foo_ext requires the addition of a Baz. prefix:\nBaz baz = createMyBaz(); Foo foo = Foo.newBuilder() .setExtension(Baz.fooExt, baz) .build(); assert foo.hasExtension(Baz.fooExt); assert foo.getExtension(Baz.fooExt) == baz; When parsing a message that might have extensions, you must provide an ExtensionRegistry in which you have registered any extensions that you want to be able to parse. Otherwise, those extensions will be treated like unknown fields and the methods observing extensions will behave as if they don’t exist.\nExtensionRegistry registry = ExtensionRegistry.newInstance(); registry.add(Baz.fooExt); Foo foo = Foo.parseFrom(input, registry); assert foo.hasExtension(Baz.fooExt); ExtensionRegistry registry = ExtensionRegistry.newInstance(); Foo foo = Foo.parseFrom(input, registry); assert foo.hasExtension(Baz.fooExt) == false; Services If the .proto file contains the following line:\noption java_generic_services = true; Then the protocol buffer compiler will generate code based on the service definitions found in the file as described in this section. However, the generated code may be undesirable as it is not tied to any particular RPC system, and thus requires more levels of indirection than code tailored to one system. If you do NOT want this code to be generated, add this line to the file:\noption java_generic_services = false; If neither of the above lines are given, the option defaults to false, as generic services are deprecated. (Note that prior to 2.4.0, the option defaults to true)\nRPC systems based on .proto-language service definitions should provide plugins to generate code approriate for the system. These plugins are likely to require that abstract services are disabled, so that they can generate their own classes of the same names. Plugins are new in version 2.3.0 (January 2010).\nThe remainder of this section describes what the protocol buffer compiler generates when abstract services are enabled.\nInterface Given a service definition:\nservice Foo { rpc Bar(FooRequest) returns(FooResponse); } The protocol buffer compiler will generate an abstract class Foo to represent this service. Foo will have an abstract method for each method defined in the service definition. In this case, the method Bar is defined as:\nabstract void bar(RpcController controller, FooRequest request, RpcCallback\u003cFooResponse\u003e done); The parameters are equivalent to the parameters of Service.CallMethod(), except that the method argument is implied and request and done specify their exact type.\nFoo subclasses the Service interface. The protocol buffer compiler automatically generates implementations of the methods of Service as follows:\ngetDescriptorForType: Returns the service’s ServiceDescriptor. callMethod: Determines which method is being called based on the provided method descriptor and calls it directly, down-casting the request message and callback to the correct types. getRequestPrototype and getResponsePrototype: Returns the default instance of the request or response of the correct type for the given method. The following static method is also generated:\nstatic ServiceDescriptor getServiceDescriptor(): Returns the type’s descriptor, which contains information about what methods this service has and what their input and output types are. Foo will also contain a nested interface Foo.Interface. This is a pure interface that again contains methods corresponding to each method in your service definition. However, this interface does not extend the Service interface. This is a problem because RPC server implementations are usually written to use abstract Service objects, not your particular service. To solve this problem, if you have an object impl implementing Foo.Interface, you can call Foo.newReflectiveService(impl) to construct an instance of Foo that simply delegates to impl, and implements Service.\nTo recap, when implementing your own service, you have two options:\nSubclass Foo and implement its methods as appropriate, then hand instances of your subclass directly to the RPC server implementation. This is usually easiest, but some consider it less “pure”. Implement Foo.Interface and use Foo.newReflectiveService(Foo.Interface) to construct a Service wrapping it, then pass the wrapper to your RPC implementation. Stub The protocol buffer compiler also generates a “stub” implementation of every service interface, which is used by clients wishing to send requests to servers implementing the service. For the Foo service (above), the stub implementation Foo.Stub will be defined as a nested class.\nFoo.Stub is a subclass of Foo which also implements the following methods:\nFoo.Stub(RpcChannel channel): Constructs a new stub which sends requests on the given channel. RpcChannel getChannel(): Returns this stub’s channel, as passed to the constructor. The stub additionally implements each of the service’s methods as a wrapper around the channel. Calling one of the methods simply calls channel.callMethod().\nThe Protocol Buffer library does not include an RPC implementation. However, it includes all of the tools you need to hook up a generated service class to any arbitrary RPC implementation of your choice. You need only provide implementations of RpcChannel and RpcController.\nBlocking Interfaces The RPC classes described above all have non-blocking semantics: when you call a method, you provide a callback object which will be invoked once the method completes. Often it is easier (though possibly less scalable) to write code using blocking semantics, where the method simply doesn’t return until it is done. To accomodate this, the protocol buffer compiler also generates blocking versions of your service class. Foo.BlockingInterface is equivalent to Foo.Interface except that each method simply returns the result rather than call a callback. So, for example, bar is defined as:\nabstract FooResponse bar(RpcController controller, FooRequest request) throws ServiceException; Analogous to non-blocking services, Foo.newReflectiveBlockingService(Foo.BlockingInterface) returns a BlockingService wrapping some Foo.BlockingInterface. Finally, Foo.BlockingStub returns a stub implementation of Foo.BlockingInterface that sends requests to a particular BlockingRpcChannel.\nPlugin Insertion Points Code generator plugins that want to extend the output of the Java code generator may insert code of the following types using the given insertion point names.\nouter_class_scope: Member declarations that belong in the file’s wrapper class. class_scope:TYPENAME: Member declarations that belong in a message class. TYPENAME is the full proto name, e.g. package.MessageType. builder_scope:TYPENAME: Member declarations that belong in a message’s builder class. TYPENAME is the full proto name, e.g. package.MessageType. enum_scope:TYPENAME: Member declarations that belong in an enum class. TYPENAME is the full proto enum name, e.g. package.EnumType. message_implements:TYPENAME: Class implementation declarations for a message class. TYPENAME is the full proto name, e.g. package.MessageType. builder_implements:TYPENAME: Class implementation declarations for a builder class. TYPENAME is the full proto name, e.g. package.MessageType. Generated code cannot contain import statements, as these are prone to conflict with type names defined within the generated code itself. Instead, when referring to an external class, you must always use its fully-qualified name.\nThe logic for determining output file names in the Java code generator is fairly complicated. You should probably look at the protoc source code, particularly java_headers.cc, to make sure you have covered all cases.\nDo not generate code which relies on private class members declared by the standard code generator, as these implementation details may change in future versions of Protocol Buffers.\nUtility Classes Protocol buffer provides utility classes for message comparison, JSON conversion and working with well-known types (predefined protocol buffer messages for common use-cases).\n","categories":"","description":"This topic describes exactly what Java code the protocol buffer compiler generates for any given protocol definition.","excerpt":"This topic describes exactly what Java code the protocol buffer …","ref":"/reference/java/java-generated/","tags":"","title":"Java Generated Code Guide"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/java/api-docs-link/","tags":"","title":"Java API"},{"body":" Kotlin Generated Code Guide Kotlin API ","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in Kotlin","excerpt":"This section contains reference documentation for working with …","ref":"/reference/kotlin/","tags":"","title":"Kotlin Reference"},{"body":"This page describes exactly what Kotlin code the protocol buffer compiler generates for any given protocol definition, in addition to the code generated for Java. Any differences between proto2 and proto3 generated code are highlighted—note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.\nCompiler Invocation The protocol buffer compiler produces Kotlin code that builds on top of Java code. As a result, it must be invoked with two command-line flags, --java_out= and --kotlin_out=. The parameter to the --java_out= option is the directory where you want the compiler to write your Java output, and the same for the --kotlin_out=. For each .proto file input, the compiler creates a wrapper .java file containing a Java class which represents the .proto file itself.\nRegardless of whether or not your .proto file contains a line like the following:\noption java_multiple_files = true; The compiler will create separate .kt files for each of the classes and factory methods which it will generate for each top-level message declared in the .proto file.\nThe Java package name for each file is the same as that used by the generated Java code as described in the Java generated code reference.\nThe output file is chosen by concatenating the parameter to --kotlin_out=, the package name (with periods [.] replaced with slashes [/]), and the suffix Kt.kt file name.\nSo, for example, let’s say you invoke the compiler as follows:\nprotoc --proto_path=src --java_out=build/gen/java --kotlin_out=build/gen/kotlin src/foo.proto If foo.proto’s Java package is com.example and it contains a message named Bar, then the protocol buffer compiler will generate the file build/gen/kotlin/com/example/BarKt.kt. The protocol buffer compiler will automatically create the build/gen/kotlin/com and build/gen/kotlin/com/example directories if needed. However, it will not create build/gen/kotlin, build/gen, or build; they must already exist. You can specify multiple .proto files in a single invocation; all output files will be generated at once.\nMessages Given a simple message declaration:\nmessage FooBar {} The protocol buffer compiler generates—in addition to the generated Java code—an object called FooBarKt, as well as two top-level functions, having the following structure:\nobject FooBarKt { class Dsl private constructor { ... } } inline fun fooBar(block: FooBarKt.Dsl.() -\u003e Unit): FooBar inline fun FooBar.copy(block: FooBarKt.Dsl.() -\u003e Unit): FooBar Nested Types A message can be declared inside another message. For example:\nmessage Foo { message Bar { } } In this case, the compiler nests the BarKt object and the bar factory method inside FooKt, though the copy method remains top-level:\nobject FooKt { class Dsl { ... } object BarKt { class Dsl private constructor { ... } } inline fun bar(block: FooKt.BarKt.Dsl.() -\u003e Unit): Foo.Bar } inline fun foo(block: FooKt.Dsl.() -\u003e Unit): Foo inline fun Foo.copy(block: FooKt.Dsl.() -\u003e Unit): Foo inline fun Foo.Bar.copy(block: FooKt.BarKt.Dsl.() -\u003e Unit): Foo.Bar Fields In addition to the methods described in the previous section, the protocol buffer compiler generates mutable properties in the DSL for each field defined within the message in the .proto file. (Kotlin already infers read-only properties on the message object from the getters generated by Java.)\nNote that properties always use camel-case naming, even if the field name in the .proto file uses lower-case with underscores (as it should). The case-conversion works as follows:\nFor each underscore in the name, the underscore is removed, and the following letter is capitalized. If the name will have a prefix attached (for example, “clear”), the first letter is capitalized. Otherwise, it is lower-cased. Thus, the field foo_bar_baz becomes fooBarBaz.\nIn a few special cases in which a field name conflicts with reserved words in Kotlin or methods already defined in the protobuf library, an extra underscore is appended. For instance, the clearer for a field named in is clearIn_().\nSingular Fields (proto2) For any of these field definitions:\noptional int32 foo = 1; required int32 foo = 1; The compiler will generate the following accessors in the DSL:\nfun hasFoo(): Boolean: Returns true if the field is set. var foo: Int: The current value of the field. If the field is not set, returns the default value. fun clearFoo(): Clears the value of the field. After calling this, hasFoo() will return false and getFoo() will return the default value. For other simple field types, the corresponding Java type is chosen according to the scalar value types table. For message and enum types, the value type is replaced with the message or enum class. As the message type is still defined in Java, unsigned types in the message are represented using the standard corresponding signed types in the DSL, for compatibility with Java and older versions of Kotlin.\nEmbedded Message Fields Note that there is no special handling of submessages. For example, if you have a field\noptional Foo my_foo = 1; you must write\nmyFoo = foo { ... } In general, this is because the compiler does not know whether Foo has a Kotlin DSL at all, or e.g. only has the Java APIs generated. This means that you do not have to wait for messages you depend on to add Kotlin code generation.\nSingular Fields (proto3) For this field definition:\nint32 foo = 1; The compiler will generate the following property in the DSL:\nvar foo: Int: Returns the current value of the field. If the field is not set, returns the default value for the field’s type. fun clearFoo(): Clears the value of the field. After calling this, getFoo() will return the default value for the field’s type. For other simple field types, the corresponding Java type is chosen according to the scalar value types table. For message and enum types, the value type is replaced with the message or enum class. As the message type is still defined in Java, unsigned types in the message are represented using the standard corresponding signed types in the DSL, for compatibility with Java and older versions of Kotlin.\nEmbedded Message Fields For message field types, an additional accessor method is generated in the DSL:\nboolean hasFoo(): Returns true if the field has been set. Note that there is no shortcut for setting a submessage based on a DSL. For example, if you have a field\nFoo my_foo = 1; you must write\nmyFoo = foo { ... } In general, this is because the compiler does not know whether Foo has a Kotlin DSL at all, or e.g. only has the Java APIs generated. This means that you do not have to wait for messages you depend on to add Kotlin code generation.\nRepeated Fields For this field definition:\nrepeated string foo = 1; The compiler will generate the following members in the DSL:\nclass FooProxy: DslProxy, an unconstructable type used only in generics val fooList: DslList\u003cString, FooProxy\u003e, a read-only view of the list of current elements in the repeated field fun DslList\u003cString, FooProxy\u003e.add(value: String), an extension function allowing elements to be added to the repeated field operator fun DslList\u003cString, FooProxy\u003e.plusAssign(value: String), an alias for add fun DslList\u003cString, FooProxy\u003e.addAll(values: Iterable\u003cString\u003e), an extension function allowing an Iterable of elements to be added to the repeated field operator fun DslList\u003cString, FooProxy\u003e.plusAssign(values: Iterable\u003cString\u003e), an alias for addAll operator fun DslList\u003cString, FooProxy\u003e.set(index: Int, value: String), an extension function setting the value of the element at the given zero-based inde fun DslList\u003cString, FooProxy\u003e.clear(), an extension function clearing the contents of the repeated field This unusual construction allows fooList to \"behave like\" a mutable list within the scope of the DSL, supporting only the methods supported by the underlying builder, while preventing mutability from \"escaping\" the DSL, which could cause confusing side effects.\nFor other simple field types, the corresponding Java type is chosen according to the scalar value types table. For message and enum types, the type is the message or enum class.\nOneof Fields For this oneof field definition:\noneof oneof_name { int32 foo = 1; ... } The compiler will generate the following accessor methods in the DSL:\nval oneofNameCase: OneofNameCase: gets which, if any, of the oneof_name fields are set; see the Java code reference for the return type fun hasFoo(): Boolean (proto2 only): Returns true if the oneof case is FOO. val foo: Int: Returns the current value of oneof_name if the oneof case is FOO. Otherwise, returns the default value of this field. For other simple field types, the corresponding Java type is chosen according to the scalar value types table. For message and enum types, the value type is replaced with the message or enum class.\nMap Fields For this map field definition:\nmap\u003cint32, int32\u003e weight = 1; The compiler will generate the following members in the DSL class:\nclass WeightProxy private constructor(): DslProxy(), an unconstructable type used only in generics val weight: DslMap\u003cInt, Int, WeightProxy\u003e, a read-only view of the current entries in the map field fun DslMap\u003cInt, Int, WeightProxy\u003e.put(key: Int, value: Int): add the entry to this map field operator fun DslMap\u003cInt, Int, WeightProxy\u003e.put(key: Int, value: Int): alias for put using operator syntax fun DslMap\u003cInt, Int, WeightProxy\u003e.remove(key: Int): removes the entry associated with key, if present fun DslMap\u003cInt, Int, WeightProxy\u003e.putAll(map: Map\u003cInt, Int\u003e): adds all entries from the specified map to this map field, overwriting prior values for already present keys fun DslMap\u003cInt, Int, WeightProxy\u003e.clear(): clears all entries from this map field Extensions (proto2 only) Given a message with an extension range:\nmessage Foo { extensions 100 to 199; } The protocol buffer compiler will add the following methods to FooKt.Dsl:\noperator fun \u003cT\u003e get(extension: ExtensionLite\u003cFoo, T\u003e): T: gets the current value of the extension field in the DSL operator fun \u003cT\u003e get(extension: ExtensionLite\u003cFoo, List\u003cT\u003e\u003e): ExtensionList\u003cT, Foo\u003e: gets the current value of the repeated extension field in the DSL as a read-only List operator fun \u003cT : Comparable\u003cT\u003e\u003e set(extension: ExtensionLite\u003cFoo, T\u003e): sets the current value of the extension field in the DSL (for Comparable field types) operator fun \u003cT : MessageLite\u003cT\u003e\u003e set(extension: ExtensionLite\u003cFoo, T\u003e): sets the current value of the extension field in the DSL (for message field types) operator fun set(extension: ExtensionLite\u003cFoo, ByteString\u003e): sets the current value of the extension field in the DSL (for bytes fields) operator fun contains(extension: ExtensionLite\u003cFoo, *\u003e): Boolean: returns true if the extension field has a value fun clear(extension: ExtensionLite\u003cFoo, *\u003e): clears the extension field fun \u003cE\u003e ExtensionList\u003cFoo, E\u003e.add(value: E): adds a value to the repeated extension field operator fun \u003cE\u003e ExtensionList\u003cFoo, E\u003e.plusAssign(value: E): alias for add using operator syntax operator fun \u003cE\u003e ExtensionList\u003cFoo, E\u003e.addAll(values: Iterable\u003cE\u003e): adds multiple values to the repeated extension field operator fun \u003cE\u003e ExtensionList\u003cFoo, E\u003e.plusAssign(values: Iterable\u003cE\u003e): alias for addAll using operator syntax operator fun \u003cE\u003e ExtensionList\u003cFoo, E\u003e.set(index: Int, value: E): sets the element of the repeated extension field at the specified index operator fun ExtensionList\u003cFoo, *\u003e.clear(): clears the elements of the repeated extension field The generics here are complex, but the effect is that this[extension] = value works for every extension type except repeated extensions, and repeated extensions have \"natural\" list syntax that works similarly to non-extension repeated fields.\nGiven an extension definition:\nextend Foo { optional int32 bar = 123; } Java generates the \"extension identifier\" bar, which is used to \"key\" extension operations above.\n","categories":"","description":"This topic describes exactly what Kotlin code the protocol buffer compiler generates for any given protocol definition,","excerpt":"This topic describes exactly what Kotlin code the protocol buffer …","ref":"/reference/kotlin/kotlin-generated/","tags":"","title":"Kotlin Generated Code Guide"},{"body":"//protobuf-kotlin\nPackages Name com.google.protobuf.kotlin ","categories":"","description":"The API docs for Kotlin.","excerpt":"The API docs for Kotlin.","ref":"/reference/kotlin/api-docs/","tags":"","title":"Kotlin API"},{"body":" Objective-C Generated Code Guide ","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in Objective-C","excerpt":"This section contains reference documentation for working with …","ref":"/reference/objective-c/","tags":"","title":"Objective-C Reference"},{"body":"This page describes exactly what Objective-C code the protocol buffer compiler generates for any given protocol definition. Any differences between proto2 and proto3 generated code are highlighted. You should read the proto2 language guide and/or proto3 language guide before reading this document.\nCompiler invocation The protocol buffer compiler produces Objective-C output when invoked with the --objc_out= command-line flag. The parameter to the --objc_out= option is the directory where you want the compiler to write your Objective-C output. The compiler creates a header file and an implementation file for each .proto file input. The names of the output files are computed by taking the name of the .proto file and making the following changes:\nThe file name is determined by converting the .proto file base name to camel case. For example, foo_bar.proto will become FooBar. The extension (.proto) is replaced with either pbobjc.h or pbobjc.m for the header or implementation file, respectively. The proto path (specified with the --proto_path= or -I command-line flag) is replaced with the output path (specified with the --objc_out= flag). So, for example, if you invoke the compiler as follows:\nprotoc --proto_path=src --objc_out=build/gen src/foo.proto src/bar/baz.proto The compiler will read the files src/foo.proto and src/bar/baz.proto and produce four output files: build/gen/Foo.pbobjc.h, build/gen/Foo.pbobjc.m, build/gen/bar/Baz.pbobjc.h, and build/gen/bar/Baz.pbobjc.m. The compiler will automatically create the directory build/gen/bar if necessary, but it will not create build or build/gen; they must already exist.\nPackages The Objective-C code generated by the protocol buffer compiler is completely unaffected by the package name defined in the .proto file, as Objective-C has no language-enforced namespacing. Instead, Objective-C class names are distinguished using prefixes, which you can find out about in the next section.\nClass prefix Given the following file option:\noption objc_class_prefix = \"CGOOP\"; The specified string - in this case, CGOOP - is prefixed in front of all Objective-C classes generated for this .proto file. Use prefixes that are 3 or more characters as recommended by Apple. Note that all 2 letter prefixes are reserved by Apple.\nCamel case conversion Idiomatic Objective-C uses camel case for all identifiers.\nMessages will not have their names converted because the standard for proto files is to name messages in camel case already. It is assumed that the user has bypassed the convention for good reason, and the implementation will conform with their intentions.\nMethods generated from field names and oneofs, enum declarations, and extension accessors will have their names camel cased. In general to convert from a proto name to a camel cased Objective-C name:\nThe first letter converted to uppercase (except for fields, which always start with a lowercase letter). For each underscore in the name, the underscore is removed, and the following letter is capitalized. So, for example, the field foo_bar_baz becomes fooBarBaz. The field FOO_bar becomes fooBar.\nMessages Given a simple message declaration:\nmessage Foo {} The protocol buffer compiler generates a class called Foo. If you specify an objc_class_prefix file option, the value of this option is prepended to the generated class name.\nIn the case of outer messages that have names matching any C/C++ or Objective-C keywords:\nmessage static {} the generated interfaces are suffixed by _Class, as follows:\n@interface static_Class {} Note that as per the camel case conversion rules the name static is not converted. In the case of an inner message that has a camel cased name that is FieldNumber or OneOfCase, the generated interface will be the camel cased name suffixed by _Class to make sure that the generated names do not conflict with the FieldNumber enumerations or OneOfCase enumerations.\nA message can also be declared inside another message.\nmessage Foo { message Bar {} } This generates:\n@interface Foo_Bar : GPBMessage @end As you can see, the generated nested message name is the name of the generated containing message name (Foo) appended with underscore (_) and the nested message name (Bar).\nNote: While we have tried to ensure that conflicts are kept to a minimum, there are still potential cases where message names may conflict due to the conversion between underscores and camel case. As an example:\nmessage foo_bar {} message foo { message bar {} } will both generate @interface foo_bar and will conflict. The most pragmatic solution may be to rename the conflicting messages.\nGPBMessage interface GPBMessage is the superclass of all generated message classes. It is required to support a superset of the following interface:\n@interface GPBMessage : NSObject @end The behaviors for this interface are as follows:\n// Will do a deep copy. - (id)copy; // Will perform a deep equality comparison. - (BOOL)isEqual:(id)value; Unknown fields (proto2 only) If a message created with an older version of your .proto definition is parsed with code generated from a newer version (or vice versa), the message may contain optional or repeated fields that the \"new\" code does not recognize. In proto2 generated code, these fields are not discarded and are stored in the message’s unknownFields property.\n@property(nonatomic, copy, nullable) GPBUnknownFieldSet *unknownFields; You can use the GPBUnknownFieldSet interface to fetch these fields by number or loop over them as an array.\nIn proto3, unknown fields are simply discarded when a message is parsed.\nFields The following sections describe the code generated by the protocol buffer compiler for message fields.\nSingular fields (proto3) For every singular field the compiler generates a property to store data and an integer constant containing the field number. Message type fields also get a has.. property that lets you check if the field is set in the encoded message. So, for example, given the following message:\nmessage Foo { message Bar { int32 int32_value = 1; } enum Qux {...} int32 int32_value = 1; string string_value = 2; Bar message_value = 3; Qux enum_value = 4; bytes bytes_value = 5; } The compiler will generate the following:\ntypedef GPB_ENUM(Foo_Bar_FieldNumber) { // The generated field number name is the enclosing message names delimited by // underscores followed by \"FieldNumber\", followed by the field name // camel cased. Foo_Bar_FieldNumber_Int32Value = 1, }; @interface Foo_Bar : GPBMessage @property(nonatomic, readwrite) int32_t int32Value; @end typedef GPB_ENUM(Foo_FieldNumber) { Foo_FieldNumber_Int32Value = 1, Foo_FieldNumber_StringValue = 2, Foo_FieldNumber_MessageValue = 3, Foo_FieldNumber_EnumValue = 4, Foo_FieldNumber_BytesValue = 5, }; typedef GPB_ENUM(Foo_Qux) { Foo_Qux_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue, ... }; @interface Foo : GPBMessage // Field names are camel cased. @property(nonatomic, readwrite) int32_t int32Value; @property(nonatomic, readwrite, copy, null_resettable) NSString *stringValue; @property(nonatomic, readwrite) BOOL hasMessageValue; @property(nonatomic, readwrite, strong, null_resettable) Foo_Bar *messageValue; @property(nonatomic, readwrite) Foo_Qux enumValue; @property(nonatomic, readwrite, copy, null_resettable) NSData *bytesValue; @end Special naming cases There are cases where the field name generation rules may result in name conflicts and names will need to be \"uniqued\". Such conflicts are resolved by appending _p to the end of the field (_p was selected because it’s pretty unique, and stands for \"property\").\nmessage Foo { int32 foo_array = 1; // Ends with Array int32 bar_OneOfCase = 2; // Ends with oneofcase int32 id = 3; // Is a C/C++/Objective-C keyword } generates:\ntypedef GPB_ENUM(Foo_FieldNumber) { // If a non-repeatable field name ends with \"Array\" it will be suffixed // with \"_p\" to keep the name distinct from repeated types. Foo_FieldNumber_FooArray_p = 1, // If a field name ends with \"OneOfCase\" it will be suffixed with \"_p\" to // keep the name distinct from OneOfCase properties. Foo_FieldNumber_BarOneOfCase_p = 2, // If a field name is a C/C++/ObjectiveC keyword it will be suffixed with // \"_p\" to allow it to compile. Foo_FieldNumber_Id_p = 3, }; @interface Foo : GPBMessage @property(nonatomic, readwrite) int32_t fooArray_p; @property(nonatomic, readwrite) int32_t barOneOfCase_p; @property(nonatomic, readwrite) int32_t id_p; @end Default values The default value for numeric types is 0.\nThe default value for strings is @\"\", and the default value for bytes is [NSData data].\nAssigning nil to a string field will assert in debug, and set the field to @\"\" in release. Assigning nil to a bytes field will assert in debug and set the field to [NSData data] in release. To test whether a bytes or string field is set requires testing its length property and comparing it to 0.\nThe default \"empty\" value for a message is an instance of the default message. To clear a message value it should be set to nil. Accessing a cleared message will return an instance of the default message and the hasFoo method will return false.\nThe default message returned for a field is a local instance. The reason behind returning a default message instead of nil is that in the case of:\nmessage Foo { message Bar { int32 b; } Bar a; } The implementation will support:\nFoo *foo = [[Foo alloc] init]; foo.a.b = 2; where a will be automatically created via the accessors if necessary. If foo.a returned nil, the foo.a.b setter pattern would not work.\nSingular fields (proto2) For every singular field the compiler generates a property to store data, an integer constant containing the field number, and a has.. property that lets you check if the field is set in the encoded message. So, for example, given the following message:\nmessage Foo { message Bar { int32 int32_value = 1; } enum Qux {...} optional int32 int32_value = 1; optional string string_value = 2; optional Bar message_value = 3; optional Qux enum_value = 4; optional bytes bytes_value = 5; } The compiler will generate the following:\n# Enum Foo_Qux typedef GPB_ENUM(Foo_Qux) { Foo_Qux_Flupple = 0, }; GPBEnumDescriptor *Foo_Qux_EnumDescriptor(void); BOOL Foo_Qux_IsValidValue(int32_t value); # Message Foo typedef GPB_ENUM(Foo_FieldNumber) { Foo_FieldNumber_Int32Value = 2, Foo_FieldNumber_MessageValue = 3, Foo_FieldNumber_EnumValue = 4, Foo_FieldNumber_BytesValue = 5, Foo_FieldNumber_StringValue = 6, }; @interface Foo : GPBMessage @property(nonatomic, readwrite) BOOL hasInt32Value; @property(nonatomic, readwrite) int32_t int32Value; @property(nonatomic, readwrite) BOOL hasStringValue; @property(nonatomic, readwrite, copy, null_resettable) NSString *stringValue; @property(nonatomic, readwrite) BOOL hasMessageValue; @property(nonatomic, readwrite, strong, null_resettable) Foo_Bar *messageValue; @property(nonatomic, readwrite) BOOL hasEnumValue; @property(nonatomic, readwrite) Foo_Qux enumValue; @property(nonatomic, readwrite) BOOL hasBytesValue; @property(nonatomic, readwrite, copy, null_resettable) NSData *bytesValue; @end # Message Foo_Bar typedef GPB_ENUM(Foo_Bar_FieldNumber) { Foo_Bar_FieldNumber_Int32Value = 1, }; @interface Foo_Bar : GPBMessage @property(nonatomic, readwrite) BOOL hasInt32Value; @property(nonatomic, readwrite) int32_t int32Value; @end Special naming cases There are cases where the field name generation rules may result in name conflicts and names will need to be \"uniqued\". Such conflicts are resolved by appending _p to the end of the field (_p was selected because it’s pretty unique, and stands for \"property\").\nmessage Foo { optional int32 foo_array = 1; // Ends with Array optional int32 bar_OneOfCase = 2; // Ends with oneofcase optional int32 id = 3; // Is a C/C++/Objective-C keyword } generates:\ntypedef GPB_ENUM(Foo_FieldNumber) { // If a non-repeatable field name ends with \"Array\" it will be suffixed // with \"_p\" to keep the name distinct from repeated types. Foo_FieldNumber_FooArray_p = 1, // If a field name ends with \"OneOfCase\" it will be suffixed with \"_p\" to // keep the name distinct from OneOfCase properties. Foo_FieldNumber_BarOneOfCase_p = 2, // If a field name is a C/C++/ObjectiveC keyword it will be suffixed with // \"_p\" to allow it to compile. Foo_FieldNumber_Id_p = 3, }; @interface Foo : GPBMessage @property(nonatomic, readwrite) int32_t fooArray_p; @property(nonatomic, readwrite) int32_t barOneOfCase_p; @property(nonatomic, readwrite) int32_t id_p; @end Default values (optional fields only) The default value for numeric types, if no explicit default was specified by the user, is 0.\nThe default value for strings is @\"\", and the default value for bytes is [NSData data].\nAssigning nil to a string field will assert in debug, and set the field to @\"\" in release. Assigning nil to a bytes field will assert in debug and set the field to [NSData data] in release. To test whether a bytes or string field is set requires testing its length property and comparing it to 0.\nThe default \"empty\" value for a message is an instance of the default message. To clear a message value it should be set to nil. Accessing a cleared message will return an instance of the default message and the hasFoo method will return false.\nThe default message returned for a field is a local instance. The reason behind returning a default message instead of nil is that in the case of:\nmessage Foo { message Bar { int32 b; } Bar a; } The implementation will support:\nFoo *foo = [[Foo alloc] init]; foo.a.b = 2; where a will be automatically created via the accessors if necessary. If foo.a returned nil, the foo.a.b setter pattern would not work.\nRepeated fields Like singular fields(proto2 proto3), the protocol buffer compiler generates one data property for each repeated field. This data property is a GPB\u003cVALUE\u003eArray depending on the field type where \u003cVALUE\u003e can be one of UInt32, Int32, UInt64, Int64, Bool, Float, Double, or Enum. NSMutableArray will be used for string, bytes and message types. Field names for repeated types have Array appended to them. The reason for appending Array in the Objective-C interface is to make the code more readable. Repeated fields in proto files tend to have singular names which do not read well in standard Objective-C usage. Making the singular names plural would be more idiomatic Objective-C, however pluralization rules are too complex to support in the compiler.\nmessage Foo { message Bar {} enum Qux {} repeated int32 int32_value = 1; repeated string string_value = 2; repeated Bar message_value = 3; repeated Qux enum_value = 4; } generates:\ntypedef GPB_ENUM(Foo_FieldNumber) { Foo_FieldNumber_Int32ValueArray = 1, Foo_FieldNumber_StringValueArray = 2, Foo_FieldNumber_MessageValueArray = 3, Foo_FieldNumber_EnumValueArray = 4, }; @interface Foo : GPBMessage // Field names for repeated types are the camel case name with // \"Array\" suffixed. @property(nonatomic, readwrite, strong, null_resettable) GPBInt32Array *int32ValueArray; @property(nonatomic, readonly) NSUInteger int32ValueArray_Count; @property(nonatomic, readwrite, strong, null_resettable) NSMutableArray *stringValueArray; @property(nonatomic, readonly) NSUInteger stringValueArray_Count; @property(nonatomic, readwrite, strong, null_resettable) NSMutableArray *messageValueArray; @property(nonatomic, readonly) NSUInteger messageValueArray_Count; @property(nonatomic, readwrite, strong, null_resettable) GPBEnumArray *enumValueArray; @property(nonatomic, readonly) NSUInteger enumValueArray_Count; @end For string, bytes and message fields, elements of the array are NSString*, NSData* and pointers to subclasses of GPBMessage respectively.\nDefault values The default value for a repeated field is to be empty. In Objective-C generated code, this is an empty GPB\u003cVALUE\u003eArray. If you access an empty repeated field, you’ll get back an empty array that you can update like any other repeated field array.\nFoo *myFoo = [[Foo alloc] init]; [myFoo.stringValueArray addObject:@\"A string\"] You can also use the provided \u003cfield\u003eArray_Count property to check if the array for a particular repeated field is empty without having to create the array:\nif (myFoo.messageValueArray_Count) { // There is something in the array... } GPB\u003cVALUE\u003eArray interface GPB\u003cVALUE\u003eArrays (aside from GPBEnumArray, which we’ll look at below) have the following interface:\n@interface GPBArray : NSObject @property (nonatomic, readonly) NSUInteger count; + (instancetype)array; + (instancetype)arrayWithValue:()value; + (instancetype)arrayWithValueArray:(GPBArray *)array; + (instancetype)arrayWithCapacity:(NSUInteger)count; // Initializes the array, copying the values. - (instancetype)initWithValueArray:(GPBArray *)array; - (instancetype)initWithValues:(const [])values count:(NSUInteger)count NS_DESIGNATED_INITIALIZER; - (instancetype)initWithCapacity:(NSUInteger)count; - ()valueAtIndex:(NSUInteger)index; - (void)enumerateValuesWithBlock: (void (^)( value, NSUInteger idx, BOOL *stop))block; - (void)enumerateValuesWithOptions:(NSEnumerationOptions)opts usingBlock:(void (^)( value, NSUInteger idx, BOOL *stop))block; - (void)addValue:()value; - (void)addValues:(const [])values count:(NSUInteger)count; - (void)addValuesFromArray:(GPBArray *)array; - (void)removeValueAtIndex:(NSUInteger)count; - (void)removeAll; - (void)exchangeValueAtIndex:(NSUInteger)idx1 withValueAtIndex:(NSUInteger)idx2; - (void)insertValue:()value atIndex:(NSUInteger)count; - (void)replaceValueAtIndex:(NSUInteger)index withValue:()value; @end GPBEnumArray has a slightly different interface to handle the validation function and to access raw values.\n@interface GPBEnumArray : NSObject @property (nonatomic, readonly) NSUInteger count; @property (nonatomic, readonly) GPBEnumValidationFunc validationFunc; + (instancetype)array; + (instancetype)arrayWithValidationFunction:(nullable GPBEnumValidationFunc)func; + (instancetype)arrayWithValidationFunction:(nullable GPBEnumValidationFunc)func rawValue:value; + (instancetype)arrayWithValueArray:(GPBEnumArray *)array; + (instancetype)arrayWithValidationFunction:(nullable GPBEnumValidationFunc)func capacity:(NSUInteger)count; - (instancetype)initWithValidationFunction: (nullable GPBEnumValidationFunc)func; // Initializes the array, copying the values. - (instancetype)initWithValueArray:(GPBEnumArray *)array; - (instancetype)initWithValidationFunction:(nullable GPBEnumValidationFunc)func values:(const int32_t [])values count:(NSUInteger)count NS_DESIGNATED_INITIALIZER; - (instancetype)initWithValidationFunction:(nullable GPBEnumValidationFunc)func capacity:(NSUInteger)count; // These will return kGPBUnrecognizedEnumeratorValue if the value at index // is not a valid enumerator as defined by validationFunc. If the actual // value is desired, use the \"raw\" version of the method. - (int32_t)valueAtIndex:(NSUInteger)index; - (void)enumerateValuesWithBlock: (void (^)(int32_t value, NSUInteger idx, BOOL *stop))block; - (void)enumerateValuesWithOptions:(NSEnumerationOptions)opts usingBlock:(void (^)(int32_t value, NSUInteger idx, BOOL *stop))block; // These methods bypass the validationFunc to provide access to values // that were not known at the time the binary was compiled. - (int32_t)rawValueAtIndex:(NSUInteger)index; - (void)enumerateRawValuesWithBlock: (void (^)(int32_t value, NSUInteger idx, BOOL *stop))block; - (void)enumerateRawValuesWithOptions:(NSEnumerationOptions)opts usingBlock:(void (^)(int32_t value, NSUInteger idx, BOOL *stop))block; // If value is not a valid enumerator as defined by validationFunc, these // methods will assert in debug, and will log in release and assign the value // to the default value. Use the rawValue methods below to assign // non enumerator values. - (void)addValue:(int32_t)value; - (void)addValues:(const int32_t [])values count:(NSUInteger)count; - (void)insertValue:(int32_t)value atIndex:(NSUInteger)count; - (void)replaceValueAtIndex:(NSUInteger)index withValue:(int32_t)value; // These methods bypass the validationFunc to provide setting of values that // were not known at the time the binary was compiled. - (void)addRawValue:(int32_t)rawValue; - (void)addRawValuesFromEnumArray:(GPBEnumArray *)array; - (void)addRawValues:(const int32_t [])values count:(NSUInteger)count; - (void)replaceValueAtIndex:(NSUInteger)index withRawValue:(int32_t)rawValue; - (void)insertRawValue:(int32_t)value atIndex:(NSUInteger)count; // No validation applies to these methods. - (void)removeValueAtIndex:(NSUInteger)count; - (void)removeAll; - (void)exchangeValueAtIndex:(NSUInteger)idx1 withValueAtIndex:(NSUInteger)idx2; @end Oneof fields Given a message with oneof field definitions:\nmessage Order { oneof OrderID { string name = 1; int32 address = 2; }; int32 quantity = 3; }; The protocol buffer compiler generates:\ntypedef GPB_ENUM(Order_OrderID_OneOfCase) { Order_OrderID_OneOfCase_GPBUnsetOneOfCase = 0, Order_OrderID_OneOfCase_Name = 1, Order_OrderID_OneOfCase_Address = 2, }; typedef GPB_ENUM(Order_FieldNumber) { Order_FieldNumber_Name = 1, Order_FieldNumber_Address = 2, Order_FieldNumber_Quantity = 3, }; @interface Order : GPBMessage @property (nonatomic, readwrite) Order_OrderID_OneOfCase orderIDOneOfCase; @property (nonatomic, readwrite, copy, null_resettable) NSString *name; @property (nonatomic, readwrite) int32_t address; @property (nonatomic, readwrite) int32_t quantity; @end void Order_ClearOrderIDOneOfCase(Order *message); Setting one of the oneof properties will clear all the other properties associated with the oneof.\n\u003cONE_OF_NAME\u003e_OneOfCase_GPBUnsetOneOfCase will always be equivalent to 0 to allow for easy testing to see if any field in the oneof is set.\nMap Fields For this message definition:\nmessage Bar {...} message Foo { map\u003cint32, string\u003e a_map = 1; map\u003cstring, Bar\u003e b_map = 2; }; The compiler generates the following:\ntypedef GPB_ENUM(Foo_FieldNumber) { Foo_FieldNumber_AMap = 1, Foo_FieldNumber_BMap = 2, }; @interface Foo : GPBMessage // Map names are the camel case version of the field name. @property (nonatomic, readwrite, strong, null_resettable) GPBInt32ObjectDictionary *aMap; @property(nonatomic, readonly) NSUInteger aMap_Count; @property (nonatomic, readwrite, strong, null_resettable) NSMutableDictionary *bMap; @property(nonatomic, readonly) NSUInteger bMap_Count; @end Cases where keys are strings and values are strings, bytes, or messages are handled by NSMutableDictionary.\nOther cases are:\nGBP\u003cKEY\u003e\u003cVALUE\u003eDictionary where:\n\u003cKEY\u003e is Uint32, Int32, UInt64, Int64, Bool or String. \u003cVALUE\u003e is UInt32, Int32, UInt64, Int64, Bool, Float, Double, Enum, or Object. Object is used for values of type string bytes or message to cut down on the number of classes and is in line with how Objective-C works with NSMutableDictionary. Default values The default value for a map field is empty. In Objective-C generated code, this is an empty GBP\u003cKEY\u003e\u003cVALUE\u003eDictionary. If you access an empty map field, you’ll get back an empty dictionary that you can update like any other map field.\nYou can also use the provided \u003cmapField\u003e_Count property to check if a particular map is empty:\nif (myFoo.myMap_Count) { // There is something in the map... } GBP\u003cKEY\u003e\u003cVALUE\u003eDictionary interface The GBP\u003cKEY\u003e\u003cVALUE\u003eDictionary (apart from GBP\u003cKEY\u003eObjectDictionary and GBP\u003cKEY\u003eEnumDictionary) interface is as follows:\n@interface GPB\u003cKEY\u003eDictionary : NSObject @property (nonatomic, readonly) NSUInteger count; + (instancetype)dictionary; + (instancetype)dictionaryWithValue:(const )value forKey:(const \u003cKEY\u003e)key; + (instancetype)dictionaryWithValues:(const [])values forKeys:(const \u003cKEY\u003e [])keys count:(NSUInteger)count; + (instancetype)dictionaryWithDictionary:(GPB\u003cKEY\u003eDictionary *)dictionary; + (instancetype)dictionaryWithCapacity:(NSUInteger)numItems; - (instancetype)initWithValues:(const [])values forKeys:(const \u003cKEY\u003e [])keys count:(NSUInteger)count NS_DESIGNATED_INITIALIZER; - (instancetype)initWithDictionary:(GPB\u003cKEY\u003eDictionary *)dictionary; - (instancetype)initWithCapacity:(NSUInteger)numItems; - (BOOL)valueForKey:(\u003cKEY\u003e)key value:(VALUE *)value; - (void)enumerateKeysAndValuesUsingBlock: (void (^)(\u003cKEY\u003e key, value, BOOL *stop))block; - (void)removeValueForKey:(\u003cKEY\u003e)aKey; - (void)removeAll; - (void)setValue:()value forKey:(\u003cKEY\u003e)key; - (void)addEntriesFromDictionary:(GPB\u003cKEY\u003eDictionary *)otherDictionary; @end The GBP\u003cKEY\u003eObjectDictionary interface is:\n@interface GPB\u003cKEY\u003eObjectDictionary : NSObject @property (nonatomic, readonly) NSUInteger count; + (instancetype)dictionary; + (instancetype)dictionaryWithObject:(id)object forKey:(const \u003cKEY\u003e)key; + (instancetype) dictionaryWithObjects:(const id GPB_UNSAFE_UNRETAINED [])objects forKeys:(const \u003cKEY\u003e [])keys count:(NSUInteger)count; + (instancetype)dictionaryWithDictionary:(GPB\u003cKEY\u003eObjectDictionary *)dictionary; + (instancetype)dictionaryWithCapacity:(NSUInteger)numItems; - (instancetype)initWithObjects:(const id GPB_UNSAFE_UNRETAINED [])objects forKeys:(const \u003cKEY\u003e [])keys count:(NSUInteger)count NS_DESIGNATED_INITIALIZER; - (instancetype)initWithDictionary:(GPB\u003cKEY\u003eObjectDictionary *)dictionary; - (instancetype)initWithCapacity:(NSUInteger)numItems; - (id)objectForKey:(uint32_t)key; - (void)enumerateKeysAndObjectsUsingBlock: (void (^)(\u003cKEY\u003e key, id object, BOOL *stop))block; - (void)removeObjectForKey:(\u003cKEY\u003e)aKey; - (void)removeAll; - (void)setObject:(id)object forKey:(\u003cKEY\u003e)key; - (void)addEntriesFromDictionary:(GPB\u003cKEY\u003eObjectDictionary *)otherDictionary; @end GBP\u003cKEY\u003eEnumDictionary has a slightly different interface to handle the validation function and to access raw values.\n@interface GPB\u003cKEY\u003eEnumDictionary : NSObject @property(nonatomic, readonly) NSUInteger count; @property(nonatomic, readonly) GPBEnumValidationFunc validationFunc; + (instancetype)dictionary; + (instancetype)dictionaryWithValidationFunction:(nullable GPBEnumValidationFunc)func; + (instancetype)dictionaryWithValidationFunction:(nullable GPBEnumValidationFunc)func rawValue:(int32_t)rawValue forKey:(\u003cKEY\u003e_t)key; + (instancetype)dictionaryWithValidationFunction:(nullable GPBEnumValidationFunc)func rawValues:(const int32_t [])values forKeys:(const \u003cKEY\u003e_t [])keys count:(NSUInteger)count; + (instancetype)dictionaryWithDictionary:(GPB\u003cKEY\u003eEnumDictionary *)dictionary; + (instancetype)dictionaryWithValidationFunction:(nullable GPBEnumValidationFunc)func capacity:(NSUInteger)numItems; - (instancetype)initWithValidationFunction:(nullable GPBEnumValidationFunc)func; - (instancetype)initWithValidationFunction:(nullable GPBEnumValidationFunc)func rawValues:(const int32_t [])values forKeys:(const \u003cKEY\u003e_t [])keys count:(NSUInteger)count NS_DESIGNATED_INITIALIZER; - (instancetype)initWithDictionary:(GPB\u003cKEY\u003eEnumDictionary *)dictionary; - (instancetype)initWithValidationFunction:(nullable GPBEnumValidationFunc)func capacity:(NSUInteger)numItems; // These will return kGPBUnrecognizedEnumeratorValue if the value for the key // is not a valid enumerator as defined by validationFunc. If the actual value is // desired, use \"raw\" version of the method. - (BOOL)valueForKey:(\u003cKEY\u003e_t)key value:(nullable int32_t *)value; - (void)enumerateKeysAndValuesUsingBlock: (void (^)(\u003cKEY\u003e_t key, int32_t value, BOOL *stop))block; // These methods bypass the validationFunc to provide access to values that were not // known at the time the binary was compiled. - (BOOL)valueForKey:(\u003cKEY\u003e_t)key rawValue:(nullable int32_t *)rawValue; - (void)enumerateKeysAndRawValuesUsingBlock: (void (^)(\u003cKEY\u003e_t key, int32_t rawValue, BOOL *stop))block; - (void)addRawEntriesFromDictionary:(GPB\u003cKEY\u003eEnumDictionary *)otherDictionary; // If value is not a valid enumerator as defined by validationFunc, these // methods will assert in debug, and will log in release and assign the value // to the default value. Use the rawValue methods below to assign non enumerator // values. - (void)setValue:(int32_t)value forKey:(\u003cKEY\u003e_t)key; // This method bypass the validationFunc to provide setting of values that were not // known at the time the binary was compiled. - (void)setRawValue:(int32_t)rawValue forKey:(\u003cKEY\u003e_t)key; // No validation applies to these methods. - (void)removeValueForKey:(\u003cKEY\u003e_t)aKey; - (void)removeAll; @end Enumerations Given an enum definition like:\nenum Foo { VALUE_A = 0; VALUE_B = 1; VALUE_C = 5; } the generated code will be:\n// The generated enum value name will be the enumeration name followed by // an underscore and then the enumerator name converted to camel case. // GPB_ENUM is a macro defined in the Objective-C Protocol Buffer headers // that enforces all enum values to be int32 and aids in Swift Enumeration // support. typedef GPB_ENUM(Foo) { Foo_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue, //proto3 only Foo_ValueA = 0, Foo_ValueB = 1; Foo_ValueC = 5; }; // Returns information about what values this enum type defines. GPBEnumDescriptor *Foo_EnumDescriptor(); Each enumeration has a validation function declared for it:\n// Returns YES if the given numeric value matches one of Foo's // defined values (0, 1, 5). BOOL Foo_IsValidValue(int32_t value); and an enumeration descriptor accessor function declared for it:\n// GPBEnumDescriptor is defined in the runtime and contains information // about the enum definition, such as the enum name, enum value and enum value // validation function. typedef GPBEnumDescriptor *(*GPBEnumDescriptorAccessorFunc)(); The enum descriptor accessor functions are C functions, as opposed to methods on the enumeration class, because they are rarely used by client software. This will cut down on the amount of Objective-C runtime information generated, and potentially allow the linker to deadstrip them.\nIn the case of outer enums that have names matching any C/C++ or Objective-C keywords, such as:\nenum method {} the generated interfaces are suffixed with _Enum, as follows:\n// The generated enumeration name is the keyword suffixed by _Enum. typedef GPB_ENUM(Method_Enum) {} An enum can also be declared inside another message. For example:\nmessage Foo { enum Bar { VALUE_A = 0; VALUE_B = 1; VALUE_C = 5; } Bar aBar = 1; Bar aDifferentBar = 2; repeated Bar aRepeatedBar = 3; } generates:\ntypedef GPB_ENUM(Foo_Bar) { Foo_Bar_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue, //proto3 only Foo_Bar_ValueA = 0; Foo_Bar_ValueB = 1; Foo_Bar_ValueC = 5; }; GPBEnumDescriptor *Foo_Bar_EnumDescriptor(); BOOL Foo_Bar_IsValidValue(int32_t value); @interface Foo : GPBMessage @property (nonatomic, readwrite) Foo_Bar aBar; @property (nonatomic, readwrite) Foo_Bar aDifferentBar; @property (nonatomic, readwrite, strong, null_resettable) GPBEnumArray *aRepeatedBarArray; @end // proto3 only Every message that has an enum field will have an accessor function to get // the value of that enum as an integer. This allows clients to deal with // raw values if they need to. int32_t Foo_ABar_RawValue(Foo *message); void SetFoo_ABar_RawValue(Foo *message, int32_t value); int32_t Foo_ADifferentBar_RawValue(Foo *message); void SetFoo_ADifferentBar_RawValue(Foo *message, int32_t value); All enumeration fields have the ability to access the value as a typed enumerator (Foo_Bar in the example above), or, if using proto3, as a raw int32_t value (using the accessor functions in the example above). This is to support the case where the server returns values that the client may not recognize due to the client and server being compiled with different versions of the proto file.\nUnrecognized enum values are treated differently depending on which protocol buffers version you are using. In proto3, kGPBUnrecognizedEnumeratorValue is returned for the typed enumerator value if the enumerator value in the parsed message data is not one that the code reading it was compiled to support. If the actual value is desired, use the raw value accessors to get the value as an int32_t. If you are using proto2, unrecognized enum values are treated as unknown fields.\nkGPBUnrecognizedEnumeratorValue is defined as 0xFBADBEEF, and it will be an error if any enumerator in an enumeration has this value. Attempting to set any enumeration field to this value is a runtime error. Similarly, attempting to set any enumeration field to an enumerator not defined by its enumeration type using the typed accessors is a runtime error. In both error cases, debug builds will cause an assertion and release builds will log and set the field to its default value (0).\nThe raw value accessors are defined as C functions instead of as Objective-C methods because they are not used in most cases. Declaring them as C functions cuts down on wasted Objective-C runtime information and allows the linker to potentially dead strip them.\nSwift Enumeration Support Apple documents how they import Objective-C enumerations to Swift enumerations in Interacting with C APIs. Protocol buffer-generated enumerations support Objective-C to Swift conversions.\n// Proto enum Foo { VALUE_A = 0; } generates:\n// Objective-C typedef GPB_ENUM(Foo) { Foo_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue, Foo_ValueA = 0, }; which in Swift code will allow:\n// Swift let aValue = Foo.ValueA let anotherValue: Foo = .GPBUnrecognizedEnumeratorValue Well-known types (proto3 only) If you use any of the message types provided with proto3, they will in general just use their proto definitions in generated Objective-C code, though we supply some basic conversion methods in categories to make using them simpler. Note that we do not have special APIs for all well-known types yet, including Any (there is currently no helper method to convert an Any’s message value into a message of the appropriate type).\nTime Stamps @interface GPBTimeStamp (GPBWellKnownTypes) @property (nonatomic, readwrite, strong) NSDate *date; @property (nonatomic, readwrite) NSTimeInterval timeIntervalSince1970; - (instancetype)initWithDate:(NSDate *)date; - (instancetype)initWithTimeIntervalSince1970: (NSTimeInterval)timeIntervalSince1970; @end Duration @interface GPBDuration (GPBWellKnownTypes) @property (nonatomic, readwrite) NSTimeInterval timeIntervalSince1970; - (instancetype)initWithTimeIntervalSince1970: (NSTimeInterval)timeIntervalSince1970; @end Extensions (proto2 only) Given a message with an extension range:\nmessage Foo { extensions 100 to 199; } extend Foo { optional int32 foo = 101; repeated int32 repeated_foo = 102; } message Bar { extend Foo { optional int32 bar = 103; repeated int32 repeated_bar = 104; } } The compiler generates the following:\n# File Test2Root @interface Test2Root : GPBRootObject // The base class provides: // + (GPBExtensionRegistry *)extensionRegistry; // which is an GPBExtensionRegistry that includes all the extensions defined by // this file and all files that it depends on. @end @interface Test2Root (DynamicMethods) + (GPBExtensionDescriptor *)foo; + (GPBExtensionDescriptor *)repeatedFoo; @end # Message Foo @interface Foo : GPBMessage @end # Message Bar @interface Bar : GPBMessage @end @interface Bar (DynamicMethods) + (GPBExtensionDescriptor *)bar; + (GPBExtensionDescriptor *)repeatedBar; @end To get and set these extension fields, you use the following:\nFoo *fooMsg = [[Foo alloc] init]; // Set the single field extensions [fooMsg setExtension:[Test2Root foo] value:@5]; NSAssert([fooMsg hasExtension:[Test2Root foo]]); NSAssert([[fooMsg getExtension:[Test2Root foo]] intValue] == 5); // Add two things to the repeated extension: [fooMsg addExtension:[Test2Root repeatedFoo] value:@1]; [fooMsg addExtension:[Test2Root repeatedFoo] value:@2]; NSAssert([fooMsg hasExtension:[Test2Root repeatedFoo]]); NSAssert([[fooMsg getExtension:[Test2Root repeatedFoo]] count] == 2); // Clearing [fooMsg clearExtension:[Test2Root foo]]; [fooMsg clearExtension:[Test2Root repeatedFoo]]; NSAssert(![fooMsg hasExtension:[Test2Root foo]]); NSAssert(![fooMsg hasExtension:[Test2Root repeatedFoo]]); ","categories":"","description":"This topic describes exactly what Objective-C code the protocol buffer compiler generates for any given protocol definition.","excerpt":"This topic describes exactly what Objective-C code the protocol buffer …","ref":"/reference/objective-c/objective-c-generated/","tags":"","title":"Objective-C Generated Code Guide"},{"body":" PHP Generated Code Guide PHP API ","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in PHP","excerpt":"This section contains reference documentation for working with …","ref":"/reference/php/","tags":"","title":"PHP Reference"},{"body":"This page describes the PHP code that the protocol buffer compiler generates for any given protocol definition. You should read the proto3 language guide before reading this document. Note that the protocol buffer compiler currently only supports proto3 code generation for PHP.\nCompiler Invocation The protocol buffer compiler produces PHP output when invoked with the --php_out= command-line flag. The parameter to the --php_out= option is the directory where you want the compiler to write your PHP output. In order to conform to PSR-4, the compiler creates a sub-directory corresponding to the package defined in the proto file. In addition, for each message in the proto file input the compiler creates a separate file in the package’s subdirectory. The names of the output files of messages are composed of three parts:\nBase directory: The proto path (specified with the --proto_path= or -I command-line flag) is replaced with the output path (specified with the --php_out= flag). Sub-directory: . in the package name are replaced by the operating system directory separator. Each package name component is capitalized. File: The message name is appended by .php. So, for example, let’s say you invoke the compiler as follows:\nprotoc --proto_path=src --php_out=build/gen src/example.proto And src/example.proto is defined as:\npackage foo.bar; message MyMessage {} The compiler will read the files src/foo.proto and produce the output file: build/gen/Foo/Bar/MyMessage.php. The compiler will automatically create the directory build/gen/Foo/Bar if necessary, but it will not create build or build/gen; they must already exist.\nPackages The package name defined in the .proto file is used to generate a module structure for the generated PHP classes. Given a file like:\npackage foo.bar; message MyMessage {} The protocol compiler generates an output class with the name Foo\\Bar\\MyMessage.\nMessages Given a simple message declaration:\nmessage Foo {} The protocol buffer compiler generates a PHP class called Foo. This class inherits from a common base class, Google\\Protobuf\\Internal\\Message, which provides methods for encoding and decoding your message types, as shown in the following example:\n$from = new Foo(); $from-\u003esetInt32(1); $from-\u003esetString('a'); $from-\u003egetRepeatedInt32()[] = 1; $from-\u003egetMapInt32Int32()[1] = 1; $data = $from-\u003eserializeToString(); try { $to-\u003emergeFromString($data); } catch (Exception $e) { // Handle parsing error from invalid data. ... } You should not create your own Foo subclasses. Generated classes are not designed for subclassing and may lead to \"fragile base class\" problems.\nNested messages result in a PHP class of the same name prefixed by their containing message and separated by underscores, as PHP doesn’t support nested classes. So, for example, if you have this in your .proto:\nmessage TestMessage { optional int32 a = 1; message NestedMessage {...} } The compiler will generate the following classes:\nclass TestMessage { public a; } // PHP doesn’t support nested classes. class TestMessage_NestedMessage {...} If the message class name is reserved (for example, Empty), the prefix PB is prepended to the class name:\nclass PBEmpty {...} We have also provided the file level option php_class_prefix. If this is specified, it is prepended to all generated message classes.\nFields For each field in a message type, there are accessor methods to set and get the field. So given a field x you can write:\n$m = new MyMessage(); $m-\u003esetX(1); $val = $m-\u003egetX(); $a = 1; $m-\u003esetX($a); Whenever you set a field, the value is type-checked against the declared type of that field. If the value is of the wrong type (or out of range), an exception will be raised. By default type conversions (for example, when assigning a value to a field or adding an element to a repeated field) are permitted to and from integer, float, and numeric strings. Conversions that are not permitted include all conversions to/from arrays or objects. Float to integer overflow conversions are undefined.\nYou can see the corresponding PHP type for each scalar protocol buffers type in the scalar value types table.\nSingular Message Fields A field with a message type defaults to nil, and is not automatically created when the field is accessed. Thus you need to explicitly create sub messages, as in the following:\n$m = new MyMessage(); $m-\u003esetZ(new SubMessage()); $m-\u003egetZ()-\u003esetFoo(42); $m2 = new MyMessage(); $m2-\u003egetZ()-\u003esetFoo(42); // FAILS with an exception You can assign any instance to a message field, even if the instance is also held elsewhere (for example, as a field value on another message).\nRepeated Fields The protocol buffer compiler generates a special RepeatedField for each repeated field. So, for example, given the following field:\nrepeated int32 foo = 1; The generated code lets you do this:\n$m-\u003egetFoo()[] =1; $m-\u003esetFoo($array); Map Fields The protocol buffer compiler generates a MapField for each map field. So given this field:\nmap\u003cint32, int32\u003e weight = 1; You can do the following with the generated code:\n$m-\u003egetWeight()[1] = 1; Enumerations PHP doesn’t have native enums, so instead the protocol buffer compiler generates a PHP class for each enum type in your .proto file, just like for messages, with constants defined for each value. So, given this enum:\nenum TestEnum { Default = 0; A = 1; } The compiler generates the following class:\nclass TestEnum { const DEFAULT = 0; const A = 1; } Also as with messages, a nested enum will result in a PHP class of the same name prefixed by its containing message(s) and separated with underscores, as PHP does not support nested classes.\nclass TestMessage_NestedEnum {...} If an enum class or value name is reserved (for example, Empty), the prefix PB is prepended to the class or value name:\nclass PBEmpty { const PBECHO = 0; } We have also provided the file level option php_class_prefix. If this is specified, it is prepended to all generated enum classes.\nOneof For a oneofs, the protocol buffer compiler generates the same code as it would for regular singular fields, but also adds a special accessor method that lets you find out which oneof field (if any) is set. So, given this message:\nmessage TestMessage { oneof test_oneof { int32 oneof_int32 = 1; int64 oneof_int64 = 2; } } The compiler generates the following fields and special method:\nclass TestMessage { private oneof_int32; private oneof_int64; public function getOneofInt32(); public function setOneofInt32($var); public function getOneofInt64(); public function setOneofInt64($var); public function getTestOneof(); // Return field name } The accessor method’s name is based on the oneof’s name, and returns an enum value representing the field in the oneof that is currently set.\n","categories":"","description":"This topic describes the PHP code that the protocol buffer compiler generates for any given protocol definition.","excerpt":"This topic describes the PHP code that the protocol buffer compiler …","ref":"/reference/php/php-generated/","tags":"","title":"PHP Generated Code Guide"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/php/api-docs-link/","tags":"","title":"PHP API"},{"body":" Python Generated Code Guide Python API (Sphinx) ","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in Python","excerpt":"This section contains reference documentation for working with …","ref":"/reference/python/","tags":"","title":"Python Reference"},{"body":"This page describes exactly what Python definitions the protocol buffer compiler generates for any given protocol definition. Any differences between proto2 and proto3 generated code are highlighted - note that these differences are in the generated code as described in this document, not the base message classes/interfaces, which are the same in both versions. You should read the proto2 language guide and/or proto3 language guide before reading this document.\nThe Python Protocol Buffers implementation is a little different from C++ and Java. In Python, the compiler only outputs code to build descriptors for the generated classes, and a Python metaclass does the real work. This document describes what you get after the metaclass has been applied.\nCompiler Invocation The protocol buffer compiler produces Python output when invoked with the --python_out= command-line flag. The parameter to the --python_out= option is the directory where you want the compiler to write your Python output. The compiler creates a .py file for each .proto file input. The names of the output files are computed by taking the name of the .proto file and making two changes:\nThe extension (.proto) is replaced with _pb2.py. The proto path (specified with the --proto_path= or -I command-line flag) is replaced with the output path (specified with the --python_out= flag). So, for example, let’s say you invoke the compiler as follows:\nprotoc --proto_path=src --python_out=build/gen src/foo.proto src/bar/baz.proto The compiler will read the files src/foo.proto and src/bar/baz.proto and produce two output files: build/gen/foo_pb2.py and build/gen/bar/baz_pb2.py. The compiler will automatically create the directory build/gen/bar if necessary, but it will not create build or build/gen; they must already exist.\nNote that if the .proto file or its path contains any characters which cannot be used in Python module names (for example, hyphens), they will be replaced with underscores. So, the file foo-bar.proto becomes the Python file foo_bar_pb2.py.\nTip When outputting Python code, the protocol buffer compiler’s ability to output directly to ZIP archives is particularly convenient, as the Python interpreter is able to read directly from these archives if placed in the PYTHONPATH. To output to a ZIP file, simply provide an output location ending in .zip. Note The number 2 in the extension _pb2.py designates version 2 of Protocol Buffers. Version 1 was used primarily inside Google, though you might be able to find parts of it included in other Python code that was released before Protocol Buffers. Since version 2 of Python Protocol Buffers has a completely different interface, and since Python does not have compile-time type checking to catch mistakes, we chose to make the version number be a prominent part of generated Python file names. Currently both proto2 and proto3 use _pb2.py for their generated files. Packages The Python code generated by the protocol buffer compiler is completely unaffected by the package name defined in the .proto file. Instead, Python packages are identified by directory structure.\nMessages Given a simple message declaration:\nmessage Foo {} The protocol buffer compiler generates a class called Foo, which subclasses google.protobuf.Message. The class is a concrete class; no abstract methods are left unimplemented. Unlike C++ and Java, Python generated code is unaffected by the optimize_for option in the .proto file; in effect, all Python code is optimized for code size.\nIf the message’s name is a Python keyword, then its class will only be accessible via getattr(), as described in the Names which conflict with Python keywords section.\nYou should not create your own Foo subclasses. Generated classes are not designed for subclassing and may lead to \"fragile base class\" problems. Besides, implementation inheritance is bad design.\nPython message classes have no particular public members other than those defined by the Message interface and those generated for nested fields, messages, and enum types (described below). Message provides methods you can use to check, manipulate, read, or write the entire message, including parsing from and serializing to binary strings. In addition to these methods, the Foo class defines the following static methods:\nFromString(s): Returns a new message instance deserialized from the given string. Note that you can also use the text_format module to work with protocol messages in text format: for example, the Merge() method lets you merge an ASCII representation of a message into an existing message.\nNested Types A message can be declared inside another message. For example:\nmessage Foo { message Bar {} } In this case, the Bar class is declared as a static member of Foo, so you can refer to it as Foo.Bar.\nWell Known Types Protocol buffers provides a number of well-known types that you can use in your .proto files along with your own message types. Some WKT messages have special methods in addition to the usual protocol buffer message methods, as they subclass both google.protobuf.Message and a WKT class.\nAny For Any messages, you can call Pack() to pack a specified message into the current Any message, or Unpack() to unpack the current Any message into a specified message. For example:\nany_message.Pack(message) any_message.Unpack(message) Unpack() also checks the descriptor of the passed-in message object against the stored one and returns False if they don’t match and does not attempt any unpacking; True otherwise.\nYou can also call the Is() method to check if the Any message represents the given protocol buffer type. For example:\nassert any_message.Is(message.DESCRIPTOR) Timestamp Timestamp messages can be converted to/from RFC 3339 date string format (JSON string) using the ToJsonString()/FromJsonString() methods. For example:\ntimestamp_message.FromJsonString(\"1970-01-01T00:00:00Z\") assert timestamp_message.ToJsonString() == \"1970-01-01T00:00:00Z\" You can also call GetCurrentTime() to fill the Timestamp message with current time:\ntimestamp_message.GetCurrentTime() To convert between other time units since epoch, you can call ToNanoseconds(), FromNanoseconds(), ToMicroseconds(), FromMicroseconds(), ToMilliseconds(), FromMilliseconds(), ToSeconds(), or FromSeconds(). The generated code also has ToDatetime() and FromDatetime() methods to convert between Python datetime objects and Timestamps. For example:\ntimestamp_message.FromMicroseconds(-1) assert timestamp_message.ToMicroseconds() == -1 dt = datetime(2016, 1, 1) timestamp_message.FromDatetime(dt) self.assertEqual(dt, timestamp_message.ToDatetime()) Duration Duration messages have the same methods as Timestamp to convert between JSON string and other time units. To convert between timedelta and Duration, you can call ToTimedelta() or FromTimedelta. For example:\nduration_message.FromNanoseconds(1999999999) td = duration_message.ToTimedelta() assert td.seconds == 1 assert td.microseconds == 999999 FieldMask FieldMask messages can be converted to/from JSON string using the ToJsonString()/FromJsonString() methods. In addition, a FieldMask message has the following methods:\nIsValidForDescriptor: Checks whether the FieldMask is valid for Message Descriptor. AllFieldsFromDescriptor: Gets all direct fields of Message Descriptor to FieldMask. CanonicalFormFromMask: Converts a FieldMask to the canonical form. Union: Merges two FieldMasks into this FieldMask. Intersect: Intersects two FieldMasks into this FieldMask. MergeMessage: Merges fields specified in FieldMask from source to destination. Struct Struct messages let you get and set the items directly. For example:\nstruct_message[\"key1\"] = 5 struct_message[\"key2\"] = \"abc\" struct_message[\"key3\"] = True To get or create a list/struct, you can call get_or_create_list()/get_or_create_struct(). For example:\nstruct.get_or_create_struct(\"key4\")[\"subkey\"] = 11.0 struct.get_or_create_list(\"key5\") ListValue A ListValue message acts like a Python sequence that lets you do the following:\nlist_value = struct_message.get_or_create_list(\"key\") list_value.extend([6, \"seven\", True, None]) list_value.append(False) assert len(list_value) == 5 assert list_value[0] == 6 assert list_value[1] == \"seven\" assert list_value[2] == True assert list_value[3] == None assert list_Value[4] == False To add a ListValue/Struct, call add_list()/add_struct(). For example:\nlist_value.add_struct()[\"key\"] = 1 list_value.add_list().extend([1, \"two\", True]) Fields For each field in a message type, the corresponding class has a property with the same name as the field. How you can manipulate the property depends on its type.\nAs well as a property, the compiler generates an integer constant for each field containing its field number. The constant name is the field name converted to upper-case followed by _FIELD_NUMBER. For example, given the field optional int32 foo_bar = 5;, the compiler will generate the constant FOO_BAR_FIELD_NUMBER = 5.\nIf the field’s name is a Python keyword, then its property will only be accessible via getattr() and setattr(), as described in the Names which conflict with Python keywords section.\nSingular Fields (proto2) If you have a singular (optional or required) field foo of any non-message type, you can manipulate the field foo as if it were a regular field. For example, if foo’s type is int32, you can say:\nmessage.foo = 123 print(message.foo) Note that setting foo to a value of the wrong type will raise a TypeError.\nIf foo is read when it is not set, its value is the default value for that field. To check if foo is set, or to clear the value of foo, you must call the HasField() or ClearField() methods of the Message interface. For example:\nassert not message.HasField(\"foo\") message.foo = 123 assert message.HasField(\"foo\") message.ClearField(\"foo\") assert not message.HasField(\"foo\") Singular Fields (proto3) If you have a singular field foo of any non-message type, you can manipulate the field foo as if it were a regular field. For example, if foo’s type is int32, you can say:\nmessage.foo = 123 print(message.foo) Note that setting foo to a value of the wrong type will raise a TypeError.\nIf foo is read when it is not set, its value is the default value for that field. To clear the value of foo and reset it to the default value for its type, you call the ClearField() method of the Message interface. For example:\nmessage.foo = 123 message.ClearField(\"foo\") Note Unlike in proto2, you cannot call HasField() for a singular non-message field in proto3, and the library will throw an exception if you try to do this. Singular Message Fields Message types work slightly differently. You cannot assign a value to an embedded message field. Instead, assigning a value to any field within the child message implies setting the message field in the parent. In proto3, you can also use the parent message’s HasField() method to check if a message type field value has been set, which you can’t do with other types of proto3 singular field.\nSo, for example, let’s say you have the following .proto definition:\nmessage Foo { optional Bar bar = 1; } message Bar { optional int32 i = 1; } You cannot do the following:\nfoo = Foo() foo.bar = Bar() # WRONG! Instead, to set bar, you simply assign a value directly to a field within bar, and - presto! - foo has a bar field:\nfoo = Foo() assert not foo.HasField(\"bar\") foo.bar.i = 1 assert foo.HasField(\"bar\") assert foo.bar.i == 1 foo.ClearField(\"bar\") assert not foo.HasField(\"bar\") assert foo.bar.i == 0 # Default value Similarly, you can set bar using the Message interface’s CopyFrom() method. This copies all the values from another message of the same type as bar.\nfoo.bar.CopyFrom(baz) Note that simply reading a field inside bar does not set the field:\nfoo = Foo() assert not foo.HasField(\"bar\") print(foo.bar.i) # Print i's default value assert not foo.HasField(\"bar\") If you need the \"has\" bit on a message that does not have any fields you can or want to set, you may use the SetInParent() method.\nfoo = Foo() assert not foo.HasField(\"bar\") foo.bar.SetInParent() # Set Foo.bar to a default Bar message assert foo.HasField(\"bar\") Repeated Fields Repeated fields are represented as an object that acts like a Python sequence. As with embedded messages, you cannot assign the field directly, but you can manipulate it. For example, given this message definition:\nmessage Foo { repeated int32 nums = 1; } You can do the following:\nfoo = Foo() foo.nums.append(15) # Appends one value foo.nums.extend([32, 47]) # Appends an entire list assert len(foo.nums) == 3 assert foo.nums[0] == 15 assert foo.nums[1] == 32 assert foo.nums == [15, 32, 47] foo.nums[:] = [33, 48] # Assigns an entire list assert foo.nums == [33, 48] foo.nums[1] = 56 # Reassigns a value assert foo.nums[1] == 56 for i in foo.nums: # Loops and print print(i) del foo.nums[:] # Clears list (works just like in a Python list) The ClearField() method of the Message interface works in addition to using Python del.\nRepeated Message Fields Repeated message fields work similar to repeated scalar fields. However, the corresponding Python object also has an add() method that creates a new message object, appends it to the list, and returns it for the caller to fill in. Also, the object’s append() method makes a copy of the given message and appends that copy to the list. This is done so that messages are always owned by the parent message to avoid circular references and other confusion that can happen when a mutable data structure has multiple owners. Similarly, the object’s extend() method appends an entire list of messages, but makes a copy of every message in the list.\nFor example, given this message definition:\nmessage Foo { repeated Bar bars = 1; } message Bar { optional int32 i = 1; optional int32 j = 2; } You can do the following:\nfoo = Foo() bar = foo.bars.add() # Adds a Bar then modify bar.i = 15 foo.bars.add().i = 32 # Adds and modify at the same time new_bar = Bar() new_bar.i = 40 another_bar = Bar() another_bar.i = 57 foo.bars.append(new_bar) # Uses append() to copy foo.bars.extend([another_bar]) # Uses extend() to copy assert len(foo.bars) == 4 assert foo.bars[0].i == 15 assert foo.bars[1].i == 32 assert foo.bars[2].i == 40 assert foo.bars[2] == new_bar # The appended message is equal, assert foo.bars[2] is not new_bar # but it is a copy! assert foo.bars[3].i == 57 assert foo.bars[3] == another_bar # The extended message is equal, assert foo.bars[3] is not another_bar # but it is a copy! foo.bars[1].i = 56 # Modifies a single element assert foo.bars[1].i == 56 for bar in foo.bars: # Loops and print print(bar.i) del foo.bars[:] # Clears list # add() also forwards keyword arguments to the concrete class. # For example, you can do: foo.bars.add(i=12, j=13) # Initializers forward keyword arguments to a concrete class too. # For example: foo = Foo( # Creates Foo bars=[ # with its field bars set to a list Bar(i=15, j=17), # where each list member is also initialized during creation. Bar(i=32), Bar(i=47, j=77), ] ) assert len(foo.bars) == 3 assert foo.bars[0].i == 15 assert foo.bars[0].j == 17 assert foo.bars[1].i == 32 assert foo.bars[2].i == 47 assert foo.bars[2].j == 77 Unlike repeated scalar fields, repeated message fields don’t support item assignment (i.e. __setitem__). For example:\nfoo = Foo() foo.bars.add(i=3) # WRONG! foo.bars[0] = Bar(i=15) # Raises an exception # WRONG! foo.bars[:] = [Bar(i=15), Bar(i=17)] # Also raises an exception Groups (proto2) Note that groups are deprecated and should not be used when creating new message types – use nested message types instead.\nA group combines a nested message type and a field into a single declaration, and uses a different wire format for the message. The generated message has the same name as the group. The generated field’s name is the lowercased name of the group.\nFor example, except for wire format, the following two message definitions are equivalent:\n// Version 1: Using groups message SearchResponse { repeated group SearchResult = 1 { required string url = 2; } } // Version 2: Not using groups message SearchResponse { message SearchResult { required string url = 2; } repeated SearchResult searchresult = 1; } A group is either required, optional, or repeated. A required or optional group is manipulated using the same API as a regular singular message field. A repeated group is manipulated using the same API as a regular repeated message field.\nFor example, given the above SearchResponse definition, you can do the following:\nresp = SearchResponse() resp.searchresult.add(url=\"https://blog.google\") assert resp.searchresult[0].url == \"https://blog.google\" assert resp.searchresult[0] == SearchResponse.SearchResult(url=\"https://blog.google\") Map Fields Given this message definition:\nmessage MyMessage { map\u003cint32, int32\u003e mapfield = 1; } The generated Python API for the map field is just like a Python dict:\n# Assign value to map m.mapfield[5] = 10 # Read value from map m.mapfield[5] # Iterate over map keys for key in m.mapfield: print(key) print(m.mapfield[key]) # Test whether key is in map: if 5 in m.mapfield: print(“Found!”) # Delete key from map. del m.mapfield[key] As with embedded message fields, messages cannot be directly assigned into a map value. Instead, to add a message as a map value you reference an undefined key, which constructs and returns a new submessage:\nm.message_map[key].submessage_field = 10 You can find out more about undefined keys in the next section.\nReferencing undefined keys The semantics of Protocol Buffer maps behave slightly differently to Python dicts when it comes to undefined keys. In a regular Python dict, referencing an undefined key raises a KeyError exception:\n\u003e\u003e\u003e x = {} \u003e\u003e\u003e x[5] Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e KeyError: 5 However, in Protocol Buffers maps, referencing an undefined key creates the key in the map with a zero/false/empty value. This behavior is more like the Python standard library defaultdict.\n\u003e\u003e\u003e dict(m.mapfield) {} \u003e\u003e\u003e m.mapfield[5] 0 \u003e\u003e\u003e dict(m.mapfield) {5: 0} This behavior is especially convenient for maps with message type values, because you can directly update the fields of the returned message.\n\u003e\u003e\u003e m.message_map[5].foo = 3 Note that even if you don’t assign any values to message fields, the submessage is still created in the map:\n\u003e\u003e\u003e m.message_map[10] \u003ctest_pb2.M2 object at 0x7fb022af28c0\u003e \u003e\u003e\u003e dict(m.message_map) {10: \u003ctest_pb2.M2 object at 0x7fb022af28c0\u003e} This is different from regular embedded message fields, where the message itself is only created once you assign a value to one of its fields.\nAs it may not be immediately obvious to anyone reading your code that m.message_map[10] alone, for example, may create a submessage, we also provide a get_or_create() method that does the same thing but whose name makes the possible message creation more explicit:\n# Equivalent to: # m.message_map[10] # but more explicit that the statement might be creating a new # empty message in the map. m.message_map.get_or_create(10) Enumerations In Python, enums are just integers. A set of integral constants are defined corresponding to the enum’s defined values. For example, given:\nmessage Foo { enum SomeEnum { VALUE_A = 0; VALUE_B = 5; VALUE_C = 1234; } optional SomeEnum bar = 1; } The constants VALUE_A, VALUE_B, and VALUE_C are defined with values 0, 5, and 1234, respectively. You can access SomeEnum if desired. If an enum is defined in the outer scope, the values are module constants; if it is defined within a message (like above), they become static members of that message class.\nFor example, you can access the values in the three following ways for the following enum in a proto:\nenum SomeEnum { VALUE_A = 0; VALUE_B = 5; VALUE_C = 1234; } value_a = myproto_pb2.SomeEnum.VALUE_A # or myproto_pb2.VALUE_A # or myproto_pb2.SomeEnum.Value('VALUE_A') An enum field works just like a scalar field.\nfoo = Foo() foo.bar = Foo.VALUE_A assert foo.bar == 0 assert foo.bar == Foo.VALUE_A If the enum’s name (or an enum value) is a Python keyword, then its object (or the enum value’s property) will only be accessible via getattr(), as described in the Names which conflict with Python keywords section.\nThe values you can set in an enum depend on your protocol buffers version:\nIn proto2, an enum cannot contain a numeric value other than those defined for the enum type. If you assign a value that is not in the enum, the generated code will throw an exception. proto3 uses open enum semantics: enum fields can contain any int32 value. Enums have a number of utility methods for getting field names from values and vice versa, lists of fields, and so on - these are defined in enum_type_wrapper.EnumTypeWrapper (the base class for generated enum classes). So, for example, if you have the following standalone enum in myproto.proto:\nenum SomeEnum { VALUE_A = 0; VALUE_B = 5; VALUE_C = 1234; } …you can do this:\nself.assertEqual('VALUE_A', myproto_pb2.SomeEnum.Name(myproto_pb2.VALUE_A)) self.assertEqual(5, myproto_pb2.SomeEnum.Value('VALUE_B')) For an enum declared within a protocol message, such as Foo above, the syntax is similar:\nself.assertEqual('VALUE_A', myproto_pb2.Foo.SomeEnum.Name(myproto_pb2.Foo.VALUE_A)) self.assertEqual(5, myproto_pb2.Foo.SomeEnum.Value('VALUE_B')) If multiple enum constants have the same value (aliases), the first constant defined is returned.\nenum SomeEnum { option allow_alias = true; VALUE_A = 0; VALUE_B = 5; VALUE_C = 1234; VALUE_B_ALIAS = 5; } In the above example, myproto_pb2.SomeEnum.Name(5) returns \"VALUE_B\".\nOneof Given a message with a oneof:\nmessage Foo { oneof test_oneof { string name = 1; int32 serial_number = 2; } } The Python class corresponding to Foo will have properties called name and serial_number just like regular fields. However, unlike regular fields, at most one of the fields in a oneof can be set at a time, which is ensured by the runtime. For example:\nmessage = Foo() message.name = \"Bender\" assert message.HasField(\"name\") message.serial_number = 2716057 assert message.HasField(\"serial_number\") assert not message.HasField(\"name\") The message class also has a WhichOneof method that lets you find out which field (if any) in the oneof has been set. This method returns the name of the field that is set, or None if nothing has been set:\nassert message.WhichOneof(\"test_oneof\") is None message.name = \"Bender\" assert message.WhichOneof(\"test_oneof\") == \"name\" HasField and ClearField also accept oneof names in addition to field names:\nassert not message.HasField(\"test_oneof\") message.name = \"Bender\" assert message.HasField(\"test_oneof\") message.serial_number = 2716057 assert message.HasField(\"test_oneof\") message.ClearField(\"test_oneof\") assert not message.HasField(\"test_oneof\") assert not message.HasField(\"serial_number\") Note that calling ClearField on a oneof just clears the currently set field.\nNames which conflict with Python keywords If the name of a message, field, enum, or enum value is a Python keyword, then the name of its corresponding class or property will be the same, but you’ll only be able to access it using Python’s getattr() and setattr() built-in functions, and not via Python’s normal attribute reference syntax (i.e. the dot operator).\nFor example, if you have the following .proto definition:\nmessage Baz { optional int32 from = 1 repeated int32 in = 2; } You would access those fields like this:\nbaz = Baz() setattr(baz, \"from\", 99) assert getattr(baz, \"from\") == 99 getattr(baz, \"in\").append(42) assert getattr(baz, \"in\") == [42] By contrast, trying to use obj.attr syntax to access these fields results in Python raising syntax errors when parsing your code:\n# WRONG! baz.in # SyntaxError: invalid syntax baz.from # SyntaxError: invalid syntax Extensions (proto2 only) Given a message with an extension range:\nmessage Foo { extensions 100 to 199; } The Python class corresponding to Foo will have a member called Extensions, which is a dictionary mapping extension identifiers to their current values.\nGiven an extension definition:\nextend Foo { optional int32 bar = 123; } The protocol buffer compiler generates an \"extension identifier\" called bar. The identifier acts as a key to the Extensions dictionary. The result of looking up a value in this dictionary is exactly the same as if you accessed a normal field of the same type. So, given the above example, you could do:\nfoo = Foo() foo.Extensions[proto_file_pb2.bar] = 2 assert foo.Extensions[proto_file_pb2.bar] == 2 Note that you need to specify the extension identifier constant, not just a string name: this is because it’s possible for multiple extensions with the same name to be specified in different scopes.\nAnalogous to normal fields, Extensions[...] returns a message object for singular messages and a sequence for repeated fields.\nThe Message interface’s HasField() and ClearField() methods do not work with extensions; you must use HasExtension() and ClearExtension() instead. To use the HasExtension() and ClearExtension() methods, pass in the field_descriptor for the extension you are checking for the existence of.\nServices If the .proto file contains the following line:\noption py_generic_services = true; Then the protocol buffer compiler will generate code based on the service definitions found in the file as described in this section. However, the generated code may be undesirable as it is not tied to any particular RPC system, and thus requires more levels of indirection that code tailored to one system. If you do NOT want this code to be generated, add this line to the file:\noption py_generic_services = false; If neither of the above lines are given, the option defaults to false, as generic services are deprecated. (Note that prior to 2.4.0, the option defaults to true)\nRPC systems based on .proto-language service definitions should provide plugins to generate code appropriate for the system. These plugins are likely to require that abstract services are disabled, so that they can generate their own classes of the same names. Plugins are new in version 2.3.0 (January 2010).\nThe remainder of this section describes what the protocol buffer compiler generates when abstract services are enabled.\nInterface Given a service definition:\nservice Foo { rpc Bar(FooRequest) returns(FooResponse); } The protocol buffer compiler will generate a class Foo to represent this service. Foo will have a method for each method defined in the service definition. In this case, the method Bar is defined as:\ndef Bar(self, rpc_controller, request, done) The parameters are equivalent to the parameters of Service.CallMethod(), except that the method_descriptor argument is implied.\nThese generated methods are intended to be overridden by subclasses. The default implementations simply call controller.SetFailed() with an error message indicating that the method is unimplemented, then invoke the done callback. When implementing your own service, you must subclass this generated service and implement its methods as appropriate.\nFoo subclasses the Service interface. The protocol buffer compiler automatically generates implementations of the methods of Service as follows:\nGetDescriptor: Returns the service’s ServiceDescriptor. CallMethod: Determines which method is being called based on the provided method descriptor and calls it directly. GetRequestClass and GetResponseClass: Returns the class of the request or response of the correct type for the given method. Stub The protocol buffer compiler also generates a \"stub\" implementation of every service interface, which is used by clients wishing to send requests to servers implementing the service. For the Foo service (above), the stub implementation Foo_Stub will be defined.\nFoo_Stub is a subclass of Foo. Its constructor takes an RpcChannel as a parameter. The stub then implements each of the service’s methods by calling the channel’s CallMethod() method.\nThe Protocol Buffer library does not include an RPC implementation. However, it includes all of the tools you need to hook up a generated service class to any arbitrary RPC implementation of your choice. You need only provide implementations of RpcChannel and RpcController.\nPlugin Insertion Points Code generator plugins which want to extend the output of the Python code generator may insert code of the following types using the given insertion point names.\nimports: Import statements. module_scope: Top-level declarations. Warning Do not generate code which relies on private class members declared by the standard code generator, as these implementation details may change in future versions of Protocol Buffers. Sharing Messages Between Python and C++ Prior to the 4.21.0 version of the Protobuf Python API, Python apps could share messages with C++ using a native extension. Starting in the 4.21.0 API version, sharing messages between Python and C++ is not supported by the default install. To enable this capability when working with the 4.x and later versions of the Protobuf Python API, define the environment variable, PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=cpp, and ensure that the Python/C++ extension is installed.\n","categories":"","description":"This topic describes exactly what Python definitions the protocol buffer compiler generates for any given protocol definition.","excerpt":"This topic describes exactly what Python definitions the protocol …","ref":"/reference/python/python-generated/","tags":"","title":"Python Generated Code Guide"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/python/api-docs-link/","tags":"","title":"Python API"},{"body":" Ruby Generated Code Guide ","categories":"","description":"This section contains reference documentation for working with protocol buffer classes in Ruby","excerpt":"This section contains reference documentation for working with …","ref":"/reference/ruby/","tags":"","title":"Ruby Reference"},{"body":"This page describes the API of message objects that the protocol buffer compiler generates for any given protocol definition. You should read the language guides for proto2 or proto3 before reading this document.\nThe protocol compiler for Ruby emits Ruby source files that use a DSL to define the message schema. However the DSL is still subject to change. In this guide we only describe the API of the generated messages, and not the DSL.\nCompiler Invocation The protocol buffer compiler produces Ruby output when invoked with the --ruby_out= command-line flag. The parameter to the --ruby_out= option is the directory where you want the compiler to write your Ruby output. The compiler creates a .rb file for each .proto file input. The names of the output files are computed by taking the name of the .proto file and making two changes:\nThe extension (.proto) is replaced with _pb.rb. The proto path (specified with the --proto_path= or -I command-line flag) is replaced with the output path (specified with the --ruby_out= flag). So, for example, let’s say you invoke the compiler as follows:\nprotoc --proto_path=src --ruby_out=build/gen src/foo.proto src/bar/baz.proto The compiler will read the files src/foo.proto and src/bar/baz.proto and produce two output files: build/gen/foo_pb.rb and build/gen/bar/baz_pb.rb. The compiler will automatically create the directory build/gen/bar if necessary, but it will not create build or build/gen; they must already exist.\nPackages The package name defined in the .proto file is used to generate a module structure for the generated messages. Given a file like:\npackage foo_bar.baz; message MyMessage {} The protocol compiler generates an output message with the name FooBar::Baz::MyMessage.\nMessages Given a simple message declaration:\nmessage Foo {} The protocol buffer compiler generates a class called Foo. The generated class derives from the Ruby Object class (protos have no common base class). Unlike C++ and Java, Ruby generated code is unaffected by the optimize_for option in the .proto file; in effect, all Ruby code is optimized for code size.\nYou should not create your own Foo subclasses. Generated classes are not designed for subclassing and may lead to \"fragile base class\" problems.\nRuby message classes define accessors for each field, and also provide the following standard methods:\nMessage#dup, Message#clone: Performs a shallow copy of this message and returns the new copy. Message#==: Performs a deep equality comparison between two messages. Message#hash: Computes a shallow hash of the message’s value. Message#to_hash, Message#to_h: Converts the object to a ruby Hash object. Only the top-level message is converted. Message#inspect: Returns a human-readable string representing this message. Message#[], Message#[]=: Gets or sets a field by string name. In the future this will probably also be used to get/set extensions. The message classes also define the following methods as static. (In general we prefer static methods, since regular methods can conflict with field names you defined in your .proto file.)\nMessage.decode(str): Decodes a binary protobuf for this message and returns it in a new instance. Message.encode(proto): Serializes a message object of this class to a binary string. Message.decode_json(str): Decodes a JSON text string for this message and returns it in a new instance. Message.encode_json(proto): Serializes a message object of this class to a JSON text string. Message.descriptor: Returns the Google::Protobuf::Descriptor object for this message. When you create a message, you can conveniently initialize fields in the constructor. Here is an example of constructing and using a message:\nmessage = MyMessage.new(:int_field =\u003e 1, :string_field =\u003e \"String\", :repeated_int_field =\u003e [1, 2, 3, 4], :submessage_field =\u003e SubMessage.new(:foo =\u003e 42)) serialized = MyMessage.encode(message) message2 = MyMessage.decode(serialized) raise unless message2.int_field == 1 Nested Types A message can be declared inside another message. For example:\nmessage Foo { message Bar { } } In this case, the Bar class is declared as a class inside of Foo, so you can refer to it as Foo::Bar.\nFields For each field in a message type, there are accessor methods to set and get the field. So given a field foo you can write:\nmessage.foo = get_value() print message.foo Whenever you set a field, the value is type-checked against the declared type of that field. If the value is of the wrong type (or out of range), an exception will be raised.\nSingular Fields For singular primitive fields (numbers, strings, and boolean), the value you assign to the field should be of the correct type and must be in the appropriate range:\nNumber types: the value should be a Fixnum, Bignum, or Float. The value you assign must be exactly representable in the target type. So assigning 1.0 to an int32 field is ok, but assigning 1.2 is not. Boolean fields: the value must be true or false. No other values will implicitly convert to true/false. Bytes fields: the assigned value must be a String object. The protobuf library will duplicate the string, convert it to ASCII-8BIT encoding, and freeze it. String fields: the assigned value must be a String object. The protobuf library will duplicate the string, convert it to UTF-8 encoding, and freeze it. No automatic #to_s, #to_i, etc. calls will happen to perform automatic conversion. You should convert values yourself first, if necessary.\nChecking Presence When using optional fields, field presence is checked by calling a generated has_...? method. Setting any value—even the default value—marks the field as present. Fields can be cleared by calling a different generated clear_... method. For example, for a message MyMessage with an int32 field foo:\nm = MyMessage.new raise unless !m.has_foo? m.foo = 0 raise unless m.has_foo? m.clear_foo raise unless !m.has_foo? Singular Message Fields For submessages, unset fields will return nil, so you can always tell if the message was explicitly set or not. To clear a submessage field, set its value explicitly to nil.\nif message.submessage_field.nil? puts \"Submessage field is unset.\" else message.submessage_field = nil puts \"Cleared submessage field.\" end In addition to comparing and assigning nil, generated messages have has_... and clear_... methods, which behave the same as for basic types:\nif message.has_submessage_field? raise unless message.submessage_field == nil puts \"Submessage field is unset.\" else raise unless message.submessage_field != nil message.clear_submessage_field raise unless message.submessage_field == nil puts \"Cleared submessage field.\" end When you assign a submessage, it must be a generated message object of the correct type.\nIt is possible to create message cycles when you assign submessages. For example:\n// foo.proto message RecursiveMessage { RecursiveMessage submessage = 1; } # test.rb require 'foo' message = RecursiveSubmessage.new message.submessage = message If you try to serialize this, the library will detect the cycle and fail to serialize.\nRepeated Fields Repeated fields are represented using a custom class Google::Protobuf::RepeatedField. This class acts like a Ruby Array and mixes in Enumerable. Unlike a regular Ruby array, RepeatedField is constructed with a specific type and expects all of the array members to have the correct type. The types and ranges are checked just like message fields.\nint_repeatedfield = Google::Protobuf::RepeatedField.new(:int32, [1, 2, 3]) raise unless !int_repeatedfield.empty? # Raises TypeError. int_repeatedfield[2] = \"not an int32\" # Raises RangeError int_repeatedfield[2] = 2**33 message.int32_repeated_field = int_repeatedfield # This isn't allowed; the regular Ruby array doesn't enforce types like we need. message.int32_repeated_field = [1, 2, 3, 4] # This is fine, since the elements are copied into the type-safe array. message.int32_repeated_field += [1, 2, 3, 4] # The elements can be cleared without reassigning. int_repeatedfield.clear raise unless int_repeatedfield.empty? The RepeatedField type supports all of the same methods as a regular Ruby Array. You can convert it to a regular Ruby Array with repeated_field.to_a.\nUnlike singular fields, has_...? methods are never generated for repeated fields.\nMap Fields Map fields are represented using a special class that acts like a Ruby Hash (Google::Protobuf::Map). Unlike a regular Ruby hash, Map is constructed with a specific type for the key and value and expects all of the map’s keys and values to have the correct type. The types and ranges are checked just like message fields and RepeatedField elements.\nint_string_map = Google::Protobuf::Map.new(:int32, :string) # Returns nil; items is not in the map. print int_string_map[5] # Raises TypeError, value should be a string int_string_map[11] = 200 # Ok. int_string_map[123] = \"abc\" message.int32_string_map_field = int_string_map Enumerations Since Ruby does not have native enums, we create a module for each enum with constants to define the values. Given the .proto file:\nmessage Foo { enum SomeEnum { VALUE_A = 0; VALUE_B = 5; VALUE_C = 1234; } optional SomeEnum bar = 1; } You can refer to enum values like so:\nprint Foo::SomeEnum::VALUE_A # =\u003e 0 message.bar = Foo::SomeEnum::VALUE_A You may assign either a number or a symbol to an enum field. When reading the value back, it will be a symbol if the enum value is known, or a number if it is unknown. Since proto3 uses open enum semantics, any number may be assigned to an enum field, even if it was not defined in the enum.\nmessage.bar = 0 puts message.bar.inspect # =\u003e :VALUE_A message.bar = :VALUE_B puts message.bar.inspect # =\u003e :VALUE_B message.bar = 999 puts message.bar.inspect # =\u003e 999 # Raises: RangeError: Unknown symbol value for enum field. message.bar = :UNDEFINED_VALUE # Switching on an enum value is convenient. case message.bar when :VALUE_A # ... when :VALUE_B # ... when :VALUE_C # ... else # ... end An enum module also defines the following utility methods:\nEnum#lookup(number): Looks up the given number and returns its name, or nil if none was found. If more than one name has this number, returns the first that was defined. Enum#resolve(symbol): Returns the number for this enum name, or nil if none was found. Enum#descriptor: Returns the descriptor for this enum. Oneof Given a message with a oneof:\nmessage Foo { oneof test_oneof { string name = 1; int32 serial_number = 2; } } The Ruby class corresponding to Foo will have members called name and serial_number with accessor methods just like regular fields. However, unlike regular fields, at most one of the fields in a oneof can be set at a time, so setting one field will clear the others.\nmessage = Foo.new # Fields have their defaults. raise unless message.name == \"\" raise unless message.serial_number == 0 raise unless message.test_oneof == nil message.name = \"Bender\" raise unless message.name == \"Bender\" raise unless message.serial_number == 0 raise unless message.test_oneof == :name # Setting serial_number clears name. message.serial_number = 2716057 raise unless message.name == \"\" raise unless message.test_oneof == :serial_number # Setting serial_number to nil clears the oneof. message.serial_number = nil raise unless message.test_oneof == nil For proto2 messages, oneof members have individual has_...? methods as well:\nmessage = Foo.new raise unless !message.has_test_oneof? raise unless !message.has_name? raise unless !message.has_serial_number? raise unless !message.has_test_oneof? message.name = \"Bender\" raise unless message.has_test_oneof? raise unless message.has_name? raise unless !message.has_serial_number? raise unless !message.has_test_oneof? ","categories":"","description":"This topic describes the API of message objects that the protocol buffer compiler generates for any given protocol definition.","excerpt":"This topic describes the API of message objects that the protocol …","ref":"/reference/ruby/ruby-generated/","tags":"","title":"Ruby Generated Code Guide"},{"body":" Protocol Buffers Version 2 Language Specification Protocol Buffers Version 3 Language Specification Text Format Language Specification ","categories":"","description":"This section contains language-agnostic information about how to use protocol buffers.","excerpt":"This section contains language-agnostic information about how to use …","ref":"/reference/protobuf/","tags":"","title":"Protocol Buffers Reference"},{"body":"This is a language specification reference for version 2 of the Protocol Buffers language (proto2). The syntax is specified using Extended Backus-Naur Form (EBNF):\n| alternation () grouping [] option (zero or one time) {} repetition (any number of times) For more information about using proto2, see the language guide.\nLexical Elements Letters and Digits letter = \"A\" … \"Z\" | \"a\" … \"z\" capitalLetter = \"A\" … \"Z\" decimalDigit = \"0\" … \"9\" octalDigit = \"0\" … \"7\" hexDigit = \"0\" … \"9\" | \"A\" … \"F\" | \"a\" … \"f\" Identifiers ident = letter { letter | decimalDigit | \"_\" } fullIdent = ident { \".\" ident } messageName = ident enumName = ident fieldName = ident oneofName = ident mapName = ident serviceName = ident rpcName = ident streamName = ident messageType = [ \".\" ] { ident \".\" } messageName enumType = [ \".\" ] { ident \".\" } enumName groupName = capitalLetter { letter | decimalDigit | \"_\" } Integer Literals intLit = decimalLit | octalLit | hexLit decimalLit = ( \"1\" … \"9\" ) { decimalDigit } octalLit = \"0\" { octalDigit } hexLit = \"0\" ( \"x\" | \"X\" ) hexDigit { hexDigit } Floating-point Literals floatLit = ( decimals \".\" [ decimals ] [ exponent ] | decimals exponent | \".\"decimals [ exponent ] ) | \"inf\" | \"nan\" decimals = decimalDigit { decimalDigit } exponent = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimals Boolean boolLit = \"true\" | \"false\" String Literals strLit = strLitSingle { strLitSingle } strLitSingle = ( \"'\" { charValue } \"'\" ) | ( '\"' { charValue } '\"' ) charValue = hexEscape | octEscape | charEscape | unicodeEscape | unicodeLongEscape | /[^\\0\\n\\\\]/ hexEscape = '\\' ( \"x\" | \"X\" ) hexDigit [ hexDigit ] octEscape = '\\' octalDigit [ octalDigit [ octalDigit ] ] charEscape = '\\' ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | '\\' | \"'\" | '\"' ) unicodeEscape = '\\' \"u\" hexDigit hexDigit hexDigit hexDigit unicodeLongEscape = '\\' \"U\" ( \"000\" hexDigit hexDigit hexDigit hexDigit hexDigit | \"0010\" hexDigit hexDigit hexDigit hexDigit EmptyStatement emptyStatement = \";\" Constant constant = fullIdent | ( [ \"-\" | \"+\" ] intLit ) | ( [ \"-\" | \"+\" ] floatLit ) | strLit | boolLit Syntax The syntax statement is used to define the protobuf version.\nsyntax = \"syntax\" \"=\" (\"'\" \"proto2\" \"'\" | '\"' \"proto2\" '\"') \";\" Import Statement The import statement is used to import another .proto’s definitions.\nimport = \"import\" [ \"weak\" | \"public\" ] strLit \";\" Example:\nimport public \"other.proto\"; Package The package specifier can be used to prevent name clashes between protocol message types.\npackage = \"package\" fullIdent \";\" Example:\npackage foo.bar; Option Options can be used in proto files, messages, enums and services. An option can be a protobuf defined option or a custom option. For more information, see Options in the language guide.\noption = \"option\" optionName \"=\" constant \";\" optionName = ( ident | \"(\" fullIdent \")\" ) { \".\" ident } For examples:\noption java_package = \"com.example.foo\"; Fields Fields are the basic elements of a protocol buffer message. Fields can be normal fields, group fields, oneof fields, or map fields. A field has a label, type and field number.\nlabel = \"required\" | \"optional\" | \"repeated\" type = \"double\" | \"float\" | \"int32\" | \"int64\" | \"uint32\" | \"uint64\" | \"sint32\" | \"sint64\" | \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\" | \"bool\" | \"string\" | \"bytes\" | messageType | enumType fieldNumber = intLit; Normal field Each field has label, type, name and field number. It may have field options.\nfield = label type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\" fieldOptions = fieldOption { \",\" fieldOption } fieldOption = optionName \"=\" constant Examples:\noptional foo.bar nested_message = 2; repeated int32 samples = 4 [packed=true]; Group field Note that this feature is deprecated and should not be used when creating new message types – use nested message types instead.\nGroups are one way to nest information in message definitions. The group name must begin with capital letter.\ngroup = label \"group\" groupName \"=\" fieldNumber messageBody Example:\nrepeated group Result = 1 { required string url = 2; optional string title = 3; repeated string snippets = 4; } Oneof and oneof field A oneof consists of oneof fields and a oneof name. Oneof fields do not have labels.\noneof = \"oneof\" oneofName \"{\" { option | oneofField } \"}\" oneofField = type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\" Example:\noneof foo { string name = 4; SubMessage sub_message = 9; } Map field A map field has a key type, value type, name, and field number. The key type can be any integral or string type. Note, the key type may not be an enum.\nmapField = \"map\" \"\u003c\" keyType \",\" type \"\u003e\" mapName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\" keyType = \"int32\" | \"int64\" | \"uint32\" | \"uint64\" | \"sint32\" | \"sint64\" | \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\" | \"bool\" | \"string\" Example:\nmap\u003cstring, Project\u003e projects = 3; Extensions and Reserved Extensions and reserved are message elements that declare a range of field numbers or field names.\nExtensions Extensions declare that a range of field numbers in a message are available for third-party extensions. Other people can declare new fields for your message type with those numeric tags in their own .proto files without having to edit the original file.\nextensions = \"extensions\" ranges \";\" ranges = range { \",\" range } range = intLit [ \"to\" ( intLit | \"max\" ) ] Examples:\nextensions 100 to 199; extensions 4, 20 to max; Reserved Reserved declares a range of field numbers or field names in a message that can not be used.\nreserved = \"reserved\" ( ranges | strFieldNames ) \";\" strFieldNames = strFieldName { \",\" strFieldName } strFieldName = \"'\" fieldName \"'\" | '\"' fieldName '\"' Examples:\nreserved 2, 15, 9 to 11; reserved \"foo\", \"bar\"; Top Level definitions Enum definition The enum definition consists of a name and an enum body. The enum body can have options, enum fields, and reserved statements.\nenum = \"enum\" enumName enumBody enumBody = \"{\" { option | enumField | emptyStatement | reserved } \"}\" enumField = ident \"=\" [ \"-\" ] intLit [ \"[\" enumValueOption { \",\" enumValueOption } \"]\" ]\";\" enumValueOption = optionName \"=\" constant Example:\nenum EnumAllowingAlias { option allow_alias = true; EAA_UNSPECIFIED = 0; EAA_STARTED = 1; EAA_RUNNING = 2 [(custom_option) = \"hello world\"]; } Message definition A message consists of a message name and a message body. The message body can have fields, nested enum definitions, nested message definitions, extend statements, extensions, groups, options, oneofs, map fields, and reserved statements.\nmessage = \"message\" messageName messageBody messageBody = \"{\" { field | enum | message | extend | extensions | group | option | oneof | mapField | reserved | emptyStatement } \"}\" Example:\nmessage Outer { option (my_option).a = true; message Inner { // Level 2 required int64 ival = 1; } map\u003cint32, string\u003e my_map = 2; extensions 20 to 30; } None of the entities declared inside a message may have conflicting names. All of the following are prohibited:\nmessage MyMessage { optional string foo = 1; message foo {} } message MyMessage { optional string foo = 1; oneof foo { string bar = 2; } } message MyMessage { optional string foo = 1; extend Extendable { optional string foo = 2; } } message MyMessage { optional string foo = 1; enum E { foo = 0; } } Extend If a message in the same or imported .proto file has reserved a range for extensions, the message can be extended.\nextend = \"extend\" messageType \"{\" {field | group} \"}\" Example:\nextend Foo { optional int32 bar = 126; } Service definition service = \"service\" serviceName \"{\" { option | rpc | emptyStatement } \"}\" rpc = \"rpc\" rpcName \"(\" [ \"stream\" ] messageType \")\" \"returns\" \"(\" [ \"stream\" ] messageType \")\" (( \"{\" { option | emptyStatement } \"}\" ) | \";\" ) Example:\nservice SearchService { rpc Search (SearchRequest) returns (SearchResponse); } Proto file proto = syntax { import | package | option | topLevelDef | emptyStatement } topLevelDef = message | enum | extend | service An example .proto file:\nsyntax = \"proto2\"; import public \"other.proto\"; option java_package = \"com.example.foo\"; enum EnumAllowingAlias { option allow_alias = true; EAA_UNSPECIFIED = 0; EAA_STARTED = 1; EAA_RUNNING = 1; EAA_FINISHED = 2 [(custom_option) = \"hello world\"]; } message Outer { option (my_option).a = true; message Inner { // Level 2 required int64 ival = 1; } repeated Inner inner_message = 2; optional EnumAllowingAlias enum_field = 3; map\u003cint32, string\u003e my_map = 4; extensions 20 to 30; } message Foo { optional group GroupMessage = 1 { optional bool a = 1; } } ","categories":"","description":"This topic is a language specification reference for version 2 of the Protocol Buffers language (proto2).","excerpt":"This topic is a language specification reference for version 2 of the …","ref":"/reference/protobuf/proto2-spec/","tags":"","title":"Protocol Buffers Version 2 Language Specification"},{"body":"This is a language specification reference for version 3 of the Protocol Buffers language (proto3). The syntax is specified using Extended Backus-Naur Form (EBNF):\n| alternation () grouping [] option (zero or one time) {} repetition (any number of times) For more information about using proto3, see the language guide.\nLexical Elements Letters and Digits letter = \"A\" … \"Z\" | \"a\" … \"z\" decimalDigit = \"0\" … \"9\" octalDigit = \"0\" … \"7\" hexDigit = \"0\" … \"9\" | \"A\" … \"F\" | \"a\" … \"f\" Identifiers ident = letter { letter | decimalDigit | \"_\" } fullIdent = ident { \".\" ident } messageName = ident enumName = ident fieldName = ident oneofName = ident mapName = ident serviceName = ident rpcName = ident messageType = [ \".\" ] { ident \".\" } messageName enumType = [ \".\" ] { ident \".\" } enumName Integer Literals intLit = decimalLit | octalLit | hexLit decimalLit = ( \"1\" … \"9\" ) { decimalDigit } octalLit = \"0\" { octalDigit } hexLit = \"0\" ( \"x\" | \"X\" ) hexDigit { hexDigit } Floating-point Literals floatLit = ( decimals \".\" [ decimals ] [ exponent ] | decimals exponent | \".\"decimals [ exponent ] ) | \"inf\" | \"nan\" decimals = decimalDigit { decimalDigit } exponent = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimals Boolean boolLit = \"true\" | \"false\" String Literals strLit = strLitSingle { strLitSingle } strLitSingle = ( \"'\" { charValue } \"'\" ) | ( '\"' { charValue } '\"' ) charValue = hexEscape | octEscape | charEscape | unicodeEscape | unicodeLongEscape | /[^\\0\\n\\\\]/ hexEscape = '\\' ( \"x\" | \"X\" ) hexDigit [ hexDigit ] octEscape = '\\' octalDigit [ octalDigit [ octalDigit ] ] charEscape = '\\' ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | '\\' | \"'\" | '\"' ) unicodeEscape = '\\' \"u\" hexDigit hexDigit hexDigit hexDigit unicodeLongEscape = '\\' \"U\" ( \"000\" hexDigit hexDigit hexDigit hexDigit hexDigit | \"0010\" hexDigit hexDigit hexDigit hexDigit EmptyStatement emptyStatement = \";\" Constant constant = fullIdent | ( [ \"-\" | \"+\" ] intLit ) | ( [ \"-\" | \"+\" ] floatLit ) | strLit | boolLit Syntax The syntax statement is used to define the protobuf version.\nsyntax = \"syntax\" \"=\" (\"'\" \"proto3\" \"'\" | '\"' \"proto3\" '\"') \";\" Example:\nsyntax = \"proto3\"; Import Statement The import statement is used to import another .proto’s definitions.\nimport = \"import\" [ \"weak\" | \"public\" ] strLit \";\" Example:\nimport public \"other.proto\"; Package The package specifier can be used to prevent name clashes between protocol message types.\npackage = \"package\" fullIdent \";\" Example:\npackage foo.bar; Option Options can be used in proto files, messages, enums and services. An option can be a protobuf defined option or a custom option. For more information, see Options in the language guide.\noption = \"option\" optionName \"=\" constant \";\" optionName = ( ident | \"(\" fullIdent \")\" ) { \".\" ident } Example:\noption java_package = \"com.example.foo\"; Fields Fields are the basic elements of a protocol buffer message. Fields can be normal fields, oneof fields, or map fields. A field has a type and field number.\ntype = \"double\" | \"float\" | \"int32\" | \"int64\" | \"uint32\" | \"uint64\" | \"sint32\" | \"sint64\" | \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\" | \"bool\" | \"string\" | \"bytes\" | messageType | enumType fieldNumber = intLit; Normal Field Each field has type, name and field number. It may have field options.\nfield = [ \"repeated\" ] type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\" fieldOptions = fieldOption { \",\" fieldOption } fieldOption = optionName \"=\" constant Examples:\nfoo.Bar nested_message = 2; repeated int32 samples = 4 [packed=true]; Oneof and Oneof Field A oneof consists of oneof fields and a oneof name.\noneof = \"oneof\" oneofName \"{\" { option | oneofField } \"}\" oneofField = type fieldName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\" Example:\noneof foo { string name = 4; SubMessage sub_message = 9; } Map Field A map field has a key type, value type, name, and field number. The key type can be any integral or string type.\nmapField = \"map\" \"\u003c\" keyType \",\" type \"\u003e\" mapName \"=\" fieldNumber [ \"[\" fieldOptions \"]\" ] \";\" keyType = \"int32\" | \"int64\" | \"uint32\" | \"uint64\" | \"sint32\" | \"sint64\" | \"fixed32\" | \"fixed64\" | \"sfixed32\" | \"sfixed64\" | \"bool\" | \"string\" Example:\nmap\u003cstring, Project\u003e projects = 3; Reserved Reserved statements declare a range of field numbers or field names that cannot be used in this message.\nreserved = \"reserved\" ( ranges | strFieldNames ) \";\" ranges = range { \",\" range } range = intLit [ \"to\" ( intLit | \"max\" ) ] strFieldNames = strFieldName { \",\" strFieldName } strFieldName = \"'\" fieldName \"'\" | '\"' fieldName '\"' Examples:\nreserved 2, 15, 9 to 11; reserved \"foo\", \"bar\"; Top Level Definitions Enum Definition The enum definition consists of a name and an enum body. The enum body can have options, enum fields, and reserved statements.\nenum = \"enum\" enumName enumBody enumBody = \"{\" { option | enumField | emptyStatement | reserved } \"}\" enumField = ident \"=\" [ \"-\" ] intLit [ \"[\" enumValueOption { \",\" enumValueOption } \"]\" ]\";\" enumValueOption = optionName \"=\" constant Example:\nenum EnumAllowingAlias { option allow_alias = true; EAA_UNSPECIFIED = 0; EAA_STARTED = 1; EAA_RUNNING = 2 [(custom_option) = \"hello world\"]; } Message Definition A message consists of a message name and a message body. The message body can have fields, nested enum definitions, nested message definitions, options, oneofs, map fields, and reserved statements.\nmessage = \"message\" messageName messageBody messageBody = \"{\" { field | enum | message | option | oneof | mapField | reserved | emptyStatement } \"}\" Example:\nmessage Outer { option (my_option).a = true; message Inner { // Level 2 int64 ival = 1; } map\u003cint32, string\u003e my_map = 2; } None of the entities declared inside a message may have conflicting names. All of the following are prohibited:\nmessage MyMessage { optional string foo = 1; message foo {} } message MyMessage { optional string foo = 1; oneof foo { string bar = 2; } } message MyMessage { optional string foo = 1; enum E { foo = 0; } } Service Definition service = \"service\" serviceName \"{\" { option | rpc | emptyStatement } \"}\" rpc = \"rpc\" rpcName \"(\" [ \"stream\" ] messageType \")\" \"returns\" \"(\" [ \"stream\" ] messageType \")\" (( \"{\" {option | emptyStatement } \"}\" ) | \";\") Example:\nservice SearchService { rpc Search (SearchRequest) returns (SearchResponse); } Proto File proto = syntax { import | package | option | topLevelDef | emptyStatement } topLevelDef = message | enum | service An example .proto file:\nsyntax = \"proto3\"; import public \"other.proto\"; option java_package = \"com.example.foo\"; enum EnumAllowingAlias { option allow_alias = true; EAA_UNSPECIFIED = 0; EAA_STARTED = 1; EAA_RUNNING = 1; EAA_FINISHED = 2 [(custom_option) = \"hello world\"]; } message Outer { option (my_option).a = true; message Inner { // Level 2 int64 ival = 1; } repeated Inner inner_message = 2; EnumAllowingAlias enum_field = 3; map\u003cint32, string\u003e my_map = 4; } ","categories":"","description":"This topic is a language specification reference for version 3 of the Protocol Buffers language (proto3).","excerpt":"This topic is a language specification reference for version 3 of the …","ref":"/reference/protobuf/proto3-spec/","tags":"","title":"Protocol Buffers Version 3 Language Specification"},{"body":"The protocol buffer Text Format Language specifies a syntax for representation of protobuf data in text form, which is often useful for configurations or tests. This format is distinct from the format of text within a .proto schema, for example. This document contains reference documentation using the syntax specified in ISO/IEC 14977 EBNF.\nNote This is a draft spec reverse-engineered from the C++ text format implementation and may change based on further discussion and review. While an effort has been made to keep text formats consistent across supported languages, incompatibilities are likely to exist. Example convolution_benchmark { label: \"NHWC_128x20x20x56x160\" input { dimension: [128, 56, 20, 20] data_type: DATA_HALF format: TENSOR_NHWC } } Parsing Overview The language elements in this spec are split into lexical and syntactic categories. Lexical elements must match the input text exactly as described, but syntactic elements may be separated by optional WHITESPACE and COMMENT tokens.\nFor example, a signed floating point value comprises two syntactic elements: the sign (-) and the FLOAT literal. Optional whitespace and comments may exist between the sign and the number, but not within the number. Example:\nvalue: -2.0 # Valid: no additional whitespace. value: - 2.0 # Valid: whitespace between '-' and '2.0'. value: - # comment 2.0 # Valid: whitespace and comments between '-' and '2.0'. value: 2 . 0 # Invalid: the floating point period is part of the lexical # element, so no additional whitespace is allowed. There is one edge case that requires special attention: a number token (FLOAT, DEC_INT, OCT_INT, or HEX_INT) may not be immediately followed by an IDENT token. Example:\nfoo: 10 bar: 20 # Valid: whitespace separates '10' and 'bar' foo: 10,bar: 20 # Valid: ',' separates '10' and 'bar' foo: 10[com.foo.ext]: 20 # Valid: '10' is followed immediately by '[', which is # not an identifier. foo: 10bar: 20 # Invalid: no space between '10' and identifier 'bar'. Lexical Elements The lexical elements described below fall into two categories: uppercase primary elements and lowercase fragments. Only primary elements are included in the output stream of tokens used during syntactic analysis; fragments exist only to simplify construction of primary elements.\nWhen parsing input text, the longest matching primary element wins. Example:\nvalue: 10 # '10' is parsed as a DEC_INT token. value: 10f # '10f' is parsed as a FLOAT token, despite containing '10' which # would also match DEC_INT. In this case, FLOAT matches a longer # subsequence of the input. Characters char = ? Any non-NUL unicode character ? ; newline = ? ASCII #10 (line feed) ? ; letter = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\" | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\" | \"_\" ; oct = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" ; dec = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" ; hex = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" ; Whitespace and Comments COMMENT = \"#\", { char - newline }, [ newline ] ; WHITESPACE = \" \" | newline | ? ASCII #9 (horizontal tab) ? | ? ASCII #11 (vertical tab) ? | ? ASCII #12 (form feed) ? | ? ASCII #13 (carriage return) ? ; Identifiers IDENT = letter, { letter | dec } ; Numeric Literals dec_lit = \"0\" | ( dec - \"0\" ), { dec } ; float_lit = \".\", dec, { dec }, [ exp ] | dec_lit, \".\", { dec }, [ exp ] | dec_lit, exp ; exp = ( \"E\" | \"e\" ), [ \"+\" | \"-\" ], dec, { dec } ; DEC_INT = dec_lit OCT_INT = \"0\", oct, { oct } ; HEX_INT = \"0\", ( \"X\" | \"x\" ), hex, { hex } ; FLOAT = float_lit, [ \"F\" | \"f\" ] | dec_lit, ( \"F\" | \"f\" ) ; Decimal integers can be cast as floating-point values by using the F and f suffixes. Example:\nfoo: 10 # This is an integer value. foo: 10f # This is a floating-point value. foo: 1.0f # Also optional for floating-point literals. String Literals STRING = single_string | double_string ; single_string = \"'\", { escape | char - \"'\" - newline - \"\\\" }, \"'\" ; double_string = '\"', { escape | char - '\"' - newline - \"\\\" }, '\"' ; escape = \"\\a\" (* ASCII #7 (bell) *) | \"\\b\" (* ASCII #8 (backspace) *) | \"\\f\" (* ASCII #12 (form feed) *) | \"\\n\" (* ASCII #10 (line feed) *) | \"\\r\" (* ASCII #13 (carriage return) *) | \"\\t\" (* ASCII #9 (horizontal tab) *) | \"\\v\" (* ASCII #11 (vertical tab) *) | \"\\?\" (* ASCII #63 (question mark) *) | \"\\\\\" (* ASCII #92 (backslash) *) | \"\\'\" (* ASCII #39 (apostrophe) *) | '\\\"' (* ASCII #34 (quote) *) | \"\\\", oct, [ oct, [ oct ] ] (* UTF-8 byte in octal *) | \"\\x\", hex, [ hex ] (* UTF-8 byte in hexadecimal *) | \"\\u\", hex, hex, hex, hex (* Unicode code point up to 0xffff *) | \"\\U000\", hex, hex, hex, hex, hex (* Unicode code point up to 0xfffff *) | \"\\U0010\", hex, hex, hex, hex ; (* Unicode code point between 0x100000 and 0x10ffff *) Longer strings can be broken into several quoted strings on successive lines. For example:\nquote: \"When we got into office, the thing that surprised me most was to find \" \"that things were just as bad as we'd been saying they were.\\n\\n\" \" -- John F. Kennedy\" Unicode code points are interpreted per Unicode 13 Table A-1 Extended BNF and are encoded as UTF-8.\nWarning The C++ implementation currently interprets escaped high-surrogate code points as UTF-16 code units, and expects a \\uHHHH low-surrogate code point to immediately follow, without any split across separate quoted strings. In addition, unpaired surrogates will be rendered directly into also-invalid UTF-8. These are both non-conforming behaviors[^surrogates] and should not be relied on. Syntax Elements Message A message is a collection of fields. A text format file is a single Message.\nMessage = { Field } ; Literals Field literal values can be numbers, strings, or identifiers such as true or enum values.\nString = STRING, { STRING } ; Float = [ \"-\" ], FLOAT ; Identifier = IDENT ; SignedIdentifier = \"-\", IDENT ; (* For example, \"-inf\" *) DecSignedInteger = \"-\", DEC_INT ; OctSignedInteger = \"-\", OCT_INT ; HexSignedInteger = \"-\", HEX_INT ; DecUnsignedInteger = DEC_INT ; OctUnsignedInteger = OCT_INT ; HexUnsignedInteger = HEX_INT ; A single string value can comprise multiple quoted parts separated by optional whitespace. Example:\na_string: \"first part\" 'second part' \"third part\" no_whitespace: \"first\"\"second\"'third''fourth' Field Names Fields that are part of the containing message use simple Identifiers as names. Extension and Any field names are wrapped in square brackets and fully-qualified. Any field names are prefixed with a qualifying domain name, such as type.googleapis.com/.\nFieldName = ExtensionName | AnyName | IDENT ; ExtensionName = \"[\", TypeName, \"]\" ; AnyName = \"[\", Domain, \"/\", TypeName, \"]\" ; TypeName = IDENT, { \".\", IDENT } ; Domain = IDENT, { \".\", IDENT } ; Regular fields and extension fields can have scalar or message values. Any fields are always messages. Example:\nreg_scalar: 10 reg_message { foo: \"bar\" } [com.foo.ext.scalar]​: 10 [com.foo.ext.message] { foo: \"bar\" } any_value { [type.googleapis.com/com.foo.any] { foo: \"bar\" } } Fields Field values can be literals (strings, numbers, or identifiers), or nested messages.\nField = ScalarField | MessageField ; MessageField = FieldName, [ \":\" ], ( MessageValue | MessageList ) [ \";\" | \",\" ]; ScalarField = FieldName, \":\", ( ScalarValue | ScalarList ) [ \";\" | \",\" ]; MessageList = \"[\", [ MessageValue, { \",\", MessageValue } ], \"]\" ; ScalarList = \"[\", [ ScalarValue, { \",\", ScalarValue } ], \"]\" ; MessageValue = \"{\", Message, \"}\" | \"\u003c\", Message, \"\u003e\" ; ScalarValue = String | Float | Identifier | SignedIdentifier | DecSignedInteger | OctSignedInteger | HexSignedInteger | DecUnsignedInteger | OctUnsignedInteger | HexUnsignedInteger ; The : delimiter between the field name and value is required for scalar fields but optional for message fields (including lists). Example:\nscalar: 10 # Valid scalar 10 # Invalid scalars: [1, 2, 3] # Valid scalars [1, 2, 3] # Invalid message: {} # Valid message {} # Valid messages: [{}, {}] # Valid messages [{}, {}] # Valid Values of message fields can be surrounded by curly brackets or angle brackets:\nmessage: { foo: \"bar\" } message: \u003c foo: \"bar\" \u003e Fields marked repeated can have multiple values specified by repeating the field, using the special [] list syntax, or some combination of both. The order of values is maintained. Example:\nrepeated_field: 1 repeated_field: 2 repeated_field: [3, 4, 5] repeated_field: 6 repeated_field: [7, 8, 9] Non-repeated fields cannot use the list syntax. For example, [0] is not valid for optional or required fields. Fields marked optional can be omitted or specified once. Fields marked required must be specified exactly once.\nFields not specified in the associated .proto message are not allowed unless the field name is present in the message’s reserved field list. reserved fields, if present in any form (scalar, list, message), are simply ignored by text format.\nValue Types When a field’s associated .proto value type is known, the following value descriptions and constraints apply. For the purposes of this section, we declare the following container elements:\nsignedInteger = DecSignedInteger | OctSignedInteger | HexSignedInteger ; unsignedInteger = DecUnsignedInteger | OctUnsignedInteger | HexUnsignedInteger ; integer = signedInteger | unsignedInteger ; .proto Type Values float, double A Float, DecSignedInteger, or DecUnsignedInteger element, or an Identifier or SignedIdentifier element whose IDENT portion is equal to \"inf\", \"infinity\", or \"nan\" (case-insensitive). Overflows are treated as infinity or -infinity. Octal and hexadecimal values are not valid. Note: \"nan\" should be interpreted as Quiet NaN int32, sint32, sfixed32 Any of the integer elements in the range -0x80000000 to 0x7FFFFFFF. int64, sint64, sfixed64 Any of the integer elements in the range -0x8000000000000000 to 0x7FFFFFFFFFFFFFFF. uint32, fixed32 Any of the unsignedInteger elements in the range 0 to 0xFFFFFFFF. Note that signed values (-0) are not valid. uint64, fixed64 Any of the unsignedInteger elements in the range 0 to 0xFFFFFFFFFFFFFFFF. Note that signed values (-0) are not valid. string A String element containing valid UTF-8 data. Any escape sequences must form valid UTF-8 byte sequences when unescaped. bytes A String element, possibly including invalid UTF-8 escape sequences. bool An Identifier element or any of the unsignedInteger elements matching one of the following values. True values: \"True\", \"true\", \"t\", 1 False values: \"False\", \"false\", \"f\", 0 Any unsigned integer representation of 0 or 1 is permitted: 00, 0x0, 01, 0x1, etc. enum values An Identifier element containing an enum value name, or any of the integer elements in the range -0x80000000 to 0x7FFFFFFF containing an enum value number. It is not valid to specify a name that is not a member of the field's enum type definition. Depending on the particular protobuf runtime implementation, it may or may not be valid to specify a number that is not a member of the field's enum type definition. Text format processors not tied to a particular runtime implementation (such as IDE support) may choose to issue a warning when a provided number value is not a valid member. Note that certain names that are valid keywords in other contexts, such as \"true\" or \"infinity\", are also valid enum value names. message values A MessageValue element. Extension Fields Extension fields are specified using their qualified names. Example:\nlocal_field: 10 [com.example.ext_field]​: 20 Extension fields are generally defined in other .proto files. The text format language does not provide a mechanism for specifying the locations of files that define extension fields; instead, the parser must have prior knowledge of their locations.\nAny Fields Text format supports an expanded form of the google.protobuf.Any well-known type using a special syntax resembling extension fields. Example:\nlocal_field: 10 # An Any value using regular fields. any_value { type_url: \"type.googleapis.com/com.example.SomeType\" value: \"\\x0a\\x05hello\" # serialized bytes of com.example.SomeType } # The same value using Any expansion any_value { [type.googleapis.com/com.example.SomeType] { field1: \"hello\" } } In this example, any_value is a field of type google.protobuf.Any, and it stores a serialized com.example.SomeType message containing field1: hello.\ngroup Fields In text format, a group field uses a normal MessageValue element as its value, but is specified using the capitalized group name rather than the implicit lowercased field name. Example:\nmessage MessageWithGroup { optional group MyGroup = 1 { optional int32 my_value = 1; } } With the above .proto definition, the following text format is a valid MessageWithGroup:\nMyGroup { my_value: 1 } Similar to Message fields, the : delimiter between the group name and value is optional.\nmap Fields Text format does not provide a custom syntax for specifying map field entries. When a map field is defined in a .proto file, an implicit Entry message is defined containing key and value fields. Map fields are always repeated, accepting multiple key/value entries. Example:\nmessage MessageWithMap { map\u003cstring, int32\u003e my_map = 1; } With the above .proto definition, the following text format is a valid MessageWithMap:\nmy_map { key: \"entry1\" value: 1 } my_map { key: \"entry2\" value: 2 } # You can also use the list syntax my_map: [ { key: \"entry3\" value: 3 }, { key: \"entry4\" value: 4 } ] Both the key and value fields are optional and default to the zero value of their respective types if unspecified. If a key is duplicated, only the last-specified value will be retained in a parsed map.\noneof Fields While there is no special syntax related to oneof fields in text format, only one oneof member may be specified at a time. Specifying multiple members concurrently is not valid. Example:\nmessage OneofExample { message MessageWithOneof { optional string not_part_of_oneof = 1; oneof Example { string first_oneof_field = 2; string second_oneof_field = 3; } } repeated MessageWithOneof message = 1; } The above .proto definition results in the following text format behavior:\n# Valid: only one field from the Example oneof is set. message { not_part_of_oneof: \"always valid\" first_oneof_field: \"valid by itself\" } # Valid: the other oneof field is set. message { not_part_of_oneof: \"always valid\" second_oneof_field: \"valid by itself\" } # Invalid: multiple fields from the Example oneof are set. message { not_part_of_oneof: \"always valid\" first_oneof_field: \"not valid\" second_oneof_field: \"not valid\" } Text Format Files A text format file uses the .textproto filename suffix and contains a single Message. Text format files are UTF-8 encoded. An example textproto file is provided below.\nImportant .textproto is the canonical text format file extension and should be preferred to the alternatives, although some tools also recognize the legacy extensions .textpb and .pbtxt (METADATA files are also an exception). All other extensions are strongly discouraged; in particular, extensions such as .protoascii wrongly imply that text format is ascii-only, and others like .pb.txt are not recognized by common tooling. # This is an example of Protocol Buffer's text format. # Unlike .proto files, only shell-style line comments are supported. name: \"John Smith\" pet { kind: DOG name: \"Fluffy\" tail_wagginess: 0.65f } pet \u003c kind: LIZARD name: \"Lizzy\" legs: 4 \u003e string_value_with_escape: \"valid \\n escape\" repeated_values: [ \"one\", \"two\", \"three\" ] Header The header comments proto-file and proto-message inform developer tools of the schema, so they may provide various features.\n# proto-file: some/proto/my_file.proto # proto-message: MyMessage Working with the Format Programmatically Due to how individual Protocol Buffer implementations emit neither a consistent nor canonical text format, tools or libraries that modify TextProto files or emit TextProto output must explicitly use https://github.com/protocolbuffers/txtpbfmt to format their output.\n","categories":"","description":"The protocol buffer Text Format Language specifies a syntax for representation of protobuf data in text form, which is often useful for configurations or tests.","excerpt":"The protocol buffer Text Format Language specifies a syntax for …","ref":"/reference/protobuf/textformat-spec/","tags":"","title":"Text Format Language Specification"},{"body":"Index Any (message) Api (message) BoolValue (message) BytesValue (message) DoubleValue (message) Duration (message) Empty (message) Enum (message) EnumValue (message) Field (message) Field.Cardinality (enum) Field.Kind (enum) FieldMask (message) FloatValue (message) Int32Value (message) Int64Value (message) ListValue (message) Method (message) Mixin (message) NullValue (enum) Option (message) SourceContext (message) StringValue (message) Struct (message) Syntax (enum) Timestamp (message) Type (message) UInt32Value (message) UInt64Value (message) Value (message) Any Any contains an arbitrary serialized message along with a URL that describes the type of the serialized message.\nJSON The JSON representation of an Any value uses the regular representation of the deserialized, embedded message, with an additional field @type which contains the type URL. Example:\npackage google.profile; message Person { string first_name = 1; string last_name = 2; } { \"@type\": \"type.googleapis.com/google.profile.Person\", \"firstName\": \u003cstring\u003e, \"lastName\": \u003cstring\u003e } If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field value which holds the custom JSON in addition to the @type field. Example (for message google.protobuf.Duration):\n{ \"@type\": \"type.googleapis.com/google.protobuf.Duration\", \"value\": \"1.212s\" } Field name Type Description type_url string A URL/resource name whose content describes the type of the serialized message.\nFor URLs which use the schema http, https, or no schema, the following restrictions and interpretations apply:\nIf no schema is provided, https is assumed. The last segment of the URL's path must represent the fully qualified name of the type (as in path/google.protobuf.Duration). An HTTP GET on the URL must yield a google.protobuf.Type value in binary format, or produce an error. Applications are allowed to cache lookup results based on the URL, or have them precompiled into a binary to avoid any lookup. Therefore, binary compatibility needs to be preserved on changes to types. (Use versioned type names to manage breaking changes.) Schemas other than http, https (or the empty schema) might be used with implementation specific semantics.\nvalue bytes Must be valid serialized data of the above specified type. Api Api is a light-weight descriptor for a protocol buffer service.\nField name Type Description name string The fully qualified name of this api, including package name followed by the api's simple name. methods Method The methods of this api, in unspecified order. options Option Any metadata attached to the API. version string A version string for this api. If specified, must have the form major-version.minor-version, as in 1.10. If the minor version is omitted, it defaults to zero. If the entire version field is empty, the major version is derived from the package name, as outlined below. If the field is not empty, the version in the package name will be verified to be consistent with what is provided here. The versioning schema uses semantic versioning where the major version number indicates a breaking change and the minor version an additive, non-breaking change. Both version numbers are signals to users what to expect from different versions, and should be carefully chosen based on the product plan. The major version is also reflected in the package name of the API, which must end in v\u003cmajor-version\u003e, as in google.feature.v1. For major versions 0 and 1, the suffix can be omitted. Zero major versions must only be used for experimental, none-GA apis. source_context SourceContext Source context for the protocol buffer service represented by this message. mixins Mixin Included APIs. See Mixin. syntax Syntax The source syntax of the service. BoolValue Wrapper message for bool.\nThe JSON representation for BoolValue is JSON true and false.\nField name Type Description value bool The bool value. BytesValue Wrapper message for bytes.\nThe JSON representation for BytesValue is JSON string.\nField name Type Description value bytes The bytes value. DoubleValue Wrapper message for double.\nThe JSON representation for DoubleValue is JSON number.\nField name Type Description value double The double value. Duration A Duration represents a signed, fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like \"day\" or \"month\". It is related to Timestamp in that the difference between two Timestamp values is a Duration and it can be added or subtracted from a Timestamp. Range is approximately +-10,000 years.\nExample 1: Compute Duration from two Timestamps in pseudo code.\nTimestamp start = ...; Timestamp end = ...; Duration duration = ...; duration.seconds = end.seconds - start.seconds; duration.nanos = end.nanos - start.nanos; if (duration.seconds \u003c 0 \u0026\u0026 duration.nanos \u003e 0) { duration.seconds += 1; duration.nanos -= 1000000000; } else if (duration.seconds \u003e 0 \u0026\u0026 duration.nanos \u003c 0) { duration.seconds -= 1; duration.nanos += 1000000000; } Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.\nTimestamp start = ...; Duration duration = ...; Timestamp end = ...; end.seconds = start.seconds + duration.seconds; end.nanos = start.nanos + duration.nanos; if (end.nanos \u003c 0) { end.seconds -= 1; end.nanos += 1000000000; } else if (end.nanos \u003e= 1000000000) { end.seconds += 1; end.nanos -= 1000000000; } The JSON representation for Duration is a String that ends in s to indicate seconds and is preceded by the number of seconds, with nanoseconds expressed as fractional seconds.\nField name Type Description seconds int64 Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. nanos int32 Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 seconds field and a positive or negative nanos field. For durations of one second or more, a non-zero value for the nanos field must be of the same sign as the seconds field. Must be from -999,999,999 to +999,999,999 inclusive. Empty A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance:\nservice Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); } The JSON representation for Empty is empty JSON object {}.\nEnum Enum type definition\nField name Type Description name string Enum type name. enumvalue EnumValue Enum value definitions. options Option Protocol buffer options. source_context SourceContext The source context. syntax Syntax The source syntax. EnumValue Enum value definition.\nField name Type Description name string Enum value name. number int32 Enum value number. options Option Protocol buffer options. Field A single field of a message type.\nField name Type Description kind Kind The field type. cardinality Cardinality The field cardinality. number int32 The field number. name string The field name. type_url string The field type URL, without the scheme, for message or enumeration types. Example: \"type.googleapis.com/google.protobuf.Timestamp\". oneof_index int32 The index of the field type in Type.oneofs, for message or enumeration types. The first type has index 1; zero means the type is not in the list. packed bool Whether to use alternative packed wire representation. options Option The protocol buffer options. json_name string The field JSON name. default_value string The string value of the default value of this field. Proto2 syntax only. Cardinality Whether a field is optional, required, or repeated.\nEnum value Description CARDINALITY_UNKNOWN For fields with unknown cardinality. CARDINALITY_OPTIONAL For optional fields. CARDINALITY_REQUIRED For required fields. Proto2 syntax only. CARDINALITY_REPEATED For repeated fields. Kind Basic field types.\nEnum value Description TYPE_UNKNOWN Field type unknown. TYPE_DOUBLE Field type double. TYPE_FLOAT Field type float. TYPE_INT64 Field type int64. TYPE_UINT64 Field type uint64. TYPE_INT32 Field type int32. TYPE_FIXED64 Field type fixed64. TYPE_FIXED32 Field type fixed32. TYPE_BOOL Field type bool. TYPE_STRING Field type string. TYPE_GROUP Field type group. Proto2 syntax only, and deprecated. TYPE_MESSAGE Field type message. TYPE_BYTES Field type bytes. TYPE_UINT32 Field type uint32. TYPE_ENUM Field type enum. TYPE_SFIXED32 Field type sfixed32. TYPE_SFIXED64 Field type sfixed64. TYPE_SINT32 Field type sint32. TYPE_SINT64 Field type sint64. FieldMask FieldMask represents a set of symbolic field paths, for example:\npaths: \"f.a\" paths: \"f.b.d\" Here f represents a field in some root message, a and b fields in the message found in f, and d a field found in the message in f.b.\nField masks are used to specify a subset of fields that should be returned by a get operation (a projection), or modified by an update operation. Field masks also have a custom JSON encoding (see below).\nField Masks in Projections When a FieldMask specifies a projection, the API will filter the response message (or sub-message) to contain only those fields specified in the mask. For example, consider this \"pre-masking\" response message:\nf { a : 22 b { d : 1 x : 2 } y : 13 } z: 8 After applying the mask in the previous example, the API response will not contain specific values for fields x, y, or z (their value will be set to the default, and omitted in proto text output):\nf { a : 22 b { d : 1 } } A repeated field is not allowed except at the last position of a field mask.\nIf a FieldMask object is not present in a get operation, the operation applies to all fields (as if a FieldMask of all fields had been specified).\nNote that a field mask does not necessarily apply to the top-level response message. In case of a REST get operation, the field mask applies directly to the response, but in case of a REST list operation, the mask instead applies to each individual message in the returned resource list. In case of a REST custom method, other definitions may be used. Where the mask applies will be clearly documented together with its declaration in the API. In any case, the effect on the returned resource/resources is required behavior for APIs.\nField Masks in Update Operations A field mask in update operations specifies which fields of the targeted resource are going to be updated. The API is required to only change the values of the fields as specified in the mask and leave the others untouched. If a resource is passed in to describe the updated values, the API ignores the values of all fields not covered by the mask.\nIn order to reset a field’s value to the default, the field must be in the mask and set to the default value in the provided resource. Hence, in order to reset all fields of a resource, provide a default instance of the resource and set all fields in the mask, or do not provide a mask as described below.\nIf a field mask is not present on update, the operation applies to all fields (as if a field mask of all fields has been specified). Note that in the presence of schema evolution, this may mean that fields the client does not know and has therefore not filled into the request will be reset to their default. If this is unwanted behavior, a specific service may require a client to always specify a field mask, producing an error if not.\nAs with get operations, the location of the resource which describes the updated values in the request message depends on the operation kind. In any case, the effect of the field mask is required to be honored by the API.\nConsiderations for HTTP REST The HTTP kind of an update operation which uses a field mask must be set to PATCH instead of PUT in order to satisfy HTTP semantics (PUT must only be used for full updates).\nJSON Encoding of Field Masks In JSON, a field mask is encoded as a single string where paths are separated by a comma. Fields name in each path are converted to/from lower-camel naming conventions.\nAs an example, consider the following message declarations:\nmessage Profile { User user = 1; Photo photo = 2; } message User { string display_name = 1; string address = 2; } In proto a field mask for Profile may look as such:\nmask { paths: \"user.display_name\" paths: \"photo\" } In JSON, the same mask is represented as below:\n{ mask: \"user.displayName,photo\" } Field name Type Description paths string The set of field mask paths. FloatValue Wrapper message for float.\nThe JSON representation for FloatValue is JSON number.\nField name Type Description value float The float value. Int32Value Wrapper message for int32.\nThe JSON representation for Int32Value is JSON number.\nField name Type Description value int32 The int32 value. Int64Value Wrapper message for int64.\nThe JSON representation for Int64Value is JSON string.\nField name Type Description value int64 The int64 value. ListValue ListValue is a wrapper around a repeated field of values.\nThe JSON representation for ListValue is JSON array.\nField name Type Description values Value Repeated field of dynamically typed values. Method Method represents a method of an api.\nField name Type Description name string The simple name of this method. request_type_url string A URL of the input message type. request_streaming bool If true, the request is streamed. response_type_url string The URL of the output message type. response_streaming bool If true, the response is streamed. options Option Any metadata attached to the method. syntax Syntax The source syntax of this method. Mixin Declares an API to be included in this API. The including API must redeclare all the methods from the included API, but documentation and options are inherited as follows:\nIf after comment and whitespace stripping, the documentation string of the redeclared method is empty, it will be inherited from the original method.\nEach annotation belonging to the service config (http, visibility) which is not set in the redeclared method will be inherited.\nIf an http annotation is inherited, the path pattern will be modified as follows. Any version prefix will be replaced by the version of the including API plus the root path if specified.\nExample of a simple mixin:\npackage google.acl.v1; service AccessControl { // Get the underlying ACL object. rpc GetAcl(GetAclRequest) returns (Acl) { option (google.api.http).get = \"/v1/{resource=**}:getAcl\"; } } package google.storage.v2; service Storage { // rpc GetAcl(GetAclRequest) returns (Acl); // Get a data record. rpc GetData(GetDataRequest) returns (Data) { option (google.api.http).get = \"/v2/{resource=**}\"; } } Example of a mixin configuration:\napis: - name: google.storage.v2.Storage mixins: - name: google.acl.v1.AccessControl The mixin construct implies that all methods in AccessControl are also declared with same name and request/response types in Storage. A documentation generator or annotation processor will see the effective Storage.GetAcl method after inherting documentation and annotations as follows:\nservice Storage { // Get the underlying ACL object. rpc GetAcl(GetAclRequest) returns (Acl) { option (google.api.http).get = \"/v2/{resource=**}:getAcl\"; } ... } Note how the version in the path pattern changed from v1 to v2.\nIf the root field in the mixin is specified, it should be a relative path under which inherited HTTP paths are placed. Example:\napis: - name: google.storage.v2.Storage mixins: - name: google.acl.v1.AccessControl root: acls This implies the following inherited HTTP annotation:\nservice Storage { // Get the underlying ACL object. rpc GetAcl(GetAclRequest) returns (Acl) { option (google.api.http).get = \"/v2/acls/{resource=**}:getAcl\"; } ... } Field name Type Description name string The fully qualified name of the API which is included. root string If non-empty specifies a path under which inherited HTTP paths are rooted. NullValue NullValue is a singleton enumeration to represent the null value for the Value type union.\nThe JSON representation for NullValue is JSON null.\nEnum value Description NULL_VALUE Null value. Option A protocol buffer option, which can be attached to a message, field, enumeration, etc.\nField name Type Description name string The option's name. For example, \"java_package\". value Any The option's value. For example, \"com.google.protobuf\". SourceContext SourceContext represents information about the source of a protobuf element, like the file in which it is defined.\nField name Type Description file_name string The path-qualified name of the .proto file that contained the associated protobuf element. For example: \"google/protobuf/source.proto\". StringValue Wrapper message for string.\nThe JSON representation for StringValue is JSON string.\nField name Type Description value string The string value. Struct Struct represents a structured data value, consisting of fields which map to dynamically typed values. In some languages, Struct might be supported by a native representation. For example, in scripting languages like JS a struct is represented as an object. The details of that representation are described together with the proto support for the language.\nThe JSON representation for Struct is JSON object.\nField name Type Description fields map\u003cstring, Value\u003e Map of dynamically typed values. Syntax The syntax in which a protocol buffer element is defined.\nEnum value Description SYNTAX_PROTO2 Syntax proto2. SYNTAX_PROTO3 Syntax proto3. Timestamp A Timestamp represents a point in time independent of any time zone or calendar, represented as seconds and fractions of seconds at nanosecond resolution in UTC Epoch time. It is encoded using the Proleptic Gregorian Calendar which extends the Gregorian calendar backwards to year one. It is encoded assuming all minutes are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By restricting to that range, we ensure that we can convert to and from RFC 3339 date strings. See https://www.ietf.org/rfc/rfc3339.txt.\nExample 1: Compute Timestamp from POSIX time().\nTimestamp timestamp; timestamp.set_seconds(time(NULL)); timestamp.set_nanos(0); Example 2: Compute Timestamp from POSIX gettimeofday().\nstruct timeval tv; gettimeofday(\u0026tv, NULL); Timestamp timestamp; timestamp.set_seconds(tv.tv_sec); timestamp.set_nanos(tv.tv_usec * 1000); Example 3: Compute Timestamp from Win32 GetSystemTimeAsFileTime().\nFILETIME ft; GetSystemTimeAsFileTime(\u0026ft); UINT64 ticks = (((UINT64)ft.dwHighDateTime) \u003c\u003c 32) | ft.dwLowDateTime; // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z. Timestamp timestamp; timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL)); timestamp.set_nanos((INT32) ((ticks % 10000000) * 100)); Example 4: Compute Timestamp from Java System.currentTimeMillis().\nlong millis = System.currentTimeMillis(); Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000) .setNanos((int) ((millis % 1000) * 1000000)).build(); Example 5: Compute Timestamp from current time in Python.\nnow = time.time() seconds = int(now) nanos = int((now - seconds) * 10**9) timestamp = Timestamp(seconds=seconds, nanos=nanos) Field name Type Description seconds int64 Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive. nanos int32 Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. Type A protocol buffer message type.\nField name Type Description name string The fully qualified message name. fields Field The list of fields. oneofs string The list of types appearing in oneof definitions in this type. options Option The protocol buffer options. source_context SourceContext The source context. syntax Syntax The source syntax. UInt32Value Wrapper message for uint32.\nThe JSON representation for UInt32Value is JSON number.\nField name Type Description value uint32 The uint32 value. UInt64Value Wrapper message for uint64.\nThe JSON representation for UInt64Value is JSON string.\nField name Type Description value uint64 The uint64 value. Value Value represents a dynamically typed value which can be either null, a number, a string, a boolean, a recursive struct value, or a list of values. A producer of value is expected to set one of that variants, absence of any variant indicates an error.\nThe JSON representation for Value is JSON value.\nField name Type Description Union field, only one of the following: null_value NullValue Represents a null value. number_value double Represents a double value. Note that attempting to serialize NaN or Infinity results in error. (We can't serialize these as string \"NaN\" or \"Infinity\" values like we do for regular fields, because they would parse as string_value, not number_value). string_value string Represents a string value. bool_value bool Represents a boolean value. struct_value Struct Represents a structured value. list_value ListValue Represents a repeated Value. ","categories":"","description":"API documentation for the google.protobuf package.","excerpt":"API documentation for the google.protobuf package.","ref":"/reference/protobuf/google.protobuf/","tags":"","title":"Protocol Buffers Well-Known Types"},{"body":"While the current release includes compilers and APIs for C++, Java, Go, Ruby, C#, and Python, the compiler code is designed so that it’s easy to add support for other languages. There are several ongoing projects to add new language implementations to Protocol Buffers, including C, Haskell, Perl, Rust, and more.\nFor a list of links to projects we know about, see the third-party add-ons wiki page.\nCompiler Plugins protoc, the Protocol Buffers Compiler, can be extended to support new languages via plugins. A plugin is just a program which reads a CodeGeneratorRequest protocol buffer from standard input and then writes a CodeGeneratorResponse protocol buffer to standard output. These message types are defined in plugin.proto. We recommend that all third-party code generators be written as plugins, as this allows all generators to provide a consistent interface and share a single parser implementation.\nAdditionally, plugins are able to insert code into the files generated by other code generators. See the comments about \"insertion points\" in plugin.proto for more on this. This could be used, for example, to write a plugin which generates RPC service code that is tailored for a particular RPC system. See the documentation for the generated code in each language to find out what insertion points they provide.\n","categories":"","description":"protoc, the Protocol Buffers Compiler, can be extended to support new languages via plugins.","excerpt":"protoc, the Protocol Buffers Compiler, can be extended to support new …","ref":"/reference/other/","tags":"","title":"Other Languages"},{"body":"This section of the documentation contains topics related to the support that the Protocol Buffers team provides to developers, including the timeframes for support for each version of a language library and migration guides to help you keep up with major version bumps.\nVersion Support Migration Guide Cross-Version Runtime Guarantee Support Forum ","categories":"","description":"Get the latest news about Protocol Buffers.","excerpt":"Get the latest news about Protocol Buffers.","ref":"/support/","tags":"","title":"Support"},{"body":" Support windows for protoc and the various languages are covered in the tables later in this topic. Version numbers throughout this topic use SemVer conventions; in the version “3.21.7,” we say that “3” is the major version, “21” is the minor version, and “7” is the micro or patch number.\nStarting with the v20.x protoc release, we changed our versioning scheme to enable nimbler updates to language-specific parts of Protocol Buffers. In the new scheme, each language has its own major version that can be incremented independently of other languages. The minor and patch versions, however, remain coupled. This allows us to introduce breaking changes into some languages without requiring a bump of the major version in languages that do not experience a breaking change. For example, a single release might include protoc version 24.0, Java runtime version 4.24.0 and C# runtime version 3.24.0.\nThe first instance of this new versioning scheme was the 4.21.0 version of the Python API, which followed the preceding version, 3.20.1. Other language APIs released at the same time were released as 3.21.0.\nRelease Cadence Protobuf does not officially have a release cadence; however, we strive to release updates quarterly, on a best-effort basis. Our support windows are defined by our library breaking change policy.\nSupport Duration The most recent release is always supported. Support for earlier minor versions ends when a new minor version under the same major version is released. Support for earlier major verions ends four quarters beyond the quarter that the breaking release is introduced. For example, when Python 4.21.0 was released in May of 2022, that set the end of public support of Python 3.20.1 at the end of 2023 Q2.\nThe following sections provide a visual guide to the support for each language.\nC++ The C++ 3.21.x runtime was first released in 2022 Q2 and has support until 2024 Q1. The C++ 4.22.x runtime was first released in 2023 Q1.\nprotoc C++ 21Q4 22Q1 22Q2 22Q3 22Q4 23Q1 23Q2 23Q3 23Q4 24Q1 19.x 3.19.x IR 20.x 3.20.x IR 21.x 3.21.x IR PS PS PS PS PS PS SE 22.x 4.22.x IR PS PS PS PS The cells below are projections of future releases, but are not guarantees that those releases will happen, or that they will happen on that schedule. 23.x IR 24.x IR Legend Initial release (IR) Public support (PS) Support ends (SE) C++ Tooling, Platform, and Library Support Protobuf is committed to following the tooling, platform, and library support policy described in Foundational C++ Support Policy. For specific versions supported, see Foundational C++ Support.\nC# The C# 3.22.x runtime was first released in 2023 Q1.\nprotoc C# 21Q4 22Q1 22Q2 22Q3 22Q4 23Q1 23Q2 23Q3 19.x 3.19.x IR 20.x 3.20.x IR 21.x 3.21.x IR PS PS 22.x 3.22.x IR PS PS The cells below are projections of future releases, but are not guarantees that those releases will happen, or that they will happen on that schedule. 23.x IR 24.x IR Legend Initial release (IR) Public support (PS) Support ends (SE) Java The Java 3.22.x runtime was first released in 2023 Q1.\nprotoc Java 21Q4 22Q1 22Q2 22Q3 22Q4 23Q1 23Q2 23Q3 23Q4 24Q1 24Q2 24Q3 19.x 3.19.x IR 20.x 3.20.x IR 21.x 3.21.x IR PS PS 22.x 3.22.x IR PS PS PS PS PS PS The cells below are projections of future releases, but are not guarantees that those releases will happen, or that they will happen on that schedule. 23.x IR 24.x IR Legend Initial release (IR) Public support (PS) Support ends (SE) Objective-C The Objective-C 3.22.x runtime was first released in 2023 Q1.\nprotoc ObjC 21Q4 22Q1 22Q2 22Q3 22Q4 23Q1 23Q2 23Q3 19.x 3.19.x IR 20.x 3.20.x IR 21.x 3.21.x IR PS PS 22.x 3.22.x IR PS PS The cells below are projections of future releases, but are not guarantees that those releases will happen, or that they will happen on that schedule. 23.x IR 24.x IR Legend Initial release (IR) Public support (PS) Support ends (SE) PHP The PHP 3.22.x runtime was first released in 2023 Q1.\nprotoc PHP 21Q4 22Q1 22Q2 22Q3 22Q4 23Q1 23Q2 23Q3 19.x 3.19.x IR 20.x 3.20.x IR 21.x 3.21.x IR PS PS 22.x 3.22.x IR PS PS The cells below are projections of future releases, but are not guarantees that those releases will happen, or that they will happen on that schedule. 23.x IR 24.x IR Legend Initial release (IR) Public support (PS) Support ends (SE) Python The Python 3.20.x runtime was first released in 2022 Q1 and has support until 2023 Q2. The Python 4.22.x runtime was first released in 2023 Q1.\nprotoc Python 21Q4 22Q1 22Q2 22Q3 22Q4 23Q1 23Q2 23Q3 19.x 3.19.x IR 20.x 3.20.x IR PS PS PS PS SE 21.x 4.21.x IR PS PS 22.x 4.22.x IR PS PS The cells below are projections of future releases, but are not guarantees that those releases will happen, or that they will happen on that schedule. 23.x IR 24.x IR Legend Initial release (IR) Public support (PS) Support ends (SE) Ruby The Ruby 3.22.x runtime was first released in 2023 Q1.\nprotoc Ruby 21Q4 22Q1 22Q2 22Q3 22Q4 23Q1 23Q2 23Q3 23Q4 24Q1 19.x 3.19.x IR 20.x 3.20.x IR 21.x 3.21.x IR PS PS 22.x 3.22.x IR PS PS PS PS The cells below are projections of future releases, but are not guarantees that those releases will happen, or that they will happen on that schedule. 23.x IR 24.x IR Legend Initial release (IR) Public support (PS) Support ends (SE) ","categories":"","description":"A list of the support windows provided for language implementations.","excerpt":"A list of the support windows provided for language implementations.","ref":"/support/version-support/","tags":"","title":"Version Support"},{"body":"This topic provides information about breaking changes in Protocol Buffers, and gives guidance on how to update your projects to adapt to those changes.\nCompiler Changes in v22.0 JSON Field Name Conflicts Source of changes: PR #11349, PR #10750\nWe’ve made some subtle changes in how we handle field name conflicts with respect to JSON mappings. In proto3, we’ve partially loosened the restrictions and only give errors when field names produce case-sensitive JSON mappings (camel case of the original name). We now also check the json_name option, and give errors for case-sensitive conflicts. In proto2, we’ve tightened restrictions a bit and will give errors if two json_name specifications conflict. If implicit JSON mappings (camel case) have conflicts, we will give warnings in proto2.\nWe’ve provided a temporary message/enum option for restoring the legacy behavior. If renaming the conflicting fields isn’t an option you can take immediately, set the deprecated_legacy_json_field_conflicts option on the specific message/enum. This option will be removed in a future release, but gives you more time to migrate.\nC++ API Changes in v22.0 4.22.0 has breaking changes for C++ runtime and protoc, as announced in August.\nAutotools Turndown Source of changes: PR #10132\nIn v22.0, we removed all Autotools support from the protobuf compiler and the C++ runtime. If you’re using Autotools to build either of these, you must migrate to CMake or Bazel. We have some dedicated instructions for setting up protobuf with CMake.\nAbseil Dependency Source of changes: PR #10416\nWith v22.0, we’ve taken on an explicit dependency on Abseil. This allowed us to remove most of our stubs, which were branched from old internal code that later became Abseil. There are a number of subtle behavior changes, but most should be transparent to users. Some notable changes include:\nstring_view - absl::string_view has replaced const std::string\u0026 in many of our APIs. This is most-commonly used for input arguments, where there should be no noticeable change for users. In a few cases (such as virtual method arguments or return types) users may need to make an explicit change to use the new signature.\ntables - Instead of STL sets/maps, we now use Abseil’s flat_hash_map, flat_hash_set, btree_map, and btree_set. These are more efficient and allow for heterogeneous lookup. This should be mostly invisible to users, but may cause some subtle behavior changes related to table ordering.\nlogging - Abseil’s logging library is very similar to our old logging code, with just a slightly different spelling (for example, ABSL_CHECK instead of GOOGLE_CHECK). The biggest difference is that it doesn’t support exceptions, and will now always crash when FATAL assertions fail. (Previously we had a PROTOBUF_USE_EXCEPTIONS flag to switch to exceptions.) Since these only occur when serious issues are encountered, we feel unconditional crashing is a suitable response.\nSource of logging changes: PR #11623\nBuild dependency - A new build dependency can always cause breakages for downstream users. We require Abseil LTS 20230117 or later to build.\nFor Bazel builds, Abseil will be automatically downloaded and built at a pinned LTS release when protobuf_deps is run from your WORKSPACE. This should be transparent, but if you depend on an older version of Abseil, you’ll need to upgrade your dependency.\nFor CMake builds, we will first look for an existing Abseil installation pulled in by the top-level CMake configuration (see instructions). Otherwise, if protobuf_ABSL_PROVIDER is set to module (its default) we will attempt to build and link Abseil from our git submodule. If protobuf_ABSL_PROVIDER is set to package, we will look for a pre-installed system version of Abseil.\nC++20 Support Source of changes: PR #10796\nTo support C++20, we’ve reserved the new keywords in C++ generated protobuf code. As with other reserved keywords, if you use them for any fields, enums, or messages, we will add an underscore suffix to make them valid C++. For example, a concept field will generate a concept_() getter. In the scenario where you have existing protos that use these keywords, you’ll need to update the C++ code that references them to add the appropriate underscores.\nFinal Classes Source of changes: PR #11604\nAs part of a larger effort to harden assumptions made in the Protobuf library, we’ve marked some classes final that were never intended to be inherited from. There are no known use cases for inheriting from these, and doing so would likely cause problems. There is no mitigation if your code is inheriting from these classes, but if you think you have some valid reason for the inheritance you’re using, you can open an issue.\nContainer Static Assertions Source of changes: PR #11550\nAs part of a larger effort to harden assumptions made in the Protobuf library, we’ve added static assertions to the Map, RepeatedField, and RepeatedPtrField containers. These ensure that you’re using these containers with only expected types, as covered in our documentation. If you hit these static assertions, you should migrate your code to use Abseil or STL containers. std::vector is a good drop-in replacement for repeated field containers, and std::unordered_map or absl::flat_hash_map for Map (the former gives similar pointer stability, while the latter is more efficient).\nCleared Element Deprecation Source of changes: PR #11588, PR #11639\nThe RepeatedPtrField API around “cleared fields” has been deprecated, and will be fully removed in a later breaking release. This was originally added as an optimization for reusing elements after they’ve been cleared, but ended up not working well. If you’re using this API, you should consider migrating to arenas for better memory reuse.\nUnsafeArena Deprecation Source of changes: PR #10325\nAs part of a larger effort to remove arena-unsafe APIs, we’ve hidden RepeatedField::UnsafeArenaSwap. This is the only one we’ve removed so far, but in later releases we will continue to remove them and provide helpers to handle efficient borrowing patterns between arenas. Within a single arena (or the stack/heap), Swap is just as efficient as UnsafeArenaSwap. The benefit is that it won’t cause invalid memory operations if you accidentally call it across different arenas.\nMap Pair Upgrades Source of changes: PR #11625\nFor v22.0 we’ve started cleaning up the Map API to make it more consistent with Abseil and STL. Notably, we’ve replaced the MapPair class with an alias to std::pair. This should be transparent for most users, but if you were using the class directly you may need to update your code.\nNew JSON Parser {:#json-parser} Source of changes: PR #10729\nWe have rewritten the C++ JSON parser this release. It should be mostly a hidden change, but inevitably some undocumented quirks my have changed; test accordingly. Parsing documents that are not valid RFC-8219 JSON (such as those that are missing quotes or using non-standard bools) is deprecated and will be removed in a future release. The serialization order of fields is now guaranteed to match the field number order, where before it was less deterministic.\nAs part of this migration, all of the files under util/internal have been deleted. These were used in the old parser, and were never intended to be used externally.\nArena::Init Source of changes: PR #10623\nThe Init method in Arena was code that didn’t do anything, and has now been removed. If you were calling this method, you likely meant to call the Arena constructor directly with a set of ArenaOptions. You should either delete the call or migrate to that constructor.\nErrorCollector Migration Source of changes: PR #11555\nAs part of our Abseil migration, we’re moving from const std::string\u0026 to absl::string_view. For our three error collector classes, this can’t be done without breaking existing code. For v22.0, we’ve decided to release both variants, and rename the methods from AddError and AddWarning to RecordError and RecordWarning. The old signature has been marked deprecated, and will be slightly less efficient (due to string copies), but will otherwise still work. You should migrate these to the new version, as the Add* methods will be removed in a later breaking release.\n","categories":"","description":"A list of the breaking changes made to versions of the libraries, and how to update your code to accommodate the changes.","excerpt":"A list of the breaking changes made to versions of the libraries, and …","ref":"/support/migration/","tags":"","title":"Migration Guide"},{"body":" Protobuf language bindings have two components. The generated code (typically produced from protoc) and the runtime libraries that must be included when using the generated code. When these come from different releases of protobuf, we are in a “cross version runtime” situation.\nHistorically, protobuf has not documented its cross-version runtime compatibility guarantees and has been inconsistent about enforcing what guarantees it provides. Moving forward, we intend to offer the following guarantees across all languages except C++. These are the default guarantees; however, owners of protobuf code generators and runtimes may explicitly override them with more specific guarantees for that language.\nMajor Versions Protobuf will not support mixing generated code and runtimes across major version boundaries. We will add “poison pills” where possible to detect these mismatches.\nMinor Versions Within a single major runtime version, generated code from an older version of protoc will run on a newer runtime.\nWithin a single major runtime version, generated code from a newer version of protoc is not guaranteed to run on an older runtime. We will add “poison pills” where possible to detect these mismatches.\nSecurity Exception We reserve the right to violate the above promises if needed for security reasons. We expect these exceptions to be rare, but will always prioritize security above these guarantees. For example, footmitten required paired updates to both the runtime and the generated code for Java. As a result, code generated by 3.20.3 (which contained the footmitten fix) would not load with runtime library 3.21.6 (which predates the footmitten fix), creating the following compatibility matrix:\nGenerated Code Version 3.20.2 3.20.3 3.21.6 3.21.7 Runtime\nVersion 3.20.2 Vuln Broken Vuln Broken 3.20.3 Vuln Works Vuln Works? 3.21.6 Vuln Broken Vuln Broken 3.21.7 Vuln Works Vuln Works “Vuln” indicates that the combination will successfully start, but the security vulnerability still exists. “Works” indicates that the combination will successfully start and does not have the vulnerability. “Broken” indicates that the combination will not successfully start. Bold indicates configurations that were never deliberately intended to function together given the guarantees outlined in this topic. No Coexistence of Multiple Major Runtime Versions Coexistence of multiple major versions in the same process is not supported.\nC++ Specific Guarantees Protobuf C++ disclaims all cross-runtime support and requires an exact match between its generated code version and its runtime version at all times. Additionally, Protobuf C++ makes no guarantees about ABI stability across any releases (major, minor, or micro).\n","categories":"","description":"The guarantees that the language has for cross-version runtime compatibility.","excerpt":"The guarantees that the language has for cross-version runtime …","ref":"/support/cross-version-runtime-guarantee/","tags":"","title":"Cross-Version Runtime Guarantee"},{"body":"Release Packages Latest Version The latest release of Protocol Buffers can be found on the release page.\nOld Versions Older versions are available in our historical releases on GitHub.\nSource Code GitHub Repository Protocol Buffers source code is hosted on GitHub.\n","categories":"","description":"The downloads page for protocol buffers.","excerpt":"The downloads page for protocol buffers.","ref":"/downloads/","tags":"","title":"Downloads"},{"body":"This is a brief history of protocol buffers. Understanding why it was created and the decisions that changed it over time can help you to better utilize the features of the tool.\nWhy Did You Release Protocol Buffers? There are several reasons that we released Protocol Buffers.\nProtocol buffers are used by many projects inside Google. We had other projects we wanted to release as open source that use protocol buffers, so to do this, we needed to release protocol buffers first. In fact, bits of the technology had already found their way into the open; if you dig into the code for Google AppEngine, you might find some of it.\nWe wanted to provide public APIs that accept protocol buffers as well as XML, both because it is more efficient and because we convert that XML to protocol buffers on our end, anyway.\nWe thought that people outside Google might find protocol buffers useful. Getting protocol buffers into a form we were happy to release was a fun side project.\nWhy Is the First Release Version 2? What Happened to Version 1? The initial version of protocol buffers (“Proto1”) was developed starting in early 2001 and evolved over the course of many years, sprouting new features whenever someone needed them and was willing to do the work to create them. Like anything created in such a way, it was a bit of a mess. We came to the conclusion that it would not be feasible to release the code as it was.\nVersion 2 (“Proto2”) was a complete rewrite, though it kept most of the design and used many of the implementation ideas from Proto1. Some features were added, some removed. Most importantly, though, the code was cleaned up and did not have any dependencies on Google libraries that were not yet open-sourced.\nWhy the Name “Protocol Buffers”? The name originates from the early days of the format, before we had the protocol buffer compiler to generate classes for us. At the time, there was a class called ProtocolBuffer that actually acted as a buffer for an individual method. Users would add tag/value pairs to this buffer individually by calling methods like AddValue(tag, value). The raw bytes were stored in a buffer that could then be written out once the message had been constructed.\nSince that time, the “buffers” part of the name has lost its meaning, but it is still the name we use. Today, people usually use the term “protocol message” to refer to a message in an abstract sense, “protocol buffer” to refer to a serialized copy of a message, and “protocol message object” to refer to an in-memory object representing the parsed message.\nDoes Google Have Any Patents on Protocol Buffers? Google currently has no issued patents on protocol buffers, and we are happy to address any concerns around protocol buffers and patents that people may have.\nHow Do Protocol Buffers Differ from ASN.1, COM, CORBA, and Thrift? We think all of these systems have strengths and weaknesses. Google relies on protocol buffers internally and they are a vital component of our success, but that doesn’t mean they are the ideal solution for every problem. You should evaluate each alternative in the context of your own project.\nIt is worth noting, though, that several of these technologies define both an interchange format and an RPC (remote procedure call) protocol. Protocol buffers are just an interchange format. They could easily be used for RPC—and, indeed, they do have limited support for defining RPC services—but they are not tied to any one RPC implementation or protocol.\n","categories":"","description":"A brief history behind the creation of protocol buffers.","excerpt":"A brief history behind the creation of protocol buffers.","ref":"/history/","tags":"","title":"History"},{"body":"","categories":"","description":"","excerpt":"","ref":"/forum-link/","tags":"","title":"Forum"},{"body":" Home Programming Guides Codelabs Reference ","categories":"","description":"","excerpt":" Home Programming Guides Codelabs Reference ","ref":"/navbar/","tags":"","title":""},{"body":"C++ APIC++ APIPackagesgoogle::protobufgoogle::protobuf::ioAuxiliary classes used for I/O. google::protobuf::utilUtility classes. google::protobuf::compilerImplementation of the Protocol Buffer compiler. google::protobuf\nFilesgoogle/protobuf/arena.hThis file defines an Arena allocator for better allocation performance. google/protobuf/descriptor.hThis file contains classes which describe a type of protocol message. google/protobuf/descriptor.pb.hProtocol buffer representations of descriptors.google/protobuf/descriptor_database.hInterface for manipulating databases of descriptors. google/protobuf/dynamic_message.hDefines an implementation of Message which can emulate types which are not known at compile-time. google/protobuf/map.hThis file defines the map container and its helpers to support protobuf maps. google/protobuf/message.hDefines Message, the abstract interface implemented by non-lite protocol message objects. google/protobuf/message_lite.hDefines MessageLite, the abstract interface implemented by all (lite and non-lite) protocol message objects. google/protobuf/repeated_field.hRepeatedField and RepeatedPtrField are used by generated protocol message classes to manipulate repeated fields. google/protobuf/service.hDEPRECATED: This module declares the abstract interfaces underlying proto2 RPC services. google/protobuf/text_format.hUtilities for printing and parsing protocol messages in a human-readable, text-based format. google/protobuf/unknown_field_set.hContains classes used to keep track of unrecognized fields seen while parsing a protocol message. google::protobuf::ioAuxiliary classes used for I/O. The Protocol Buffer library uses the classes in this package to deal with I/O and encoding/decoding raw bytes. Most users will not need to deal with this package. However, users who want to adapt the system to work with their own I/O abstractions – e.g., to allow Protocol Buffers to be read from a different kind of input stream without the need for a temporary buffer – should take a closer look. Filesgoogle/protobuf/io/coded_stream.hThis file contains the CodedInputStream and CodedOutputStream classes, which wrap a ZeroCopyInputStream or ZeroCopyOutputStream, respectively, and allow you to read or write individual pieces of data in various formats. google/protobuf/io/printer.hUtility class for writing text to a ZeroCopyOutputStream. google/protobuf/io/tokenizer.hClass for parsing tokenized text from a ZeroCopyInputStream. google/protobuf/io/zero_copy_stream.hThis file contains the ZeroCopyInputStream and ZeroCopyOutputStream interfaces, which represent abstract I/O streams to and from which protocol buffers can be read and written. google/protobuf/io/zero_copy_stream_impl.hThis file contains common implementations of the interfaces defined in zero_copy_stream.h which are only included in the full (non-lite) protobuf library. google/protobuf/io/zero_copy_stream_impl_lite.hThis file contains common implementations of the interfaces defined in zero_copy_stream.h which are included in the \"lite\" protobuf library. google::protobuf::utilUtility classes. This package contains various utilities for message comparison, JSON conversion, well known types, etc. Filesgoogle/protobuf/util/field_comparator.hDefines classes for field comparison. google/protobuf/util/field_mask_util.hDefines utilities for the FieldMask well known type. google/protobuf/util/json_util.hUtility functions to convert between protobuf binary format and proto3 JSON format. google/protobuf/util/message_differencer.hThis file defines static methods and classes for comparing Protocol Messages. google/protobuf/util/time_util.hDefines utilities for the Timestamp and Duration well known types. google/protobuf/util/type_resolver.hDefines a TypeResolver for the Any message. google/protobuf/util/type_resolver_util.hDefines utilities for the TypeResolver. google::protobuf::compilerImplementation of the Protocol Buffer compiler. This package contains code for parsing .proto files and generating code based on them. There are two reasons you might be interested in this package:\nYou want to parse .proto files at runtime. In this case, you should look at importer.h. Since this functionality is widely useful, it is included in the libprotobuf base library; you do not have to link against libprotoc. You want to write a custom protocol compiler which generates different kinds of code, e.g. code in a different language which is not supported by the official compiler. For this purpose, command_line_interface.h provides you with a complete compiler front-end, so all you need to do is write a custom implementation of CodeGenerator and a trivial main() function. You can even make your compiler support the official languages in addition to your own. Since this functionality is only useful to those writing custom compilers, it is in a separate library called \"libprotoc\" which you will have to link against. Filesgoogle/protobuf/compiler/code_generator.hDefines the abstract interface implemented by each of the language-specific code generators. google/protobuf/compiler/command_line_interface.hImplements the Protocol Compiler front-end such that it may be reused by custom compilers written to support other languages. google/protobuf/compiler/importer.hThis file is the public interface to the .proto file parser. google/protobuf/compiler/parser.hImplements parsing of .proto files to FileDescriptorProtos. google/protobuf/compiler/plugin.hFront-end for protoc code generator plugins written in C++. google/protobuf/compiler/plugin.pb.hAPI for protoc plugins.google/protobuf/compiler/cpp/cpp_generator.hGenerates C++ code for a given .proto file. google/protobuf/compiler/csharp/csharp_generator.hGenerates C# code for a given .proto file. google/protobuf/compiler/csharp/csharp_names.hProvides a mechanism for mapping a descriptor to the fully-qualified name of the corresponding C# class. google/protobuf/compiler/java/java_generator.hGenerates Java code for a given .proto file. google/protobuf/compiler/java/java_names.hProvides a mechanism for mapping a descriptor to the fully-qualified name of the corresponding Java class. google/protobuf/compiler/js/js_generator.hGenerates JavaScript code for a given .proto file. google/protobuf/compiler/objectivec/objectivec_generator.hGenerates ObjectiveC code for a given .proto file. google/protobuf/compiler/objectivec/objectivec_helpers.hHelper functions for generating ObjectiveC code. google/protobuf/compiler/python/python_generator.hGenerates Python code for a given .proto file. google/protobuf/compiler/ruby/ruby_generator.hGenerates Ruby code for a given .proto file. ","categories":"","description":"","excerpt":"C++ APIC++ APIPackagesgoogle::protobufgoogle::protobuf::ioAuxiliary …","ref":"/reference/cpp/api-docs/","tags":"","title":""},{"body":"arena.harena.h#include \u003cgoogle/protobuf/arena.h\u003e\nnamespace google::protobuf\nThis file defines an Arena allocator for better allocation performance. Classes in this fileArenaOptionsArenaOptions provides optional additional parameters to arena construction that control its block-allocation behavior. ArenaArena allocator. Arena::InternalHelperArena::is_arena_constructableHelper typetraits that indicates support for arenas in a type T at compile time. Arena::is_destructor_skippablestruct ArenaOptions#include \u003cgoogle/protobuf/arena.h\u003e\nnamespace google::protobuf\nArenaOptions provides optional additional parameters to arena construction that control its block-allocation behavior. Memberssize_tstart_block_sizeThis defines the size of the first block requested from the system malloc. more...size_tmax_block_sizeThis defines the maximum block size requested from system malloc (unless an individual arena allocation request occurs with a size larger than this maximum). more...char *initial_blockAn initial block of memory for the arena to use, or NULL for none. more...size_tinitial_block_sizeThe size of the initial block, if provided. void *(*block_allocA function pointer to an alloc method that returns memory blocks of size requested. more...void(*block_deallocA function pointer to a dealloc method that takes ownership of the blocks from the arena. more...ArenaOptions() size_t ArenaOptions::start_block_sizeThis defines the size of the first block requested from the system malloc. Subsequent block sizes will increase in a geometric series up to a maximum. size_t ArenaOptions::max_block_sizeThis defines the maximum block size requested from system malloc (unless an individual arena allocation request occurs with a size larger than this maximum). Requested block sizes increase up to this value, then remain here. char * ArenaOptions::initial_blockAn initial block of memory for the arena to use, or NULL for none. If provided, the block must live at least as long as the arena itself. The creator of the Arena retains ownership of the block after the Arena is destroyed. void *(* ArenaOptions::block_allocA function pointer to an alloc method that returns memory blocks of size requested. By default, it contains a ptr to the malloc function.\nNOTE: block_alloc and dealloc functions are expected to behave like malloc and free, including Asan poisoning. void(* ArenaOptions::block_deallocA function pointer to a dealloc method that takes ownership of the blocks from the arena. By default, it contains a ptr to a wrapper function that calls free. class Arena#include \u003cgoogle/protobuf/arena.h\u003e\nnamespace google::protobuf\nArena allocator. Arena allocation replaces ordinary (heap-based) allocation with new/delete, and improves performance by aggregating allocations into larger blocks and freeing allocations all at once. Protocol messages are allocated on an arena by using Arena::CreateMessage\u003cT\u003e(Arena*), below, and are automatically freed when the arena is destroyed.\nThis is a thread-safe implementation: multiple threads may allocate from the arena concurrently. Destruction is not thread-safe and the destructing thread must synchronize with users of the arena first.\nAn arena provides two allocation interfaces: CreateMessage\u003cT\u003e, which works for arena-enabled proto2 message types as well as other types that satisfy the appropriate protocol (described below), and Create\u003cT\u003e, which works for any arbitrary type T. CreateMessage\u003cT\u003e is better when the type T supports it, because this interface (i) passes the arena pointer to the created object so that its sub-objects and internal allocations can use the arena too, and (ii) elides the object's destructor call when possible. Create\u003cT\u003e does not place any special requirements on the type T, and will invoke the object's destructor when the arena is destroyed.\nThe arena message allocation protocol, required by CreateMessage\u003cT\u003e(Arena* arena, Args\u0026\u0026... args), is as follows:\nThe type T must have (at least) two constructors: a constructor callable with args (without arena), called when a T is allocated on the heap; and a constructor callable with Arena* arena, Args\u0026\u0026... args, called when a T is allocated on an arena. If the second constructor is called with a NULL arena pointer, it must be equivalent to invoking the first (args-only) constructor. The type T must have a particular type trait: a nested type |InternalArenaConstructable_|. This is usually a typedef to |void|. If no such type trait exists, then the instantiation CreateMessage\u003cT\u003e will fail to compile. The type T may have the type trait |DestructorSkippable_|. If this type trait is present in the type, then its destructor will not be called if and only if it was passed a non-NULL arena pointer. If this type trait is not present on the type, then its destructor is always called when the containing arena is destroyed. This protocol is implemented by all arena-enabled proto2 message classes as well as protobuf container types like RepeatedPtrField and Map. The protocol is internal to protobuf and is not guaranteed to be stable. Non-proto types should not rely on this protocol. Membersconst size_tkBlockOverhead = = internal::ThreadSafeArena::kBlockHeaderSize + internal::ThreadSafeArena::kSerialArenaSizeBlock overhead. more...Arena()Default constructor with sensible default options, tuned for average use-cases. Arena(char * initial_block, size_t initial_block_size)Construct an arena with default options, except for the supplied initial block. more...explicit Arena(const ArenaOptions \u0026 options)Arena constructor taking custom options. more...~Arena()voidInit(const ArenaOptions \u0026 )uint64SpaceAllocated() constThe following are routines are for monitoring. more...uint64SpaceUsed() constReturns the total space used by the arena. more...uint64Reset()Frees all storage allocated by this arena after calling destructors registered with OwnDestructor() and freeing objects registered with Own(). more...template voidOwn(T * object)Adds |object| to a list of heap-allocated objects to be freed with |delete| when the arena is destroyed or reset. template voidOwnDestructor(T * object)Adds |object| to a list of objects whose destructors will be manually called when the arena is destroyed or reset. more...voidOwnCustomDestructor(void * object, void(*)(void *) destruct)Adds a custom member function on an object to the list of destructors that will be manually called when the arena is destroyed or reset. more...template static T *CreateMessage(Arena * arena, Args \u0026\u0026... args)API to create proto2 message objects on the arena. more...template static PROTOBUF_NDEBUG_INLINE T *Create(Arena * arena, Args \u0026\u0026... args)API to create any objects on the arena. more...template static PROTOBUF_NDEBUG_INLINE T *CreateArray(Arena * arena, size_t num_elements)Create an array of object type T on the arena without invoking the constructor of T. more...template static Arena *GetArena(const T * value)Retrieves the arena associated with |value| if |value| is an arena-capable message, or NULL otherwise. more... const size_t Arena::kBlockOverhead = = internal::ThreadSafeArena::kBlockHeaderSize + internal::ThreadSafeArena::kSerialArenaSizeBlock overhead. Use this as a guide for how much to over-allocate the initial block if you want an allocation of size N to fit inside it.\nWARNING: if you allocate multiple objects, it is difficult to guarantee that a series of allocations will fit in the initial block, especially if Arena changes its alignment guarantees in the future! Arena::Arena(\n        char * initial_block,\n        size_t initial_block_size)Construct an arena with default options, except for the supplied initial block. It is more efficient to use this constructor instead of passing ArenaOptions if the only configuration needed by the caller is supplying an initial block. explicit Arena::Arena(\n        const ArenaOptions \u0026 options)Arena constructor taking custom options. See ArenaOptions above for descriptions of the options available. uint64 Arena::SpaceAllocated() constThe following are routines are for monitoring. They will approximate the total sum allocated and used memory, but the exact value is an implementation deal. For instance allocated space depends on growth policies. Do not use these in unit tests. Returns the total space allocated by the arena, which is the sum of the sizes of the underlying blocks. uint64 Arena::SpaceUsed() constReturns the total space used by the arena. Similar to SpaceAllocated but does not include free space and block overhead. The total space returned may not include space used by other threads executing concurrently with the call to this method. uint64 Arena::Reset()Frees all storage allocated by this arena after calling destructors registered with OwnDestructor() and freeing objects registered with Own(). Any objects allocated on this arena are unusable after this call. It also returns the total space used by the arena which is the sums of the sizes of the allocated blocks. This method is not thread-safe. template void Arena::OwnDestructor(\n        T * object)Adds |object| to a list of objects whose destructors will be manually called when the arena is destroyed or reset. This differs from Own() in that it does not free the underlying memory with |delete|; hence, it is normally only used for objects that are placement-newed into arena-allocated memory. void Arena::OwnCustomDestructor(\n        void * object,\n        void(*)(void *) destruct)Adds a custom member function on an object to the list of destructors that will be manually called when the arena is destroyed or reset. This differs from OwnDestructor() in that any member function may be specified, not only the class destructor. template static T * Arena::CreateMessage(\n        Arena * arena,\n        Args \u0026\u0026... args)API to create proto2 message objects on the arena. If the arena passed in is NULL, then a heap allocated object is returned. Type T must be a message defined in a .proto file with cc_enable_arenas set to true, otherwise a compilation error will occur.\nRepeatedField and RepeatedPtrField may also be instantiated directly on an arena with this method.\nThis function also accepts any type T that satisfies the arena message allocation protocol, documented above. template static PROTOBUF_NDEBUG_INLINE T *     Arena::Create(\n        Arena * arena,\n        Args \u0026\u0026... args)API to create any objects on the arena. Note that only the object will be created on the arena; the underlying ptrs (in case of a proto2 message) will be still heap allocated. Proto messages should usually be allocated with CreateMessage\u003cT\u003e() instead.\nNote that even if T satisfies the arena message construction protocol (InternalArenaConstructable_ trait and optional DestructorSkippable_ trait), as described above, this function does not follow the protocol; instead, it treats T as a black-box type, just as if it did not have these traits. Specifically, T's constructor arguments will always be only those passed to Create\u003cT\u003e() – no additional arena pointer is implicitly added. Furthermore, the destructor will always be called at arena destruction time (unless the destructor is trivial). Hence, from T's point of view, it is as if the object were allocated on the heap (except that the underlying memory is obtained from the arena). template static PROTOBUF_NDEBUG_INLINE T *     Arena::CreateArray(\n        Arena * arena,\n        size_t num_elements)Create an array of object type T on the arena without invoking the constructor of T. If arena is null, then the return value should be freed with delete[[]] x; (or ::operator delete[[]](x);). To ensure safe uses, this function checks at compile time (when compiled as C++11) that T is trivially default-constructible and trivially destructible. template static Arena * Arena::GetArena(\n        const T * value)Retrieves the arena associated with |value| if |value| is an arena-capable message, or NULL otherwise. If possible, the call resolves at compile time. Note that we can often devirtualize calls to value-\u003eGetArena() so usually calling this method is unnecessary. template class Arena::InternalHelper#include \u003cgoogle/protobuf/arena.h\u003e\nnamespace google::protobuf\ntemplate \u003ctypename \u003e\nMembersstatic Arena *GetOwningArena(const T * p)Provides access to protected GetOwningArena to generated messages. static Arena *GetArenaForAllocation(const T * p)Provides access to protected GetArenaForAllocation to generated messages. template struct Arena::is_arena_constructable#include \u003cgoogle/protobuf/arena.h\u003e\nnamespace google::protobuf\ntemplate \u003ctypename \u003e\nHelper typetraits that indicates support for arenas in a type T at compile time. This is public only to allow construction of higher-level templated utilities.\nis_arena_constructable\u003cT\u003e::value is true if the message type T has arena support enabled, and false otherwise.\nis_destructor_skippable\u003cT\u003e::value is true if the message type T has told the arena that it is safe to skip the destructor, and false otherwise.\nThis is inside Arena because only Arena has the friend relationships necessary to see the underlying generated code traits. Memberstemplate struct Arena::is_destructor_skippable#include \u003cgoogle/protobuf/arena.h\u003e\nnamespace google::protobuf\ntemplate \u003ctypename \u003e\nMembers","categories":"","description":"","excerpt":"arena.harena.h#include \u003cgoogle/protobuf/arena.h\u003e\nnamespace …","ref":"/reference/cpp/api-docs/google.protobuf.arena/","tags":"","title":""},{"body":"common.hcommon.h#include \u003cgoogle/protobuf/stubs/common.h\u003e\nnamespace google::protobuf\nContains basic types and utilities used by the rest of the library. Classes in this file","categories":"","description":"","excerpt":"common.hcommon.h#include \u003cgoogle/protobuf/stubs/common.h\u003e\nnamespace …","ref":"/reference/cpp/api-docs/google.protobuf.common/","tags":"","title":""},{"body":"code_generator.hcode_generator.h#include \u003cgoogle/protobuf/compiler/code_generator.h\u003e\nnamespace google::protobuf::compiler\nDefines the abstract interface implemented by each of the language-specific code generators. Classes in this fileCodeGeneratorThe abstract interface to a class which generates code implementing a particular proto file in a particular language. GeneratorContextCodeGenerators generate one or more files in a given directory. File MembersThese definitions are not part of any class.typedefGeneratorContext OutputDirectoryThe type GeneratorContext was once called OutputDirectory. more...voidParseGeneratorParameter(const std::string \u0026 , std::vector\u003c std::pair\u003c std::string, std::string \u003e \u003e * )Several code generators treat the parameter argument as holding a list of options separated by commas. more...std::stringStripProto(const std::string \u0026 filename)Strips \".proto\" or \".protodevel\" from the end of a filename. typedef compiler::OutputDirectoryThe type GeneratorContext was once called OutputDirectory. This typedef provides backward compatibility. void compiler::ParseGeneratorParameter(\n        const std::string \u0026 ,\n        std::vector\u003c std::pair\u003c std::string, std::string \u003e \u003e * )Several code generators treat the parameter argument as holding a list of options separated by commas. This helper function parses a set of comma-delimited name/value pairs: e.g., \"foo=bar,baz,qux=corge\" parses to the pairs: (\"foo\", \"bar\"), (\"baz\", \"\"), (\"qux\", \"corge\") class CodeGenerator#include \u003cgoogle/protobuf/compiler/code_generator.h\u003e\nnamespace google::protobuf::compiler\nThe abstract interface to a class which generates code implementing a particular proto file in a particular language. A number of these may be registered with CommandLineInterface to support various languages. Known subclasses:\nCppGeneratorGeneratorJavaGeneratorGeneratorObjectiveCGeneratorGeneratorGeneratorMembersenumFeatureSync with plugin.proto. more...CodeGenerator()virtual ~CodeGenerator()virtual boolGenerate(const FileDescriptor * file, const std::string \u0026 parameter, GeneratorContext * generator_context, std::string * error) const = 0Generates code for the given proto file, generating one or more files in the given output directory. more...virtual boolGenerateAll(const std::vector\u003c const FileDescriptor * \u003e \u0026 files, const std::string \u0026 parameter, GeneratorContext * generator_context, std::string * error) constGenerates code for all given proto files. more...virtual uint64_tGetSupportedFeatures() constImplement this to indicate what features this code generator supports. more...virtual boolHasGenerateAll() constThis is no longer used, but this class is part of the opensource protobuf library, so it has to remain to keep vtables the same for the current version of the library. more... enum CodeGenerator::Feature {\n  FEATURE_PROTO3_OPTIONAL = = 1\n}Sync with plugin.proto. FEATURE_PROTO3_OPTIONAL virtual bool CodeGenerator::Generate(\n        const FileDescriptor * file,\n        const std::string \u0026 parameter,\n        GeneratorContext * generator_context,\n        std::string * error) const = 0Generates code for the given proto file, generating one or more files in the given output directory. A parameter to be passed to the generator can be specified on the command line. This is intended to be used to pass generator specific parameters. It is empty if no parameter was given. ParseGeneratorParameter (below), can be used to accept multiple parameters within the single parameter command line flag.\nReturns true if successful. Otherwise, sets *error to a description of the problem (e.g. \"invalid parameter\") and returns false. virtual bool CodeGenerator::GenerateAll(\n        const std::vector\u003c const FileDescriptor * \u003e \u0026 files,\n        const std::string \u0026 parameter,\n        GeneratorContext * generator_context,\n        std::string * error) constGenerates code for all given proto files. WARNING: The canonical code generator design produces one or two output files per input .proto file, and we do not wish to encourage alternate designs.\nA parameter is given as passed on the command line, as in |Generate()| above.\nReturns true if successful. Otherwise, sets *error to a description of the problem (e.g. \"invalid parameter\") and returns false. virtual uint64_t CodeGenerator::GetSupportedFeatures() constImplement this to indicate what features this code generator supports. This should be a bitwise OR of features from the Features enum in plugin.proto. virtual bool CodeGenerator::HasGenerateAll() constThis is no longer used, but this class is part of the opensource protobuf library, so it has to remain to keep vtables the same for the current version of the library. When protobufs does a api breaking change, the method can be removed. class GeneratorContext#include \u003cgoogle/protobuf/compiler/code_generator.h\u003e\nnamespace google::protobuf::compiler\nCodeGenerators generate one or more files in a given directory. This abstract interface represents the directory to which the CodeGenerator is to write and other information about the context in which the Generator runs. MembersGeneratorContext()virtual ~GeneratorContext()virtual io::ZeroCopyOutputStream *Open(const std::string \u0026 filename) = 0Opens the given file, truncating it if it exists, and returns a ZeroCopyOutputStream that writes to the file. more...virtual io::ZeroCopyOutputStream *OpenForAppend(const std::string \u0026 filename)Similar to Open() but the output will be appended to the file if exists. virtual io::ZeroCopyOutputStream *OpenForInsert(const std::string \u0026 filename, const std::string \u0026 insertion_point)Creates a ZeroCopyOutputStream which will insert code into the given file at the given insertion point. more...virtual io::ZeroCopyOutputStream *OpenForInsertWithGeneratedCodeInfo(const std::string \u0026 filename, const std::string \u0026 insertion_point, const google::protobuf::GeneratedCodeInfo \u0026 info)Similar to OpenForInsert, but if info is non-empty, will open (or create) filename.pb.meta and insert info at the appropriate place with the necessary shifts. more...virtual voidListParsedFiles(std::vector\u003c const FileDescriptor * \u003e * output)Returns a vector of FileDescriptors for all the files being compiled in this run. more...virtual voidGetCompilerVersion(Version * version) constRetrieves the version number of the protocol compiler associated with this GeneratorContext. virtual io::ZeroCopyOutputStream *     GeneratorContext::Open(\n        const std::string \u0026 filename) = 0Opens the given file, truncating it if it exists, and returns a ZeroCopyOutputStream that writes to the file. The caller takes ownership of the returned object. This method never fails (a dummy stream will be returned instead).\nThe filename given should be relative to the root of the source tree. E.g. the C++ generator, when generating code for \"foo/bar.proto\", will generate the files \"foo/bar.pb.h\" and \"foo/bar.pb.cc\"; note that \"foo/\" is included in these filenames. The filename is not allowed to contain \".\" or \"..\" components. virtual io::ZeroCopyOutputStream *     GeneratorContext::OpenForInsert(\n        const std::string \u0026 filename,\n        const std::string \u0026 insertion_point)Creates a ZeroCopyOutputStream which will insert code into the given file at the given insertion point. See plugin.proto (plugin.pb.h) for more information on insertion points. The default implementation assert-fails – it exists only for backwards-compatibility.\nWARNING: This feature is currently EXPERIMENTAL and is subject to change. virtual io::ZeroCopyOutputStream *     GeneratorContext::OpenForInsertWithGeneratedCodeInfo(\n        const std::string \u0026 filename,\n        const std::string \u0026 insertion_point,\n        const google::protobuf::GeneratedCodeInfo \u0026 info)Similar to OpenForInsert, but if info is non-empty, will open (or create) filename.pb.meta and insert info at the appropriate place with the necessary shifts. The default implementation ignores info.\nWARNING: This feature will be REMOVED in the near future. virtual void GeneratorContext::ListParsedFiles(\n        std::vector\u003c const FileDescriptor * \u003e * output)Returns a vector of FileDescriptors for all the files being compiled in this run. Useful for languages, such as Go, that treat files differently when compiled as a set rather than individually. ","categories":"","description":"","excerpt":"code_generator.hcode_generator.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.code_generator/","tags":"","title":""},{"body":"command_line_interface.hcommand_line_interface.h#include \u003cgoogle/protobuf/compiler/command_line_interface.h\u003e\nnamespace google::protobuf::compiler\nImplements the Protocol Compiler front-end such that it may be reused by custom compilers written to support other languages. Classes in this fileCommandLineInterfaceThis class implements the command-line interface to the protocol compiler. class CommandLineInterface#include \u003cgoogle/protobuf/compiler/command_line_interface.h\u003e\nnamespace google::protobuf::compiler\nThis class implements the command-line interface to the protocol compiler. It is designed to make it very easy to create a custom protocol compiler supporting the languages of your choice. For example, if you wanted to create a custom protocol compiler binary which includes both the regular C++ support plus support for your own custom output \"Foo\", you would write a class \"FooGenerator\" which implements the CodeGenerator interface, then write a main() procedure like this:\nint main(int argc, char* argv[[]]) { google::protobuf::compiler::CommandLineInterface cli; // Support generation of C++ source and headers. google::protobuf::compiler::cpp::CppGenerator cpp_generator; cli.RegisterGenerator(\"–cpp_out\", \u0026cpp_generator, “Generate C++ source and header.”);\n// Support generation of Foo code. FooGenerator foo_generator; cli.RegisterGenerator(\"–foo_out\", \u0026foo_generator, “Generate Foo file.”);\nreturn cli.Run(argc, argv); }\nThe compiler is invoked with syntax like: protoc --cpp_out=outdir --foo_out=outdir --proto_path=src src/foo.proto The .proto file to compile can be specified on the command line using either its physical file path, or a virtual path relative to a directory specified in –proto_path. For example, for src/foo.proto, the following two protoc invocations work the same way: 1. protoc --proto_path=src src/foo.proto (physical file path) 2. protoc --proto_path=src foo.proto (virtual path relative to src) If a file path can be interpreted both as a physical file path and as a relative virtual path, the physical file path takes precedence.\nFor a full description of the command-line syntax, invoke it with –help. Membersconst char *constkPathSeparatorCommandLineInterface()~CommandLineInterface()voidRegisterGenerator(const std::string \u0026 flag_name, CodeGenerator * generator, const std::string \u0026 help_text)Register a code generator for a language. more...voidRegisterGenerator(const std::string \u0026 flag_name, const std::string \u0026 option_flag_name, CodeGenerator * generator, const std::string \u0026 help_text)Register a code generator for a language. more...voidAllowPlugins(const std::string \u0026 exe_name_prefix)Enables \"plugins\". more...intRun(int argc, const char *const argv)Run the Protocol Compiler with the given command-line parameters. more...voidSetInputsAreProtoPathRelative(bool )DEPRECATED. more...voidSetVersionInfo(const std::string \u0026 text)Provides some text which will be printed when the –version flag is used. more... void CommandLineInterface::RegisterGenerator(\n        const std::string \u0026 flag_name,\n        CodeGenerator * generator,\n        const std::string \u0026 help_text)Register a code generator for a language. Parameters:\nflag_name: The command-line flag used to specify an output file of this type. The name must start with a '-'. If the name is longer than one letter, it must start with two '-'s. generator: The CodeGenerator which will be called to generate files of this type. help_text: Text describing this flag in the –help output. Some generators accept extra parameters. You can specify this parameter on the command-line by placing it before the output directory, separated by a colon: protoc --foo_out=enable_bar:outdir The text before the colon is passed to CodeGenerator::Generate() as the \"parameter\". void CommandLineInterface::RegisterGenerator(\n        const std::string \u0026 flag_name,\n        const std::string \u0026 option_flag_name,\n        CodeGenerator * generator,\n        const std::string \u0026 help_text)Register a code generator for a language. Besides flag_name you can specify another option_flag_name that could be used to pass extra parameters to the registered code generator. Suppose you have registered a generator by calling: command_line_interface.RegisterGenerator(\"--foo_out\", \"--foo_opt\", ...) Then you could invoke the compiler with a command like: protoc --foo_out=enable_bar:outdir --foo_opt=enable_baz This will pass \"enable_bar,enable_baz\" as the parameter to the generator. void CommandLineInterface::AllowPlugins(\n        const std::string \u0026 exe_name_prefix)Enables \"plugins\". In this mode, if a command-line flag ends with \"_out\" but does not match any registered generator, the compiler will attempt to find a \"plugin\" to implement the generator. Plugins are just executables. They should live somewhere in the PATH.\nThe compiler determines the executable name to search for by concatenating exe_name_prefix with the unrecognized flag name, removing \"_out\". So, for example, if exe_name_prefix is \"protoc-\" and you pass the flag –foo_out, the compiler will try to run the program \"protoc-gen-foo\".\nThe plugin program should implement the following usage: plugin [[]--out=OUTDIR] [[]--parameter=PARAMETER] PROTO_FILES \u003c DESCRIPTORS –out indicates the output directory (as passed to the –foo_out parameter); if omitted, the current directory should be used. –parameter gives the generator parameter, if any was provided (see below). The PROTO_FILES list the .proto files which were given on the compiler command-line; these are the files for which the plugin is expected to generate output code. Finally, DESCRIPTORS is an encoded FileDescriptorSet (as defined in descriptor.proto). This is piped to the plugin's stdin. The set will include descriptors for all the files listed in PROTO_FILES as well as all files that they import. The plugin MUST NOT attempt to read the PROTO_FILES directly – it must use the FileDescriptorSet.\nThe plugin should generate whatever files are necessary, as code generators normally do. It should write the names of all files it generates to stdout. The names should be relative to the output directory, NOT absolute names or relative to the current directory. If any errors occur, error messages should be written to stderr. If an error is fatal, the plugin should exit with a non-zero exit code.\nPlugins can have generator parameters similar to normal built-in generators. Extra generator parameters can be passed in via a matching \"_opt\" parameter. For example: protoc --plug_out=enable_bar:outdir --plug_opt=enable_baz This will pass \"enable_bar,enable_baz\" as the parameter to the plugin. int CommandLineInterface::Run(\n        int argc,\n        const char *const argv)Run the Protocol Compiler with the given command-line parameters. Returns the error code which should be returned by main().\nIt may not be safe to call Run() in a multi-threaded environment because it calls strerror(). I'm not sure why you'd want to do this anyway. void CommandLineInterface::SetInputsAreProtoPathRelative(\n        bool )DEPRECATED. Calling this method has no effect. Protocol compiler now always try to find the .proto file relative to the current directory first and if the file is not found, it will then treat the input path as a virtual path. void CommandLineInterface::SetVersionInfo(\n        const std::string \u0026 text)Provides some text which will be printed when the –version flag is used. The version of libprotoc will also be printed on the next line after this text. ","categories":"","description":"","excerpt":"command_line_interface.hcommand_line_interface.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.command_line_interface/","tags":"","title":""},{"body":"cpp_generator.hcpp_generator.h#include \u003cgoogle/protobuf/compiler/cpp/cpp_generator.h\u003e\nnamespace google::protobuf::compiler::cpp\nGenerates C++ code for a given .proto file. Classes in this fileCppGeneratorCodeGenerator implementation which generates a C++ source file and header. class CppGenerator: public CodeGenerator#include \u003cgoogle/protobuf/compiler/cpp/cpp_generator.h\u003e\nnamespace google::protobuf::compiler::cpp\nCodeGenerator implementation which generates a C++ source file and header. If you create your own protocol compiler binary and you want it to support C++ output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function. MembersenumRuntime more...CppGenerator()~CppGenerator()voidset_opensource_runtime(bool opensource)voidset_runtime_include_base(const std::string \u0026 base)If set to a non-empty string, generated code will do: more...implements CodeGeneratorvirtual boolGenerate(const FileDescriptor * file, const std::string \u0026 parameter, GeneratorContext * generator_context, std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. more...virtual uint64_tGetSupportedFeatures() constImplement this to indicate what features this code generator supports. more... enum CppGenerator::Runtime {\n  kGoogle3,\n  kOpensource,\n  kOpensourceGoogle3\n}\nkGoogle3Use the internal google3 runtime. kOpensourceUse the open-source runtime. kOpensourceGoogle3Use the open-source runtime with google3 #include paths. We make these absolute to avoid ambiguity, so the runtime will be #included like: void CppGenerator::set_runtime_include_base(\n        const std::string \u0026 base)If set to a non-empty string, generated code will do: /google/protobuf/message.h\" instead of: This has no effect if opensource_runtime = false. virtual bool CppGenerator::Generate(\n        const FileDescriptor * file,\n        const std::string \u0026 parameter,\n        GeneratorContext * generator_context,\n        std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. A parameter to be passed to the generator can be specified on the command line. This is intended to be used to pass generator specific parameters. It is empty if no parameter was given. ParseGeneratorParameter (below), can be used to accept multiple parameters within the single parameter command line flag.\nReturns true if successful. Otherwise, sets *error to a description of the problem (e.g. \"invalid parameter\") and returns false. virtual uint64_t CppGenerator::GetSupportedFeatures() constImplement this to indicate what features this code generator supports. This should be a bitwise OR of features from the Features enum in plugin.proto. ","categories":"","description":"","excerpt":"cpp_generator.hcpp_generator.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.cpp_generator/","tags":"","title":""},{"body":"csharp_generator.hcsharp_generator.h#include \u003cgoogle/protobuf/compiler/csharp/csharp_generator.h\u003e\nnamespace google::protobuf::compiler::csharp\nGenerates C# code for a given .proto file. Classes in this fileGeneratorCodeGenerator implementation which generates a C# source file and header. class Generator: public CodeGenerator#include \u003cgoogle/protobuf/compiler/csharp/csharp_generator.h\u003e\nnamespace google::protobuf::compiler::csharp\nCodeGenerator implementation which generates a C# source file and header. If you create your own protocol compiler binary and you want it to support C# output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function. MembersGenerator()~Generator()virtual boolGenerate(const FileDescriptor * file, const std::string \u0026 parameter, GeneratorContext * generator_context, std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. more...virtual uint64_tGetSupportedFeatures() constImplement this to indicate what features this code generator supports. more... virtual bool Generator::Generate(\n        const FileDescriptor * file,\n        const std::string \u0026 parameter,\n        GeneratorContext * generator_context,\n        std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. A parameter to be passed to the generator can be specified on the command line. This is intended to be used to pass generator specific parameters. It is empty if no parameter was given. ParseGeneratorParameter (below), can be used to accept multiple parameters within the single parameter command line flag.\nReturns true if successful. Otherwise, sets *error to a description of the problem (e.g. \"invalid parameter\") and returns false. virtual uint64_t Generator::GetSupportedFeatures() constImplement this to indicate what features this code generator supports. This should be a bitwise OR of features from the Features enum in plugin.proto. ","categories":"","description":"","excerpt":"csharp_generator.hcsharp_generator.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.csharp_generator/","tags":"","title":""},{"body":"csharp_names.hcsharp_names.h#include \u003cgoogle/protobuf/compiler/csharp/csharp_names.h\u003e\nnamespace google::protobuf::compiler::csharp\nProvides a mechanism for mapping a descriptor to the fully-qualified name of the corresponding C# class. Classes in this fileFile MembersThese definitions are not part of any class.std::stringGetFileNamespace(const FileDescriptor * descriptor)Requires: more...std::stringGetClassName(const Descriptor * descriptor)Requires: more...std::stringGetReflectionClassName(const FileDescriptor * descriptor)Requires: more...std::stringGetOutputFile(const FileDescriptor * descriptor, const std::string file_extension, const bool generate_directories, const std::string base_namespace, std::string * error)Generates output file name for given file descriptor. more... std::string csharp::GetFileNamespace(\n        const FileDescriptor * descriptor)Requires: descriptor != NULL Returns: The namespace to use for given file descriptor. std::string csharp::GetClassName(\n        const Descriptor * descriptor)Requires: descriptor != NULL Returns: The fully-qualified C# class name. std::string csharp::GetReflectionClassName(\n        const FileDescriptor * descriptor)Requires: descriptor != NULL Returns: The fully-qualified name of the C# class that provides access to the file descriptor. Proto compiler generates such class for each .proto file processed. std::string csharp::GetOutputFile(\n        const FileDescriptor * descriptor,\n        const std::string file_extension,\n        const bool generate_directories,\n        const std::string base_namespace,\n        std::string * error)Generates output file name for given file descriptor. If generate_directories is true, the output file will be put under directory corresponding to file's namespace. base_namespace can be used to strip some of the top level directories. E.g. for file with namespace \"Bar.Foo\" and base_namespace=\"Bar\", the resulting file will be put under directory \"Foo\" (and not \"Bar/Foo\").\nRequires: descriptor != NULL error != NULL Returns: The file name to use as output file for given file descriptor. In case of failure, this function will return empty string and error parameter will contain the error message. ","categories":"","description":"","excerpt":"csharp_names.hcsharp_names.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.csharp_names/","tags":"","title":""},{"body":"importer.himporter.h#include \u003cgoogle/protobuf/compiler/importer.h\u003e\nnamespace google::protobuf::compiler\nThis file is the public interface to the .proto file parser. Classes in this fileSourceTreeDescriptorDatabaseAn implementation of DescriptorDatabase which loads files from a SourceTree and parses them. ImporterSimple interface for parsing .proto files. MultiFileErrorCollectorIf the importer encounters problems while trying to import the proto files, it reports them to a MultiFileErrorCollector. SourceTreeAbstract interface which represents a directory tree containing proto files. DiskSourceTreeAn implementation of SourceTree which loads files from locations on disk. class SourceTreeDescriptorDatabase: public DescriptorDatabase#include \u003cgoogle/protobuf/compiler/importer.h\u003e\nnamespace google::protobuf::compiler\nAn implementation of DescriptorDatabase which loads files from a SourceTree and parses them. Note: This class is not thread-safe since it maintains a table of source code locations for error reporting. However, when a DescriptorPool wraps a DescriptorDatabase, it uses mutex locking to make sure only one method of the database is called at a time, even if the DescriptorPool is used from multiple threads. Therefore, there is only a problem if you create multiple DescriptorPools wrapping the same SourceTreeDescriptorDatabase and use them from multiple threads.\nNote: This class does not implement FindFileContainingSymbol() or FindFileContainingExtension(); these will always return false. MembersSourceTreeDescriptorDatabase(SourceTree * source_tree)SourceTreeDescriptorDatabase(SourceTree * source_tree, DescriptorDatabase * fallback_database)If non-NULL, fallback_database will be checked if a file doesn't exist in the specified source_tree. ~SourceTreeDescriptorDatabase()voidRecordErrorsTo(MultiFileErrorCollector * error_collector)Instructs the SourceTreeDescriptorDatabase to report any parse errors to the given MultiFileErrorCollector. more...DescriptorPool::ErrorCollector *GetValidationErrorCollector()Gets a DescriptorPool::ErrorCollector which records errors to the MultiFileErrorCollector specified with RecordErrorsTo(). more...implements DescriptorDatabasevirtual boolFindFileByName(const std::string \u0026 filename, FileDescriptorProto * output)Find a file by file name. more...virtual boolFindFileContainingSymbol(const std::string \u0026 symbol_name, FileDescriptorProto * output)Find the file that declares the given fully-qualified symbol name. more...virtual boolFindFileContainingExtension(const std::string \u0026 containing_type, int field_number, FileDescriptorProto * output)Find the file which defines an extension extending the given message type with the given field number. more... void SourceTreeDescriptorDatabase::RecordErrorsTo(\n        MultiFileErrorCollector * error_collector)Instructs the SourceTreeDescriptorDatabase to report any parse errors to the given MultiFileErrorCollector. This should be called before parsing. error_collector must remain valid until either this method is called again or the SourceTreeDescriptorDatabase is destroyed. DescriptorPool::ErrorCollector *     SourceTreeDescriptorDatabase::GetValidationErrorCollector()Gets a DescriptorPool::ErrorCollector which records errors to the MultiFileErrorCollector specified with RecordErrorsTo(). This collector has the ability to determine exact line and column numbers of errors from the information given to it by the DescriptorPool. virtual bool SourceTreeDescriptorDatabase::FindFileByName(\n        const std::string \u0026 filename,\n        FileDescriptorProto * output)Find a file by file name. Fills in in *output and returns true if found. Otherwise, returns false, leaving the contents of *output undefined. virtual bool SourceTreeDescriptorDatabase::FindFileContainingSymbol(\n        const std::string \u0026 symbol_name,\n        FileDescriptorProto * output)Find the file that declares the given fully-qualified symbol name. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. virtual bool SourceTreeDescriptorDatabase::FindFileContainingExtension(\n        const std::string \u0026 containing_type,\n        int field_number,\n        FileDescriptorProto * output)Find the file which defines an extension extending the given message type with the given field number. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. containing_type must be a fully-qualified type name. class Importer#include \u003cgoogle/protobuf/compiler/importer.h\u003e\nnamespace google::protobuf::compiler\nSimple interface for parsing .proto files. This wraps the process of opening the file, parsing it with a Parser, recursively parsing all its imports, and then cross-linking the results to produce a FileDescriptor.\nThis is really just a thin wrapper around SourceTreeDescriptorDatabase. You may find that SourceTreeDescriptorDatabase is more flexible.\nMembersImporter(SourceTree * source_tree, MultiFileErrorCollector * error_collector)~Importer()const FileDescriptor *Import(const std::string \u0026 filename)Import the given file and build a FileDescriptor representing it. more...const DescriptorPool *pool() constThe DescriptorPool in which all imported FileDescriptors and their contents are stored. voidAddUnusedImportTrackFile(const std::string \u0026 file_name, bool is_error = false)voidClearUnusedImportTrackFiles() const FileDescriptor *     Importer::Import(\n        const std::string \u0026 filename)Import the given file and build a FileDescriptor representing it. If the file is already in the DescriptorPool, the existing FileDescriptor will be returned. The FileDescriptor is property of the DescriptorPool, and will remain valid until it is destroyed. If any errors occur, they will be reported using the error collector and Import() will return NULL.\nA particular Importer object will only report errors for a particular file once. All future attempts to import the same file will return NULL without reporting any errors. The idea is that you might want to import a lot of files without seeing the same errors over and over again. If you want to see errors for the same files repeatedly, you can use a separate Importer object to import each one (but use the same DescriptorPool so that they can be cross-linked). class MultiFileErrorCollector#include \u003cgoogle/protobuf/compiler/importer.h\u003e\nnamespace google::protobuf::compiler\nIf the importer encounters problems while trying to import the proto files, it reports them to a MultiFileErrorCollector. MembersMultiFileErrorCollector()virtual ~MultiFileErrorCollector()virtual voidAddError(const std::string \u0026 filename, int line, int column, const std::string \u0026 message) = 0Line and column numbers are zero-based. more...virtual voidAddWarning(const std::string \u0026 , int , int , const std::string \u0026 ) virtual void MultiFileErrorCollector::AddError(\n        const std::string \u0026 filename,\n        int line,\n        int column,\n        const std::string \u0026 message) = 0Line and column numbers are zero-based. A line number of -1 indicates an error with the entire file (e.g. \"not found\"). class SourceTree#include \u003cgoogle/protobuf/compiler/importer.h\u003e\nnamespace google::protobuf::compiler\nAbstract interface which represents a directory tree containing proto files. Used by the default implementation of Importer to resolve import statements Most users will probably want to use the DiskSourceTree implementation, below. Known subclasses:\nDiskSourceTreeMembersSourceTree()virtual ~SourceTree()virtual io::ZeroCopyInputStream *Open(const std::string \u0026 filename) = 0Open the given file and return a stream that reads it, or NULL if not found. more...virtual std::stringGetLastErrorMessage()If Open() returns NULL, calling this method immediately will return an description of the error. more... virtual io::ZeroCopyInputStream *     SourceTree::Open(\n        const std::string \u0026 filename) = 0Open the given file and return a stream that reads it, or NULL if not found. The caller takes ownership of the returned object. The filename must be a path relative to the root of the source tree and must not contain \".\" or \"..\" components. virtual std::string SourceTree::GetLastErrorMessage()If Open() returns NULL, calling this method immediately will return an description of the error. Subclasses should implement this method and return a meaningful value for better error reporting.\nclass DiskSourceTree: public SourceTree#include \u003cgoogle/protobuf/compiler/importer.h\u003e\nnamespace google::protobuf::compiler\nAn implementation of SourceTree which loads files from locations on disk. Multiple mappings can be set up to map locations in the DiskSourceTree to locations in the physical filesystem. MembersenumDiskFileToVirtualFileResultReturn type for DiskFileToVirtualFile(). more...DiskSourceTree()~DiskSourceTree()voidMapPath(const std::string \u0026 virtual_path, const std::string \u0026 disk_path)Map a path on disk to a location in the SourceTree. more...DiskFileToVirtualFileResultDiskFileToVirtualFile(const std::string \u0026 disk_file, std::string * virtual_file, std::string * shadowing_disk_file)Given a path to a file on disk, find a virtual path mapping to that file. more...boolVirtualFileToDiskFile(const std::string \u0026 virtual_file, std::string * disk_file)Given a virtual path, find the path to the file on disk. more...implements SourceTreevirtual io::ZeroCopyInputStream *Open(const std::string \u0026 filename)Open the given file and return a stream that reads it, or NULL if not found. more...virtual std::stringGetLastErrorMessage()If Open() returns NULL, calling this method immediately will return an description of the error. more... enum DiskSourceTree::DiskFileToVirtualFileResult {\n  SUCCESS,\n  SHADOWED,\n  CANNOT_OPEN,\n  NO_MAPPING\n}Return type for DiskFileToVirtualFile(). SUCCESSSHADOWEDCANNOT_OPENNO_MAPPING void DiskSourceTree::MapPath(\n        const std::string \u0026 virtual_path,\n        const std::string \u0026 disk_path)Map a path on disk to a location in the SourceTree. The path may be either a file or a directory. If it is a directory, the entire tree under it will be mapped to the given virtual location. To map a directory to the root of the source tree, pass an empty string for virtual_path.\nIf multiple mapped paths apply when opening a file, they will be searched in order. For example, if you do: MapPath(\"bar\", \"foo/bar\"); MapPath(\"\", \"baz\"); and then you do: Open(\"bar/qux\"); the DiskSourceTree will first try to open foo/bar/qux, then baz/bar/qux, returning the first one that opens successfully.\ndisk_path may be an absolute path or relative to the current directory, just like a path you'd pass to open(). DiskFileToVirtualFileResult     DiskSourceTree::DiskFileToVirtualFile(\n        const std::string \u0026 disk_file,\n        std::string * virtual_file,\n        std::string * shadowing_disk_file)Given a path to a file on disk, find a virtual path mapping to that file. The first mapping created with MapPath() whose disk_path contains the filename is used. However, that virtual path may not actually be usable to open the given file. Possible return values are:\nSUCCESS: The mapping was found. *virtual_file is filled in so that calling Open(*virtual_file) will open the file named by disk_file. SHADOWED: A mapping was found, but using Open() to open this virtual path will end up returning some different file. This is because some other mapping with a higher precedence also matches this virtual path and maps it to a different file that exists on disk. *virtual_file is filled in as it would be in the SUCCESS case. *shadowing_disk_file is filled in with the disk path of the file which would be opened if you were to call Open(*virtual_file). CANNOT_OPEN: The mapping was found and was not shadowed, but the file specified cannot be opened. When this value is returned, errno will indicate the reason the file cannot be opened. *virtual_file will be set to the virtual path as in the SUCCESS case, even though it is not useful. NO_MAPPING: Indicates that no mapping was found which contains this file. bool DiskSourceTree::VirtualFileToDiskFile(\n        const std::string \u0026 virtual_file,\n        std::string * disk_file)Given a virtual path, find the path to the file on disk. Return true and update disk_file with the on-disk path if the file exists. Return false and leave disk_file untouched if the file doesn't exist. virtual io::ZeroCopyInputStream *     DiskSourceTree::Open(\n        const std::string \u0026 filename)Open the given file and return a stream that reads it, or NULL if not found. The caller takes ownership of the returned object. The filename must be a path relative to the root of the source tree and must not contain \".\" or \"..\" components. virtual std::string DiskSourceTree::GetLastErrorMessage()If Open() returns NULL, calling this method immediately will return an description of the error. Subclasses should implement this method and return a meaningful value for better error reporting.\n","categories":"","description":"","excerpt":"importer.himporter.h#include \u003cgoogle/protobuf/compiler/importer.h\u003e …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.importer/","tags":"","title":""},{"body":"java_generator.hjava_generator.h#include \u003cgoogle/protobuf/compiler/java/java_generator.h\u003e\nnamespace google::protobuf::compiler::java\nGenerates Java code for a given .proto file. Classes in this fileJavaGeneratorCodeGenerator implementation which generates Java code. class JavaGenerator: public CodeGenerator#include \u003cgoogle/protobuf/compiler/java/java_generator.h\u003e\nnamespace google::protobuf::compiler::java\nCodeGenerator implementation which generates Java code. If you create your own protocol compiler binary and you want it to support Java output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function. MembersJavaGenerator()~JavaGenerator()implements CodeGeneratorvirtual boolGenerate(const FileDescriptor * file, const std::string \u0026 parameter, GeneratorContext * generator_context, std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. more...virtual uint64_tGetSupportedFeatures() constImplement this to indicate what features this code generator supports. more... virtual bool JavaGenerator::Generate(\n        const FileDescriptor * file,\n        const std::string \u0026 parameter,\n        GeneratorContext * generator_context,\n        std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. A parameter to be passed to the generator can be specified on the command line. This is intended to be used to pass generator specific parameters. It is empty if no parameter was given. ParseGeneratorParameter (below), can be used to accept multiple parameters within the single parameter command line flag.\nReturns true if successful. Otherwise, sets *error to a description of the problem (e.g. \"invalid parameter\") and returns false. virtual uint64_t JavaGenerator::GetSupportedFeatures() constImplement this to indicate what features this code generator supports. This should be a bitwise OR of features from the Features enum in plugin.proto. ","categories":"","description":"","excerpt":"java_generator.hjava_generator.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.java_generator/","tags":"","title":""},{"body":"java_names.hjava_names.h#include \u003cgoogle/protobuf/compiler/java/java_names.h\u003e\nnamespace google::protobuf::compiler::java\nProvides a mechanism for mapping a descriptor to the fully-qualified name of the corresponding Java class. Classes in this fileFile MembersThese definitions are not part of any class.std::stringClassName(const Descriptor * descriptor)Requires: more...std::stringClassName(const EnumDescriptor * descriptor)Requires: more...std::stringClassName(const FileDescriptor * descriptor)Requires: more...std::stringClassName(const ServiceDescriptor * descriptor)Requires: more...std::stringFileJavaPackage(const FileDescriptor * descriptor)Requires: more...std::stringCapitalizedFieldName(const FieldDescriptor * descriptor)Requires: more... std::string java::ClassName(\n        const Descriptor * descriptor)Requires: descriptor != NULL Returns: The fully-qualified Java class name. std::string java::ClassName(\n        const EnumDescriptor * descriptor)Requires: descriptor != NULL Returns: The fully-qualified Java class name. std::string java::ClassName(\n        const FileDescriptor * descriptor)Requires: descriptor != NULL Returns: The fully-qualified Java class name. std::string java::ClassName(\n        const ServiceDescriptor * descriptor)Requires: descriptor != NULL Returns: The fully-qualified Java class name. std::string java::FileJavaPackage(\n        const FileDescriptor * descriptor)Requires: descriptor != NULL Returns: Java package name. std::string java::CapitalizedFieldName(\n        const FieldDescriptor * descriptor)Requires: descriptor != NULL Returns: Capitalized camel case name field name. ","categories":"","description":"","excerpt":"java_names.hjava_names.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.java_names/","tags":"","title":""},{"body":"javanano_generator.hjavanano_generator.h#include \u003cgoogle/protobuf/compiler/javanano/javanano_generator.h\u003e\nnamespace google::protobuf::compiler::javanano\nGenerates Java nano code for a given .proto file. Classes in this fileJavaNanoGeneratorCodeGenerator implementation which generates Java nano code. class JavaNanoGenerator: public CodeGenerator#include \u003cgoogle/protobuf/compiler/javanano/javanano_generator.h\u003e\nnamespace google::protobuf::compiler::javanano\nCodeGenerator implementation which generates Java nano code. If you create your own protocol compiler binary and you want it to support Java output for the nano runtime, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function. MembersJavaNanoGenerator()~JavaNanoGenerator()implements CodeGeneratorvirtual boolGenerate(const FileDescriptor * file, const string \u0026 parameter, GeneratorContext * generator_context, string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. more... virtual bool JavaNanoGenerator::Generate(\n        const FileDescriptor * file,\n        const string \u0026 parameter,\n        GeneratorContext * generator_context,\n        string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. A parameter to be passed to the generator can be specified on the command line. This is intended to be used to pass generator specific parameters. It is empty if no parameter was given. ParseGeneratorParameter (below), can be used to accept multiple parameters within the single parameter command line flag.\nReturns true if successful. Otherwise, sets *error to a description of the problem (e.g. \"invalid parameter\") and returns false. ","categories":"","description":"","excerpt":"javanano_generator.hjavanano_generator.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.javanano_generator/","tags":"","title":""},{"body":"js_generator.hjs_generator.h#include \u003cgoogle/protobuf/compiler/js/js_generator.h\u003e\nnamespace google::protobuf::compiler::js\nGenerates JavaScript code for a given .proto file. Classes in this fileGeneratorOptionsGeneratorCodeGenerator implementation which generates a JavaScript source file and header. struct GeneratorOptions#include \u003cgoogle/protobuf/compiler/js/js_generator.h\u003e\nnamespace google::protobuf::compiler::js\nMembersenumImportStyleWhat style of imports should be used. more...enumOutputMode more...std::stringoutput_dirOutput path. std::stringnamespace_prefixNamespace prefix. boolbinaryEnable binary-format support? enum google::protobuf::compiler::js::GeneratorOptions::ImportStyleimport_stylebooladd_require_for_enumsAdd a goog.requires() call for each enum type used. more...booltestonlySet this as a test-only module via goog.setTestOnly();. std::stringlibraryCreate a library with name \u003cname\u003e_lib.js rather than a separate .js file per type? boolerror_on_name_conflictError if there are two types that would generate the same output file? std::stringextensionThe extension to use for output file names. boolone_output_file_per_input_fileCreate a separate output file for each input file? boolannotate_codeIf true, we should append annotations as comments on the last line for generated .js file. more...GeneratorOptions()boolParseFromOptions(const std::vector\u003c std::pair\u003c std::string, std::string \u003e \u003e \u0026 options, std::string * error)std::stringGetFileNameExtension() constReturns the file name extension to use for generated code. OutputModeoutput_mode() constIndicates how to output the generated code based on the provided options. enum GeneratorOptions::ImportStyle {\n  kImportClosure,\n  kImportCommonJs,\n  kImportCommonJsStrict,\n  kImportBrowser,\n  kImportEs6\n}What style of imports should be used. kImportClosuregoog.require() kImportCommonJsrequire() kImportCommonJsStrictrequire() with no global export kImportBrowserno import statements kImportEs6import { member } from '' enum GeneratorOptions::OutputMode {\n  kOneOutputFilePerInputFile,\n  kOneOutputFilePerSCC,\n  kEverythingInOneFile\n}\nkOneOutputFilePerInputFileCreate an output file for each input .proto file. kOneOutputFilePerSCCCreate an output file for each type. kEverythingInOneFilePut everything in a single file named by the library option. bool GeneratorOptions::add_require_for_enumsAdd a goog.requires() call for each enum type used. If not set, a forward declaration with goog.forwardDeclare is produced instead. bool GeneratorOptions::annotate_codeIf true, we should append annotations as comments on the last line for generated .js file. Annotations used by tools like to provide cross-references between .js and .proto files. Annotations are encoded as base64 proto of GeneratedCodeInfo message (see descriptor.proto). class Generator: public CodeGenerator#include \u003cgoogle/protobuf/compiler/js/js_generator.h\u003e\nnamespace google::protobuf::compiler::js\nCodeGenerator implementation which generates a JavaScript source file and header. If you create your own protocol compiler binary and you want it to support JavaScript output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function. MembersGenerator()virtual ~Generator()virtual boolGenerate(const FileDescriptor * file, const std::string \u0026 parameter, GeneratorContext * generator_context, std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. more...virtual boolHasGenerateAll() constThis is no longer used, but this class is part of the opensource protobuf library, so it has to remain to keep vtables the same for the current version of the library. more...virtual boolGenerateAll(const std::vector\u003c const FileDescriptor * \u003e \u0026 files, const std::string \u0026 parameter, GeneratorContext * generator_context, std::string * error) constGenerates code for all given proto files. more...virtual uint64GetSupportedFeatures() constImplement this to indicate what features this code generator supports. more... virtual bool Generator::Generate(\n        const FileDescriptor * file,\n        const std::string \u0026 parameter,\n        GeneratorContext * generator_context,\n        std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. A parameter to be passed to the generator can be specified on the command line. This is intended to be used to pass generator specific parameters. It is empty if no parameter was given. ParseGeneratorParameter (below), can be used to accept multiple parameters within the single parameter command line flag.\nReturns true if successful. Otherwise, sets *error to a description of the problem (e.g. \"invalid parameter\") and returns false. virtual bool Generator::HasGenerateAll() constThis is no longer used, but this class is part of the opensource protobuf library, so it has to remain to keep vtables the same for the current version of the library. When protobufs does a api breaking change, the method can be removed. virtual bool Generator::GenerateAll(\n        const std::vector\u003c const FileDescriptor * \u003e \u0026 files,\n        const std::string \u0026 parameter,\n        GeneratorContext * generator_context,\n        std::string * error) constGenerates code for all given proto files. WARNING: The canonical code generator design produces one or two output files per input .proto file, and we do not wish to encourage alternate designs.\nA parameter is given as passed on the command line, as in |Generate()| above.\nReturns true if successful. Otherwise, sets *error to a description of the problem (e.g. \"invalid parameter\") and returns false. virtual uint64 Generator::GetSupportedFeatures() constImplement this to indicate what features this code generator supports. This should be a bitwise OR of features from the Features enum in plugin.proto. ","categories":"","description":"","excerpt":"js_generator.hjs_generator.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.js_generator/","tags":"","title":""},{"body":"objectivec_generator.hobjectivec_generator.h#include \u003cgoogle/protobuf/compiler/objectivec/objectivec_generator.h\u003e\nnamespace google::protobuf::compiler::objectivec\nGenerates ObjectiveC code for a given .proto file. Classes in this fileObjectiveCGeneratorCodeGenerator implementation which generates a ObjectiveC source file and header. class ObjectiveCGenerator: public CodeGenerator#include \u003cgoogle/protobuf/compiler/objectivec/objectivec_generator.h\u003e\nnamespace google::protobuf::compiler::objectivec\nCodeGenerator implementation which generates a ObjectiveC source file and header. If you create your own protocol compiler binary and you want it to support ObjectiveC output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function. MembersObjectiveCGenerator()~ObjectiveCGenerator()ObjectiveCGenerator(const ObjectiveCGenerator \u0026 )ObjectiveCGenerator \u0026operator=(const ObjectiveCGenerator \u0026 )implements CodeGeneratorvirtual boolHasGenerateAll() constThis is no longer used, but this class is part of the opensource protobuf library, so it has to remain to keep vtables the same for the current version of the library. more...virtual boolGenerate(const FileDescriptor * file, const std::string \u0026 parameter, GeneratorContext * generator_context, std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. more...virtual boolGenerateAll(const std::vector\u003c const FileDescriptor * \u003e \u0026 files, const std::string \u0026 parameter, GeneratorContext * generator_context, std::string * error) constGenerates code for all given proto files. more...virtual uint64_tGetSupportedFeatures() constImplement this to indicate what features this code generator supports. more... virtual bool ObjectiveCGenerator::HasGenerateAll() constThis is no longer used, but this class is part of the opensource protobuf library, so it has to remain to keep vtables the same for the current version of the library. When protobufs does a api breaking change, the method can be removed. virtual bool ObjectiveCGenerator::Generate(\n        const FileDescriptor * file,\n        const std::string \u0026 parameter,\n        GeneratorContext * generator_context,\n        std::string * error) constGenerates code for the given proto file, generating one or more files in the given output directory. A parameter to be passed to the generator can be specified on the command line. This is intended to be used to pass generator specific parameters. It is empty if no parameter was given. ParseGeneratorParameter (below), can be used to accept multiple parameters within the single parameter command line flag.\nReturns true if successful. Otherwise, sets *error to a description of the problem (e.g. \"invalid parameter\") and returns false. virtual bool ObjectiveCGenerator::GenerateAll(\n        const std::vector\u003c const FileDescriptor * \u003e \u0026 files,\n        const std::string \u0026 parameter,\n        GeneratorContext * generator_context,\n        std::string * error) constGenerates code for all given proto files. WARNING: The canonical code generator design produces one or two output files per input .proto file, and we do not wish to encourage alternate designs.\nA parameter is given as passed on the command line, as in |Generate()| above.\nReturns true if successful. Otherwise, sets *error to a description of the problem (e.g. \"invalid parameter\") and returns false. virtual uint64_t ObjectiveCGenerator::GetSupportedFeatures() constImplement this to indicate what features this code generator supports. This should be a bitwise OR of features from the Features enum in plugin.proto. ","categories":"","description":"","excerpt":"objectivec_generator.hobjectivec_generator.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.objectivec_generator/","tags":"","title":""},{"body":"objectivec_helpers.hobjectivec_helpers.h#include \u003cgoogle/protobuf/compiler/objectivec/objectivec_helpers.h\u003e\nnamespace google::protobuf::compiler::objectivec\nHelper functions for generating ObjectiveC code. Classes in this fileOptionsGenerator options (see objectivec_generator.cc for a description of each): TextFormatDecodeDataGenerate decode data needed for ObjC's GPBDecodeTextFormatName() to transform the input into the expected output. LineConsumerHelper for parsing simple files. ImportWriterHelper class for parsing framework import mappings and generating import statements. File MembersThese definitions are not part of any class.enumObjectiveCType more...enumFlagType more...const char *constProtobufLibraryFrameworkNameThe name the commonly used by the library when built as a framework. more...std::stringEscapeTrigraphs(const std::string \u0026 to_escape)Escape C++ trigraphs by escaping question marks to \"\\?\". voidTrimWhitespace(StringPiece * input)Remove white space from either end of a StringPiece. boolIsRetainedName(const std::string \u0026 name)Returns true if the name requires a ns_returns_not_retained attribute applied to it. boolIsInitName(const std::string \u0026 name)Returns true if the name starts with \"init\" and will need to have special handling under ARC. std::stringFileClassPrefix(const FileDescriptor * file)Gets the objc_class_prefix. std::stringFilePath(const FileDescriptor * file)Gets the path of the file we're going to generate (sans the .pb.h extension). more...std::stringFilePathBasename(const FileDescriptor * file)Just like FilePath(), but without the directory part. std::stringFileClassName(const FileDescriptor * file)Gets the name of the root class we'll generate in the file. more...std::stringClassName(const Descriptor * descriptor)These return the fully-qualified class name corresponding to the given descriptor. std::stringClassName(const Descriptor * descriptor, std::string * out_suffix_added)std::stringEnumName(const EnumDescriptor * descriptor)std::stringEnumValueName(const EnumValueDescriptor * descriptor)Returns the fully-qualified name of the enum value corresponding to the the descriptor. std::stringEnumValueShortName(const EnumValueDescriptor * descriptor)Returns the name of the enum value corresponding to the descriptor. std::stringUnCamelCaseEnumShortName(const std::string \u0026 name)Reverse what an enum does. std::stringExtensionMethodName(const FieldDescriptor * descriptor)Returns the name to use for the extension (used as the method off the file's Root class). std::stringFieldName(const FieldDescriptor * field)Returns the transformed field name. std::stringFieldNameCapitalized(const FieldDescriptor * field)std::stringOneofEnumName(const OneofDescriptor * descriptor)Returns the transformed oneof name. std::stringOneofName(const OneofDescriptor * descriptor)std::stringOneofNameCapitalized(const OneofDescriptor * descriptor)std::stringObjCClass(const std::string \u0026 class_name)Returns a symbol that can be used in C code to refer to an Objective C class without initializing the class. std::stringObjCClassDeclaration(const std::string \u0026 class_name)Declares an Objective C class without initializing the class so that it can be refrerred to by ObjCClass. boolHasPreservingUnknownEnumSemantics(const FileDescriptor * file)boolIsMapEntryMessage(const Descriptor * descriptor)std::stringUnCamelCaseFieldName(const std::string \u0026 name, const FieldDescriptor * field)Reverse of the above. template std::stringGetOptionalDeprecatedAttribute(const TDescriptor * descriptor, const FileDescriptor * file = NULL, bool preSpace = true, bool postNewline = false)std::stringGetCapitalizedType(const FieldDescriptor * field)ObjectiveCTypeGetObjectiveCType(FieldDescriptor::Type field_type)ObjectiveCTypeGetObjectiveCType(const FieldDescriptor * field)boolIsPrimitiveType(const FieldDescriptor * field)boolIsReferenceType(const FieldDescriptor * field)std::stringGPBGenericValueFieldName(const FieldDescriptor * field)std::stringDefaultValue(const FieldDescriptor * field)boolHasNonZeroDefaultValue(const FieldDescriptor * field)std::stringBuildFlagsString(const FlagType type, const std::vector\u003c std::string \u003e \u0026 strings)std::stringBuildCommentsString(const SourceLocation \u0026 location, bool prefer_single_line)Builds HeaderDoc/appledoc style comments out of the comments in the .proto file. std::stringProtobufFrameworkImportSymbol(const std::string \u0026 framework_name)Returns the CPP symbol name to use as the gate for framework style imports for the given framework name to use. boolIsProtobufLibraryBundledProtoFile(const FileDescriptor * file)Checks if the file is one of the proto's bundled with the library. boolValidateObjCClassPrefixes(const std::vector\u003c const FileDescriptor * \u003e \u0026 files, const Options \u0026 generation_options, std::string * out_error)Checks the prefix for the given files and outputs any warnings as needed. more...boolParseSimpleFile(const std::string \u0026 path, LineConsumer * line_consumer, std::string * out_error) enum objectivec::ObjectiveCType {\n  OBJECTIVECTYPE_INT32,\n  OBJECTIVECTYPE_UINT32,\n  OBJECTIVECTYPE_INT64,\n  OBJECTIVECTYPE_UINT64,\n  OBJECTIVECTYPE_FLOAT,\n  OBJECTIVECTYPE_DOUBLE,\n  OBJECTIVECTYPE_BOOLEAN,\n  OBJECTIVECTYPE_STRING,\n  OBJECTIVECTYPE_DATA,\n  OBJECTIVECTYPE_ENUM,\n  OBJECTIVECTYPE_MESSAGE\n}\nOBJECTIVECTYPE_INT32OBJECTIVECTYPE_UINT32OBJECTIVECTYPE_INT64OBJECTIVECTYPE_UINT64OBJECTIVECTYPE_FLOATOBJECTIVECTYPE_DOUBLEOBJECTIVECTYPE_BOOLEANOBJECTIVECTYPE_STRINGOBJECTIVECTYPE_DATAOBJECTIVECTYPE_ENUMOBJECTIVECTYPE_MESSAGE enum objectivec::FlagType {\n  FLAGTYPE_DESCRIPTOR_INITIALIZATION,\n  FLAGTYPE_EXTENSION,\n  FLAGTYPE_FIELD\n}\nFLAGTYPE_DESCRIPTOR_INITIALIZATIONFLAGTYPE_EXTENSIONFLAGTYPE_FIELD const char *const objectivec::ProtobufLibraryFrameworkNameThe name the commonly used by the library when built as a framework. This lines up to the name used in the CocoaPod. std::string objectivec::FilePath(\n        const FileDescriptor * file)Gets the path of the file we're going to generate (sans the .pb.h extension). The path will be dependent on the objectivec package declared in the proto package. std::string objectivec::FileClassName(\n        const FileDescriptor * file)Gets the name of the root class we'll generate in the file. This class is not meant for external consumption, but instead contains helpers that the rest of the classes need bool objectivec::ValidateObjCClassPrefixes(\n        const std::vector\u003c const FileDescriptor * \u003e \u0026 files,\n        const Options \u0026 generation_options,\n        std::string * out_error)Checks the prefix for the given files and outputs any warnings as needed. If there are flat out errors, then out_error is filled in with the first error and the result is false. struct Options#include \u003cgoogle/protobuf/compiler/objectivec/objectivec_helpers.h\u003e\nnamespace google::protobuf::compiler::objectivec\nGenerator options (see objectivec_generator.cc for a description of each): Membersstd::stringexpected_prefixes_pathstd::vector\u003c std::string \u003eexpected_prefixes_suppressionsstd::stringgenerate_for_named_frameworkstd::stringnamed_framework_to_proto_path_mappings_pathstd::stringruntime_import_prefixOptions()class TextFormatDecodeData#include \u003cgoogle/protobuf/compiler/objectivec/objectivec_helpers.h\u003e\nnamespace google::protobuf::compiler::objectivec\nGenerate decode data needed for ObjC's GPBDecodeTextFormatName() to transform the input into the expected output. MembersTextFormatDecodeData()~TextFormatDecodeData()TextFormatDecodeData(const TextFormatDecodeData \u0026 )TextFormatDecodeData \u0026operator=(const TextFormatDecodeData \u0026 )voidAddString(int32 key, const std::string \u0026 input_for_decode, const std::string \u0026 desired_output)size_tnum_entries() conststd::stringData() conststatic std::stringDecodeDataForString(const std::string \u0026 input_for_decode, const std::string \u0026 desired_output)class LineConsumer#include \u003cgoogle/protobuf/compiler/objectivec/objectivec_helpers.h\u003e\nnamespace google::protobuf::compiler::objectivec\nHelper for parsing simple files. MembersLineConsumer()virtual ~LineConsumer()virtual boolConsumeLine(const StringPiece \u0026 line, std::string * out_error) = 0class ImportWriter#include \u003cgoogle/protobuf/compiler/objectivec/objectivec_helpers.h\u003e\nnamespace google::protobuf::compiler::objectivec\nHelper class for parsing framework import mappings and generating import statements. MembersImportWriter(const std::string \u0026 generate_for_named_framework, const std::string \u0026 named_framework_to_proto_path_mappings_path, const std::string \u0026 runtime_import_prefix, bool include_wkt_imports)~ImportWriter()voidAddFile(const FileDescriptor * file, const std::string \u0026 header_extension)voidPrint(io::Printer * printer) conststatic voidPrintRuntimeImports(io::Printer * printer, const std::vector\u003c std::string \u003e \u0026 header_to_import, const std::string \u0026 runtime_import_prefix, bool default_cpp_symbol = false)","categories":"","description":"","excerpt":"objectivec_helpers.hobjectivec_helpers.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.objectivec_helpers/","tags":"","title":""},{"body":"parser.hparser.h#include \u003cgoogle/protobuf/compiler/parser.h\u003e\nnamespace google::protobuf::compiler\nImplements parsing of .proto files to FileDescriptorProtos. Classes in this fileParserImplements parsing of protocol definitions (such as .proto files). SourceLocationTableA table mapping (descriptor, ErrorLocation) pairs – as reported by DescriptorPool when validating descriptors – to line and column numbers within the original source code. class Parser#include \u003cgoogle/protobuf/compiler/parser.h\u003e\nnamespace google::protobuf::compiler\nImplements parsing of protocol definitions (such as .proto files). Note that most users will be more interested in the Importer class. Parser is a lower-level class which simply converts a single .proto file to a FileDescriptorProto. It does not resolve import directives or perform many other kinds of validation needed to construct a complete FileDescriptor. MembersParser()~Parser()boolParse(io::Tokenizer * input, FileDescriptorProto * file)Parse the entire input and construct a FileDescriptorProto representing it. more...voidRecordSourceLocationsTo(SourceLocationTable * location_table)DEPRECATED: New code should use the SourceCodeInfo embedded in the FileDescriptorProto. more...voidRecordErrorsTo(io::ErrorCollector * error_collector)Requests that errors be recorded to the given ErrorCollector while parsing. more...const std::string \u0026GetSyntaxIdentifier()Returns the identifier used in the \"syntax = \" declaration, if one was seen during the last call to Parse(), or the empty string otherwise. voidSetRequireSyntaxIdentifier(bool value)If set true, input files will be required to begin with a syntax identifier. more...voidSetStopAfterSyntaxIdentifier(bool value)Call SetStopAfterSyntaxIdentifier(true) to tell the parser to stop parsing as soon as it has seen the syntax identifier, or lack thereof. more... bool Parser::Parse(\n        io::Tokenizer * input,\n        FileDescriptorProto * file)Parse the entire input and construct a FileDescriptorProto representing it. Returns true if no errors occurred, false otherwise. void Parser::RecordSourceLocationsTo(\n        SourceLocationTable * location_table)DEPRECATED: New code should use the SourceCodeInfo embedded in the FileDescriptorProto. Requests that locations of certain definitions be recorded to the given SourceLocationTable while parsing. This can be used to look up exact line and column numbers for errors reported by DescriptorPool during validation. Set to NULL (the default) to discard source location information. void Parser::RecordErrorsTo(\n        io::ErrorCollector * error_collector)Requests that errors be recorded to the given ErrorCollector while parsing. Set to NULL (the default) to discard error messages. void Parser::SetRequireSyntaxIdentifier(\n        bool value)If set true, input files will be required to begin with a syntax identifier. Otherwise, files may omit this. If a syntax identifier is provided, it must be 'syntax = \"proto2\";' and must appear at the top of this file regardless of whether or not it was required. void Parser::SetStopAfterSyntaxIdentifier(\n        bool value)Call SetStopAfterSyntaxIdentifier(true) to tell the parser to stop parsing as soon as it has seen the syntax identifier, or lack thereof. This is useful for quickly identifying the syntax of the file without parsing the whole thing. If this is enabled, no error will be recorded if the syntax identifier is something other than \"proto2\" (since presumably the caller intends to deal with that), but other kinds of errors (e.g. parse errors) will still be reported. When this is enabled, you may pass a NULL FileDescriptorProto to Parse(). class SourceLocationTable#include \u003cgoogle/protobuf/compiler/parser.h\u003e\nnamespace google::protobuf::compiler\nA table mapping (descriptor, ErrorLocation) pairs – as reported by DescriptorPool when validating descriptors – to line and column numbers within the original source code. This is semi-obsolete: FileDescriptorProto.source_code_info now contains far more complete information about source locations. However, as of this writing you still need to use SourceLocationTable when integrating with DescriptorPool. MembersSourceLocationTable()~SourceLocationTable()boolFind(const Message * descriptor, DescriptorPool::ErrorCollector::ErrorLocation location, int * line, int * column) constFinds the precise location of the given error and fills in *line and *column with the line and column numbers. more...boolFindImport(const Message * descriptor, const std::string \u0026 name, int * line, int * column) constvoidAdd(const Message * descriptor, DescriptorPool::ErrorCollector::ErrorLocation location, int line, int column)Adds a location to the table. voidAddImport(const Message * descriptor, const std::string \u0026 name, int line, int column)voidClear()Clears the contents of the table. bool SourceLocationTable::Find(\n        const Message * descriptor,\n        DescriptorPool::ErrorCollector::ErrorLocation location,\n        int * line,\n        int * column) constFinds the precise location of the given error and fills in *line and *column with the line and column numbers. If not found, sets *line to -1 and *column to 0 (since line = -1 is used to mean \"error has no exact location\" in the ErrorCollector interface). Returns true if found, false otherwise. ","categories":"","description":"","excerpt":"parser.hparser.h#include \u003cgoogle/protobuf/compiler/parser.h\u003e\nnamespace …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.parser/","tags":"","title":""},{"body":"plugin.hplugin.h#include \u003cgoogle/protobuf/compiler/plugin.h\u003e\nnamespace google::protobuf::compiler\nFront-end for protoc code generator plugins written in C++. To implement a protoc plugin in C++, simply write an implementation of CodeGenerator, then create a main() function like: int main(int argc, char* argv[[]]) { MyCodeGenerator generator; return google::protobuf::compiler::PluginMain(argc, argv, \u0026generator); } You must link your plugin against libprotobuf and libprotoc.\nThe core part of PluginMain is to invoke the given CodeGenerator on a CodeGeneratorRequest to generate a CodeGeneratorResponse. This part is abstracted out and made into function GenerateCode so that it can be reused, for example, to implement a variant of PluginMain that does some preprocessing on the input CodeGeneratorRequest before feeding the request to the given code generator.\nTo get protoc to use the plugin, do one of the following:\nPlace the plugin binary somewhere in the PATH and give it the name \"protoc-gen-NAME\" (replacing \"NAME\" with the name of your plugin). If you then invoke protoc with the parameter –NAME_out=OUT_DIR (again, replace \"NAME\" with your plugin's name), protoc will invoke your plugin to generate the output, which will be placed in OUT_DIR. Place the plugin binary anywhere, with any name, and pass the –plugin parameter to protoc to direct it to your plugin like so: protoc --plugin=protoc-gen-NAME=path/to/mybinary --NAME_out=OUT_DIR On Windows, make sure to include the .exe suffix: protoc --plugin=protoc-gen-NAME=path/to/mybinary.exe --NAME_out=OUT_DIR Classes in this fileFile MembersThese definitions are not part of any class.intPluginMain(int argc, char * argv, const CodeGenerator * generator)Implements main() for a protoc plugin exposing the given code generator. boolGenerateCode(const CodeGeneratorRequest \u0026 request, const CodeGenerator \u0026 generator, CodeGeneratorResponse * response, std::string * error_msg)Generates code using the given code generator. more... bool compiler::GenerateCode(\n        const CodeGeneratorRequest \u0026 request,\n        const CodeGenerator \u0026 generator,\n        CodeGeneratorResponse * response,\n        std::string * error_msg)Generates code using the given code generator. Returns true if the code generation is successful. If the code generation fails, error_msg may be populated to describe the failure cause. ","categories":"","description":"","excerpt":"plugin.hplugin.h#include \u003cgoogle/protobuf/compiler/plugin.h\u003e\nnamespace …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.plugin/","tags":"","title":""},{"body":"plugin.pb.hplugin.pb.h#include \u003cgoogle/protobuf/compiler/plugin.pb.h\u003e\nnamespace google::protobuf::compiler\nAPI for protoc plugins.\nThis file defines a set of protocol message classes which make up the API to protoc code generator plugins. Plugins written in C++ should probably build on the API in plugin.h instead of dealing with the protobuf-level API, but plugins in other languages will need to deal with the raw messages as defined below.\nThe protocol compiler currently doesn't support auto-generated documentation, hence this page contains no descriptions. This file was generated by the protocol compiler from plugin.proto, whose contents are as follows:\n// Protocol Buffers - Google's data interchange format // Copyright 2008 Google Inc. All rights reserved. // https://developers.google.com/protocol-buffers/ // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are // met: // // * Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // * Redistributions in binary form must reproduce the above // copyright notice, this list of conditions and the following disclaimer // in the documentation and/or other materials provided with the // distribution. // * Neither the name of Google Inc. nor the names of its // contributors may be used to endorse or promote products derived from // this software without specific prior written permission. // // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // Author: kenton@google.com (Kenton Varda) // // WARNING: The plugin interface is currently EXPERIMENTAL and is subject to // change. // // protoc (aka the Protocol Compiler) can be extended via plugins. A plugin is // just a program that reads a CodeGeneratorRequest from stdin and writes a // CodeGeneratorResponse to stdout. // // Plugins written using C++ can use google/protobuf/compiler/plugin.h instead // of dealing with the raw protocol defined here. // // A plugin executable needs only to be placed somewhere in the path. The // plugin should be named “protoc-gen-$NAME”, and will then be used when the // flag “–${NAME}_out” is passed to protoc.\nsyntax = “proto2”;\npackage google.protobuf.compiler; option java_package = “com.google.protobuf.compiler”; option java_outer_classname = “PluginProtos”;\noption go_package = “google.golang.org/protobuf/types/pluginpb”;\nimport “google/protobuf/descriptor.proto”;\n// The version number of protocol compiler. message Version { optional int32 major = 1; optional int32 minor = 2; optional int32 patch = 3; // A suffix for alpha, beta or rc release, e.g., “alpha-1”, “rc2”. It should // be empty for mainline stable releases. optional string suffix = 4; }\n// An encoded CodeGeneratorRequest is written to the plugin’s stdin. message CodeGeneratorRequest { // The .proto files that were explicitly listed on the command-line. The // code generator should generate code only for these files. Each file’s // descriptor will be included in proto_file, below. repeated string file_to_generate = 1;\n// The generator parameter passed on the command-line. optional string parameter = 2;\n// FileDescriptorProtos for all files in files_to_generate and everything // they import. The files will appear in topological order, so each file // appears before any file that imports it. // // protoc guarantees that all proto_files will be written after // the fields above, even though this is not technically guaranteed by the // protobuf wire format. This theoretically could allow a plugin to stream // in the FileDescriptorProtos and handle them one by one rather than read // the entire set into memory at once. However, as of this writing, this // is not similarly optimized on protoc’s end – it will store all fields in // memory at once before sending them to the plugin. // // Type names of fields and extensions in the FileDescriptorProto are always // fully qualified. repeated FileDescriptorProto proto_file = 15;\n// The version number of protocol compiler. optional Version compiler_version = 3;\n}\n// The plugin writes an encoded CodeGeneratorResponse to stdout. message CodeGeneratorResponse { // Error message. If non-empty, code generation failed. The plugin process // should exit with status code zero even if it reports an error in this way. // // This should be used to indicate errors in .proto files which prevent the // code generator from generating correct code. Errors which indicate a // problem in protoc itself – such as the input CodeGeneratorRequest being // unparseable – should be reported by writing a message to stderr and // exiting with a non-zero status code. optional string error = 1;\n// A bitmask of supported features that the code generator supports. // This is a bitwise “or” of values from the Feature enum. optional uint64 supported_features = 2;\n// Sync with code_generator.h. enum Feature { FEATURE_NONE = 0; FEATURE_PROTO3_OPTIONAL = 1; }\n// Represents a single generated file. message File { // The file name, relative to the output directory. The name must not // contain “.” or “..” components and must be relative, not be absolute (so, // the file cannot lie outside the output directory). “/” must be used as // the path separator, not “\". // // If the name is omitted, the content will be appended to the previous // file. This allows the generator to break large files into small chunks, // and allows the generated text to be streamed back to protoc so that large // files need not reside completely in memory at one time. Note that as of // this writing protoc does not optimize for this – it will read the entire // CodeGeneratorResponse before writing files to disk. optional string name = 1;\n// If non-empty, indicates that the named file should already exist, and the // content here is to be inserted into that file at a defined insertion // point. This feature allows a code generator to extend the output // produced by another code generator. The original generator may provide // insertion points by placing special annotations in the file that look // like: // @@protoc_insertion_point(NAME) // The annotation can have arbitrary text before and after it on the line, // which allows it to be placed in a comment. NAME should be replaced with // an identifier naming the point -- this is what other generators will use // as the insertion_point. Code inserted at this point will be placed // immediately above the line containing the insertion point (thus multiple // insertions to the same point will come out in the order they were added). // The double-@ is intended to make it unlikely that the generated code // could contain things that look like insertion points by accident. // // For example, the C++ code generator places the following line in the // .pb.h files that it generates: // // @@protoc_insertion_point(namespace_scope) // This line appears within the scope of the file's package namespace, but // outside of any particular class. Another plugin can then specify the // insertion_point \"namespace_scope\" to generate additional classes or // other declarations that should be placed in this scope. // // Note that if the line containing the insertion point begins with // whitespace, the same whitespace will be added to every line of the // inserted text. This is useful for languages like Python, where // indentation matters. In these languages, the insertion point comment // should be indented the same amount as any inserted code will need to be // in order to work correctly in that context. // // The code generator that generates the initial file and the one which // inserts into it must both run as part of a single invocation of protoc. // Code generators are executed in the order in which they appear on the // command line. // // If |insertion_point| is present, |name| must also be present. optional string insertion_point = 2; // The file contents. optional string content = 15; // Information describing the file content being inserted. If an insertion // point is used, this information will be appropriately offset and inserted // into the code generation metadata for the generated files. optional GeneratedCodeInfo generated_code_info = 16; } repeated File file = 15; } Classes in this fileFile MembersThese definitions are not part of any class.const ::protobuf::internal::DescriptorTable\u003ctd style=“border-left-width: 0px\"id=“descriptor_table_google_2fprotobuf_2fcompiler_2fplugin_2eproto”\u003edescriptor_table_google_2fprotobuf_2fcompiler_2fplugin_2eprotoPROTOBUF_NAMESPACE_CLOSE PROTOBUF_NAMESPACE_OPEN protobuf::compiler::CodeGeneratorRequest *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::compiler::CodeGeneratorRequest \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::compiler::CodeGeneratorRequest \u003e(Arena * )protobuf::compiler::CodeGeneratorResponse *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::compiler::CodeGeneratorResponse \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::compiler::CodeGeneratorResponse \u003e(Arena * )protobuf::compiler::CodeGeneratorResponse_File *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::compiler::CodeGeneratorResponse_File \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::compiler::CodeGeneratorResponse_File \u003e(Arena * )protobuf::compiler::Version *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::compiler::Version \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::compiler::Version \u003e(Arena * )const EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“GetEnumDescriptor\u003c protobuf::compiler::CodeGeneratorResponse_Feature \u003e\"\u003eGetEnumDescriptor\u003c protobuf::compiler::CodeGeneratorResponse_Feature \u003e()\n","categories":"","description":"","excerpt":"plugin.pb.hplugin.pb.h#include \u003cgoogle/protobuf/compiler/plugin.pb.h\u003e …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.plugin.pb/","tags":"","title":""},{"body":"python_generator.hpython_generator.h#include \u003cgoogle/protobuf/compiler/python/python_generator.h\u003e\nnamespace google::protobuf::compiler::python\nGenerates Python code for a given .proto file. Classes in this fileGeneratorCodeGenerator implementation for generated Python protocol buffer classes. class Generator: public CodeGenerator#include \u003cgoogle/protobuf/compiler/python/python_generator.h\u003e\nnamespace google::protobuf::compiler::python\nCodeGenerator implementation for generated Python protocol buffer classes. If you create your own protocol compiler binary and you want it to support Python output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function. MembersGenerator()virtual ~Generator()virtual boolGenerate(const FileDescriptor * file, const std::string \u0026 parameter, GeneratorContext * generator_context, std::string * error) constCodeGenerator methods. virtual uint64_tGetSupportedFeatures() constImplement this to indicate what features this code generator supports. more... virtual uint64_t Generator::GetSupportedFeatures() constImplement this to indicate what features this code generator supports. This should be a bitwise OR of features from the Features enum in plugin.proto. ","categories":"","description":"","excerpt":"python_generator.hpython_generator.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.python_generator/","tags":"","title":""},{"body":"ruby_generator.hruby_generator.h#include \u003cgoogle/protobuf/compiler/ruby/ruby_generator.h\u003e\nnamespace google::protobuf::compiler::ruby\nGenerates Ruby code for a given .proto file. Classes in this fileGeneratorCodeGenerator implementation for generated Ruby protocol buffer classes. class Generator: public CodeGenerator#include \u003cgoogle/protobuf/compiler/ruby/ruby_generator.h\u003e\nnamespace google::protobuf::compiler::ruby\nCodeGenerator implementation for generated Ruby protocol buffer classes. If you create your own protocol compiler binary and you want it to support Ruby output, you can do so by registering an instance of this CodeGenerator with the CommandLineInterface in your main() function. Members","categories":"","description":"","excerpt":"ruby_generator.hruby_generator.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.compiler.ruby_generator/","tags":"","title":""},{"body":"descriptor.hdescriptor.h#include \u003cgoogle/protobuf/descriptor.h\u003e\nnamespace google::protobuf\nThis file contains classes which describe a type of protocol message. You can use a message's descriptor to learn at runtime what fields it contains and what the types of those fields are. The Message interface also allows you to dynamically access and modify individual fields by passing the FieldDescriptor of the field you are interested in.\nMost users will not care about descriptors, because they will write code specific to certain protocol types and will simply use the classes generated by the protocol compiler directly. Advanced users who want to operate on arbitrary types (not known at compile time) may want to read descriptors in order to learn about the contents of a message. A very small number of users will want to construct their own Descriptors, either because they are implementing Message manually or because they are writing something like the protocol compiler.\nFor an example of how you might use descriptors, see the code example at the top of message.h. Classes in this fileSourceLocationNB, all indices are zero-based. DebugStringOptionsOptions when generating machine-parsable output from a descriptor with DebugString(). DescriptorDescribes a type of protocol message, or a particular group within a message. Descriptor::ExtensionRangeA range of field numbers which are designated for third-party extensions. Descriptor::ReservedRangeA range of reserved field numbers. FieldDescriptorDescribes a single field of a message. OneofDescriptorDescribes a oneof defined in a message type. EnumDescriptorDescribes an enum type defined in a .proto file. EnumDescriptor::ReservedRangeA range of reserved field numbers. EnumValueDescriptorDescribes an individual enum constant of a particular type. ServiceDescriptorDescribes an RPC service. MethodDescriptorDescribes an individual service method. FileDescriptorDescribes a whole .proto file. DescriptorPoolUsed to construct descriptors. DescriptorPool::ErrorCollectorWhen converting a FileDescriptorProto to a FileDescriptor, various errors might be detected in the input. struct SourceLocation#include \u003cgoogle/protobuf/descriptor.h\u003e\nnamespace google::protobuf\nNB, all indices are zero-based. Membersintstart_lineintend_lineintstart_columnintend_columnstd::stringleading_commentsDoc comments found at the source location. more...std::stringtrailing_commentsstd::vector\u003c std::string \u003eleading_detached_comments std::string SourceLocation::leading_commentsDoc comments found at the source location. See the comments in SourceCodeInfo.Location (descriptor.proto) for details. struct DebugStringOptions#include \u003cgoogle/protobuf/descriptor.h\u003e\nnamespace google::protobuf\nOptions when generating machine-parsable output from a descriptor with DebugString(). Membersboolinclude_commentsinclude original user comments as recorded in SourceLocation entries. more...boolelide_group_bodyIf true, elide the braced body in the debug string. boolelide_oneof_bodyDebugStringOptions() bool DebugStringOptions::include_commentsinclude original user comments as recorded in SourceLocation entries. N.B. that this must be |false| by default: several other pieces of code (for example, the C++ code generation for fields in the proto compiler) rely on DebugString() output being unobstructed by user comments. class Descriptor#include \u003cgoogle/protobuf/descriptor.h\u003e\nnamespace google::protobuf\nDescribes a type of protocol message, or a particular group within a message. To obtain the Descriptor for a given message object, call Message::GetDescriptor(). Generated message classes also have a static method called descriptor() which returns the type's descriptor. Use DescriptorPool to construct your own descriptors. MembersenumWellKnownType more...typedefDescriptorProto Protoconst std::string \u0026name() constThe name of the message type, not including its scope. const std::string \u0026full_name() constThe fully-qualified name of the message type, scope delimited by periods. more...intindex() constIndex of this descriptor within the file or containing type's message type array. const FileDescriptor *file() constThe .proto file in which this message type was defined. Never nullptr. const Descriptor *containing_type() constIf this Descriptor describes a nested type, this returns the type in which it is nested. more...const MessageOptions \u0026options() constGet options for this message type. more...voidCopyTo(DescriptorProto * proto) constWrite the contents of this Descriptor into the given DescriptorProto. more...std::stringDebugString() constWrite the contents of this descriptor in a human-readable form. more...std::stringDebugStringWithOptions(const DebugStringOptions \u0026 options) constSimilar to DebugString(), but additionally takes options (e.g., include original user comments in output). boolis_placeholder() constReturns true if this is a placeholder for an unknown type. more...WellKnownTypewell_known_type() constField stuffintfield_count() constThe number of fields in this message type. const FieldDescriptor *field(int index) constGets a field by index, where 0 \u003c= index \u003c field_count(). more...const FieldDescriptor *FindFieldByNumber(int number) constLooks up a field by declared tag number. more...const FieldDescriptor *FindFieldByName(ConstStringParam name) constLooks up a field by name. Returns nullptr if no such field exists. const FieldDescriptor *FindFieldByLowercaseName(ConstStringParam lowercase_name) constLooks up a field by lowercased name (as returned by lowercase_name()). more...const FieldDescriptor *FindFieldByCamelcaseName(ConstStringParam camelcase_name) constLooks up a field by camel-case name (as returned by camelcase_name()). more...intoneof_decl_count() constThe number of oneofs in this message type. intreal_oneof_decl_count() constThe number of oneofs in this message type, excluding synthetic oneofs. more...const OneofDescriptor *oneof_decl(int index) constGet a oneof by index, where 0 \u003c= index \u003c oneof_decl_count(). more...const OneofDescriptor *FindOneofByName(ConstStringParam name) constLooks up a oneof by name. Returns nullptr if no such oneof exists. Nested type stuffintnested_type_count() constThe number of nested types in this message type. const Descriptor *nested_type(int index) constGets a nested type by index, where 0 \u003c= index \u003c nested_type_count(). more...const Descriptor *FindNestedTypeByName(ConstStringParam name) constLooks up a nested type by name. more...Enum stuffintenum_type_count() constThe number of enum types in this message type. const EnumDescriptor *enum_type(int index) constGets an enum type by index, where 0 \u003c= index \u003c enum_type_count(). more...const EnumDescriptor *FindEnumTypeByName(ConstStringParam name) constLooks up an enum type by name. more...const EnumValueDescriptor *FindEnumValueByName(ConstStringParam name) constLooks up an enum value by name, among all enum types in this message. more...Extensionsintextension_range_count() constThe number of extension ranges in this message type. const ExtensionRange *extension_range(int index) constGets an extension range by index, where 0 \u003c= index \u003c extension_range_count(). more...boolIsExtensionNumber(int number) constReturns true if the number is in one of the extension ranges. const ExtensionRange *FindExtensionRangeContainingNumber(int number) constReturns nullptr if no extension range contains the given number. intextension_count() constThe number of extensions defined nested within this message type's scope. more...const FieldDescriptor *extension(int index) constGet an extension by index, where 0 \u003c= index \u003c extension_count(). more...const FieldDescriptor *FindExtensionByName(ConstStringParam name) constLooks up a named extension (which extends some other message type) defined within this message type's scope. const FieldDescriptor *FindExtensionByLowercaseName(ConstStringParam name) constSimilar to FindFieldByLowercaseName(), but finds extensions defined within this message type's scope. const FieldDescriptor *FindExtensionByCamelcaseName(ConstStringParam name) constSimilar to FindFieldByCamelcaseName(), but finds extensions defined within this message type's scope. Reserved fieldsintreserved_range_count() constThe number of reserved ranges in this message type. const ReservedRange *reserved_range(int index) constGets an reserved range by index, where 0 \u003c= index \u003c reserved_range_count(). more...boolIsReservedNumber(int number) constReturns true if the number is in one of the reserved ranges. const ReservedRange *FindReservedRangeContainingNumber(int number) constReturns nullptr if no reserved range contains the given number. intreserved_name_count() constThe number of reserved field names in this message type. const std::string \u0026reserved_name(int index) constGets a reserved name by index, where 0 \u003c= index \u003c reserved_name_count(). more...boolIsReservedName(ConstStringParam name) constReturns true if the field name is reserved. Source LocationboolGetSourceLocation(SourceLocation * out_location) constUpdates |*out_location| to the source location of the complete extent of this message declaration. more...Mapsconst FieldDescriptor *map_key() constReturns the FieldDescriptor for the \"key\" field. more...const FieldDescriptor *map_value() constReturns the FieldDescriptor for the \"value\" field. more... enum Descriptor::WellKnownType {\n  WELLKNOWNTYPE_UNSPECIFIED,\n  WELLKNOWNTYPE_DOUBLEVALUE,\n  WELLKNOWNTYPE_FLOATVALUE,\n  WELLKNOWNTYPE_INT64VALUE,\n  WELLKNOWNTYPE_UINT64VALUE,\n  WELLKNOWNTYPE_INT32VALUE,\n  WELLKNOWNTYPE_UINT32VALUE,\n  WELLKNOWNTYPE_STRINGVALUE,\n  WELLKNOWNTYPE_BYTESVALUE,\n  WELLKNOWNTYPE_BOOLVALUE,\n  WELLKNOWNTYPE_ANY,\n  WELLKNOWNTYPE_FIELDMASK,\n  WELLKNOWNTYPE_DURATION,\n  WELLKNOWNTYPE_TIMESTAMP,\n  WELLKNOWNTYPE_VALUE,\n  WELLKNOWNTYPE_LISTVALUE,\n  WELLKNOWNTYPE_STRUCT,\n  __WELLKNOWNTYPE__DO_NOT_USE__ADD_DEFAULT_INSTEAD__\n}\nWELLKNOWNTYPE_UNSPECIFIEDNot a well-known type. WELLKNOWNTYPE_DOUBLEVALUEWrapper types. google.protobuf.DoubleValue WELLKNOWNTYPE_FLOATVALUEgoogle.protobuf.FloatValue WELLKNOWNTYPE_INT64VALUEgoogle.protobuf.Int64Value WELLKNOWNTYPE_UINT64VALUEgoogle.protobuf.UInt64Value WELLKNOWNTYPE_INT32VALUEgoogle.protobuf.Int32Value WELLKNOWNTYPE_UINT32VALUEgoogle.protobuf.UInt32Value WELLKNOWNTYPE_STRINGVALUEgoogle.protobuf.StringValue WELLKNOWNTYPE_BYTESVALUEgoogle.protobuf.BytesValue WELLKNOWNTYPE_BOOLVALUEgoogle.protobuf.BoolValue WELLKNOWNTYPE_ANYOther well known types. google.protobuf.Any WELLKNOWNTYPE_FIELDMASKgoogle.protobuf.FieldMask WELLKNOWNTYPE_DURATIONgoogle.protobuf.Duration WELLKNOWNTYPE_TIMESTAMPgoogle.protobuf.Timestamp WELLKNOWNTYPE_VALUEgoogle.protobuf.Value WELLKNOWNTYPE_LISTVALUEgoogle.protobuf.ListValue WELLKNOWNTYPE_STRUCTgoogle.protobuf.Struct __WELLKNOWNTYPE__DO_NOT_USE__ADD_DEFAULT_INSTEAD__New well-known types may be added in the future. Please make sure any switch() statements have a 'default' case. const std::string \u0026     Descriptor::full_name() constThe fully-qualified name of the message type, scope delimited by periods. For example, message type \"Foo\" which is declared in package \"bar\" has full name \"bar.Foo\". If a type \"Baz\" is nested within Foo, Baz's full_name is \"bar.Foo.Baz\". To get only the part that comes after the last '.', use name(). const Descriptor *     Descriptor::containing_type() constIf this Descriptor describes a nested type, this returns the type in which it is nested. Otherwise, returns nullptr. const MessageOptions \u0026     Descriptor::options() constGet options for this message type. These are specified in the .proto file by placing lines like \"option foo = 1234;\" in the message definition. Allowed options are defined by MessageOptions in descriptor.proto, and any available extensions of that message. void Descriptor::CopyTo(\n        DescriptorProto * proto) constWrite the contents of this Descriptor into the given DescriptorProto. The target DescriptorProto must be clear before calling this; if it isn't, the result may be garbage. std::string Descriptor::DebugString() constWrite the contents of this descriptor in a human-readable form. Output will be suitable for re-parsing. bool Descriptor::is_placeholder() constReturns true if this is a placeholder for an unknown type. This will only be the case if this descriptor comes from a DescriptorPool with AllowUnknownDependencies() set. const FieldDescriptor *     Descriptor::field(\n        int index) constGets a field by index, where 0 \u003c= index \u003c field_count(). These are returned in the order they were defined in the .proto file. const FieldDescriptor *     Descriptor::FindFieldByNumber(\n        int number) constLooks up a field by declared tag number. Returns nullptr if no such field exists. const FieldDescriptor *     Descriptor::FindFieldByLowercaseName(\n        ConstStringParam lowercase_name) constLooks up a field by lowercased name (as returned by lowercase_name()). This lookup may be ambiguous if multiple field names differ only by case, in which case the field returned is chosen arbitrarily from the matches. const FieldDescriptor *     Descriptor::FindFieldByCamelcaseName(\n        ConstStringParam camelcase_name) constLooks up a field by camel-case name (as returned by camelcase_name()). This lookup may be ambiguous if multiple field names differ in a way that leads them to have identical camel-case names, in which case the field returned is chosen arbitrarily from the matches. int Descriptor::real_oneof_decl_count() constThe number of oneofs in this message type, excluding synthetic oneofs. Real oneofs always come first, so iterating up to real_oneof_decl_cout() will yield all real oneofs. const OneofDescriptor *     Descriptor::oneof_decl(\n        int index) constGet a oneof by index, where 0 \u003c= index \u003c oneof_decl_count(). These are returned in the order they were defined in the .proto file. const Descriptor *     Descriptor::nested_type(\n        int index) constGets a nested type by index, where 0 \u003c= index \u003c nested_type_count(). These are returned in the order they were defined in the .proto file. const Descriptor *     Descriptor::FindNestedTypeByName(\n        ConstStringParam name) constLooks up a nested type by name. Returns nullptr if no such nested type exists. const EnumDescriptor *     Descriptor::enum_type(\n        int index) constGets an enum type by index, where 0 \u003c= index \u003c enum_type_count(). These are returned in the order they were defined in the .proto file. const EnumDescriptor *     Descriptor::FindEnumTypeByName(\n        ConstStringParam name) constLooks up an enum type by name. Returns nullptr if no such enum type exists. const EnumValueDescriptor *     Descriptor::FindEnumValueByName(\n        ConstStringParam name) constLooks up an enum value by name, among all enum types in this message. Returns nullptr if no such value exists. const ExtensionRange *     Descriptor::extension_range(\n        int index) constGets an extension range by index, where 0 \u003c= index \u003c extension_range_count(). These are returned in the order they were defined in the .proto file. int Descriptor::extension_count() constThe number of extensions defined nested within this message type's scope. See doc: ","categories":"","description":"","excerpt":"descriptor.hdescriptor.h#include \u003cgoogle/protobuf/descriptor.h\u003e …","ref":"/reference/cpp/api-docs/google.protobuf.descriptor/","tags":"","title":""},{"body":"descriptor.pb.hdescriptor.pb.h#include \u003cgoogle/protobuf/descriptor.pb.h\u003e\nnamespace google::protobuf\nProtocol buffer representations of descriptors.\nThis file defines a set of protocol message classes which represent the same information represented by the classes defined in descriptor.h. You can convert a FileDescriptorProto to a FileDescriptor using the DescriptorPool class. Thus, the classes in this file allow protocol type definitions to be communicated efficiently between processes.\nThe protocol compiler currently doesn't support auto-generated documentation, hence this page contains no descriptions. This file was generated by the protocol compiler from descriptor.proto, whose contents are as follows:\n// Protocol Buffers - Google's data interchange format // Copyright 2008 Google Inc. All rights reserved. // https://developers.google.com/protocol-buffers/ // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are // met: // // * Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // * Redistributions in binary form must reproduce the above // copyright notice, this list of conditions and the following disclaimer // in the documentation and/or other materials provided with the // distribution. // * Neither the name of Google Inc. nor the names of its // contributors may be used to endorse or promote products derived from // this software without specific prior written permission. // // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // Author: kenton@google.com (Kenton Varda) // Based on original Protocol Buffers design by // Sanjay Ghemawat, Jeff Dean, and others. // // The messages in this file describe the definitions found in .proto files. // A valid .proto file can be translated directly to a FileDescriptorProto // without any other information (e.g. without reading its imports).\nsyntax = “proto2”;\npackage google.protobuf;\noption go_package = “google.golang.org/protobuf/types/descriptorpb”; option java_package = “com.google.protobuf”; option java_outer_classname = “DescriptorProtos”; option csharp_namespace = “Google.Protobuf.Reflection”; option objc_class_prefix = “GPB”; option cc_enable_arenas = true;\n// descriptor.proto must be optimized for speed because reflection-based // algorithms don’t work during bootstrapping. option optimize_for = SPEED;\n// The protocol compiler can output a FileDescriptorSet containing the .proto // files it parses. message FileDescriptorSet { repeated FileDescriptorProto file = 1; }\n// Describes a complete .proto file. message FileDescriptorProto { optional string name = 1; // file name, relative to root of source tree optional string package = 2; // e.g. “foo”, “foo.bar”, etc.\n// Names of files imported by this file. repeated string dependency = 3; // Indexes of the public imported files in the dependency list above. repeated int32 public_dependency = 10; // Indexes of the weak imported files in the dependency list. // For Google-internal migration only. Do not use. repeated int32 weak_dependency = 11;\n// All top-level definitions in this file. repeated DescriptorProto message_type = 4; repeated EnumDescriptorProto enum_type = 5; repeated ServiceDescriptorProto service = 6; repeated FieldDescriptorProto extension = 7;\noptional FileOptions options = 8;\n// This field contains optional information about the original source code. // You may safely remove this entire field without harming runtime // functionality of the descriptors – the information is needed only by // development tools. optional SourceCodeInfo source_code_info = 9;\n// The syntax of the proto file. // The supported values are “proto2” and “proto3”. optional string syntax = 12; }\n// Describes a message type. message DescriptorProto { optional string name = 1;\nrepeated FieldDescriptorProto field = 2; repeated FieldDescriptorProto extension = 6;\nrepeated DescriptorProto nested_type = 3; repeated EnumDescriptorProto enum_type = 4;\nmessage ExtensionRange { optional int32 start = 1; // Inclusive. optional int32 end = 2; // Exclusive.\noptional ExtensionRangeOptions options = 3; } repeated ExtensionRange extension_range = 5;\nrepeated OneofDescriptorProto oneof_decl = 8;\noptional MessageOptions options = 7;\n// Range of reserved tag numbers. Reserved tag numbers may not be used by // fields or extension ranges in the same message. Reserved ranges may // not overlap. message ReservedRange { optional int32 start = 1; // Inclusive. optional int32 end = 2; // Exclusive. } repeated ReservedRange reserved_range = 9; // Reserved field names, which may not be used by fields in the same message. // A given name may only be reserved once. repeated string reserved_name = 10; }\nmessage ExtensionRangeOptions { // The parser stores options it doesn’t recognize here. See above. repeated UninterpretedOption uninterpreted_option = 999;\n// Clients can define custom options in extensions of this message. See above. extensions 1000 to max; }\n// Describes a field within a message. message FieldDescriptorProto { enum Type { // 0 is reserved for errors. // Order is weird for historical reasons. TYPE_DOUBLE = 1; TYPE_FLOAT = 2; // Not ZigZag encoded. Negative numbers take 10 bytes. Use TYPE_SINT64 if // negative values are likely. TYPE_INT64 = 3; TYPE_UINT64 = 4; // Not ZigZag encoded. Negative numbers take 10 bytes. Use TYPE_SINT32 if // negative values are likely. TYPE_INT32 = 5; TYPE_FIXED64 = 6; TYPE_FIXED32 = 7; TYPE_BOOL = 8; TYPE_STRING = 9; // Tag-delimited aggregate. // Group type is deprecated and not supported in proto3. However, Proto3 // implementations should still be able to parse the group wire format and // treat group fields as unknown fields. TYPE_GROUP = 10; TYPE_MESSAGE = 11; // Length-delimited aggregate.\n// New in version 2. TYPE_BYTES = 12; TYPE_UINT32 = 13; TYPE_ENUM = 14; TYPE_SFIXED32 = 15; TYPE_SFIXED64 = 16; TYPE_SINT32 = 17; // Uses ZigZag encoding. TYPE_SINT64 = 18; // Uses ZigZag encoding. }\nenum Label { // 0 is reserved for errors LABEL_OPTIONAL = 1; LABEL_REQUIRED = 2; LABEL_REPEATED = 3; }\noptional string name = 1; optional int32 number = 3; optional Label label = 4;\n// If type_name is set, this need not be set. If both this and type_name // are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP. optional Type type = 5;\n// For message and enum types, this is the name of the type. If the name // starts with a ‘.’, it is fully-qualified. Otherwise, C++-like scoping // rules are used to find the type (i.e. first the nested types within this // message are searched, then within the parent, on up to the root // namespace). optional string type_name = 6;\n// For extensions, this is the name of the type being extended. It is // resolved in the same manner as type_name. optional string extendee = 2;\n// For numeric types, contains the original text representation of the value. // For booleans, “true” or “false”. // For strings, contains the default text contents (not escaped in any way). // For bytes, contains the C escaped value. All bytes \u003e= 128 are escaped. optional string default_value = 7;\n// If set, gives the index of a oneof in the containing type’s oneof_decl // list. This field is a member of that oneof. optional int32 oneof_index = 9;\n// JSON name of this field. The value is set by protocol compiler. If the // user has set a “json_name” option on this field, that option’s value // will be used. Otherwise, it’s deduced from the field’s name by converting // it to camelCase. optional string json_name = 10;\noptional FieldOptions options = 8;\n// If true, this is a proto3 “optional”. When a proto3 field is optional, it // tracks presence regardless of field type. // // When proto3_optional is true, this field must be belong to a oneof to // signal to old proto3 clients that presence is tracked for this field. This // oneof is known as a “synthetic” oneof, and this field must be its sole // member (each proto3 optional field gets its own synthetic oneof). Synthetic // oneofs exist in the descriptor only, and do not generate any API. Synthetic // oneofs must be ordered after all “real” oneofs. // // For message fields, proto3_optional doesn’t create any semantic change, // since non-repeated message fields always track presence. However it still // indicates the semantic detail of whether the user wrote “optional” or not. // This can be useful for round-tripping the .proto file. For consistency we // give message fields a synthetic oneof also, even though it is not required // to track presence. This is especially important because the parser can’t // tell if a field is a message or an enum, so it must always create a // synthetic oneof. // // Proto2 optional fields do not set this flag, because they already indicate // optional with LABEL_OPTIONAL. optional bool proto3_optional = 17; }\n// Describes a oneof. message OneofDescriptorProto { optional string name = 1; optional OneofOptions options = 2; }\n// Describes an enum type. message EnumDescriptorProto { optional string name = 1;\nrepeated EnumValueDescriptorProto value = 2;\noptional EnumOptions options = 3;\n// Range of reserved numeric values. Reserved values may not be used by // entries in the same enum. Reserved ranges may not overlap. // // Note that this is distinct from DescriptorProto.ReservedRange in that it // is inclusive such that it can appropriately represent the entire int32 // domain. message EnumReservedRange { optional int32 start = 1; // Inclusive. optional int32 end = 2; // Inclusive. }\n// Range of reserved numeric values. Reserved numeric values may not be used // by enum values in the same enum declaration. Reserved ranges may not // overlap. repeated EnumReservedRange reserved_range = 4;\n// Reserved enum value names, which may not be reused. A given name may only // be reserved once. repeated string reserved_name = 5; }\n// Describes a value within an enum. message EnumValueDescriptorProto { optional string name = 1; optional int32 number = 2;\noptional EnumValueOptions options = 3; }\n// Describes a service. message ServiceDescriptorProto { optional string name = 1; repeated MethodDescriptorProto method = 2;\noptional ServiceOptions options = 3; }\n// Describes a method of a service. message MethodDescriptorProto { optional string name = 1;\n// Input and output type names. These are resolved in the same way as // FieldDescriptorProto.type_name, but must refer to a message type. optional string input_type = 2; optional string output_type = 3;\noptional MethodOptions options = 4;\n// Identifies if client streams multiple client messages optional bool client_streaming = 5 [[]default = false]; // Identifies if server streams multiple server messages optional bool server_streaming = 6 [[]default = false]; }\n// =================================================================== // Options\n// Each of the definitions above may have “options” attached. These are // just annotations which may cause code to be generated slightly differently // or may contain hints for code that manipulates protocol messages. // // Clients may define custom options as extensions of the *Options messages. // These extensions may not yet be known at parsing time, so the parser cannot // store the values in them. Instead it stores them in a field in the *Options // message called uninterpreted_option. This field must have the same name // across all *Options messages. We then use this field to populate the // extensions when we build a descriptor, at which point all protos have been // parsed and so all extensions are known. // // Extension numbers for custom options may be chosen as follows: // * For options which will only be used within a single application or // organization, or for experimental options, use field numbers 50000 // through 99999. It is up to you to ensure that you do not use the // same number for multiple options. // * For options which will be published and used publicly by multiple // independent entities, e-mail protobuf-global-extension-registry@google.com // to reserve extension numbers. Simply provide your project name (e.g. // Objective-C plugin) and your project website (if available) – there’s no // need to explain how you intend to use them. Usually you only need one // extension number. You can declare multiple options with only one extension // number by putting them in a sub-message. See the Custom Options section of // the docs for examples: // /programming-guides/proto#options // If this turns out to be popular, a web service will be set up // to automatically assign option numbers.\nmessage FileOptions {\n// Sets the Java package where classes generated from this .proto will be // placed. By default, the proto package is used, but this is often // inappropriate because proto packages do not normally start with backwards // domain names. optional string java_package = 1;\n// Controls the name of the wrapper Java class generated for the .proto file. // That class will always contain the .proto file’s getDescriptor() method as // well as any top-level extensions defined in the .proto file. // If java_multiple_files is disabled, then all the other classes from the // .proto file will be nested inside the single wrapper outer class. optional string java_outer_classname = 8;\n// If enabled, then the Java code generator will generate a separate .java // file for each top-level message, enum, and service defined in the .proto // file. Thus, these types will not be nested inside the wrapper class // named by java_outer_classname. However, the wrapper class will still be // generated to contain the file’s getDescriptor() method as well as any // top-level extensions defined in the file. optional bool java_multiple_files = 10 [[]default = false];\n// This option does nothing. optional bool java_generate_equals_and_hash = 20 [[]deprecated=true];\n// If set true, then the Java2 code generator will generate code that // throws an exception whenever an attempt is made to assign a non-UTF-8 // byte sequence to a string field. // Message reflection will do the same. // However, an extension field still accepts non-UTF-8 byte sequences. // This option has no effect on when used with the lite runtime. optional bool java_string_check_utf8 = 27 [[]default = false];\n// Generated classes can be optimized for speed or code size. enum OptimizeMode { SPEED = 1; // Generate complete code for parsing, serialization, // etc. CODE_SIZE = 2; // Use ReflectionOps to implement these methods. LITE_RUNTIME = 3; // Generate code using MessageLite and the lite runtime. } optional OptimizeMode optimize_for = 9 [[]default = SPEED];\n// Sets the Go package where structs generated from this .proto will be // placed. If omitted, the Go package will be derived from the following: // - The basename of the package import path, if provided. // - Otherwise, the package statement in the .proto file, if present. // - Otherwise, the basename of the .proto file, without extension. optional string go_package = 11;\n// Should generic services be generated in each language? “Generic” services // are not specific to any particular RPC system. They are generated by the // main code generators in each language (without additional plugins). // Generic services were the only kind of service generation supported by // early versions of google.protobuf. // // Generic services are now considered deprecated in favor of using plugins // that generate code specific to your particular RPC system. Therefore, // these default to false. Old code which depends on generic services should // explicitly set them to true. optional bool cc_generic_services = 16 [[]default = false]; optional bool java_generic_services = 17 [[]default = false]; optional bool py_generic_services = 18 [[]default = false]; optional bool php_generic_services = 42 [[]default = false];\n// Is this file deprecated? // Depending on the target platform, this can emit Deprecated annotations // for everything in the file, or it will be completely ignored; in the very // least, this is a formalization for deprecating files. optional bool deprecated = 23 [[]default = false];\n// Enables the use of arenas for the proto messages in this file. This applies // only to generated classes for C++. optional bool cc_enable_arenas = 31 [[]default = true];\n// Sets the objective c class prefix which is prepended to all objective c // generated classes from this .proto. There is no default. optional string objc_class_prefix = 36;\n// Namespace for generated classes; defaults to the package. optional string csharp_namespace = 37;\n// By default Swift generators will take the proto package and CamelCase it // replacing ‘.’ with underscore and use that to prefix the types/symbols // defined. When this options is provided, they will use this value instead // to prefix the types/symbols defined. optional string swift_prefix = 39;\n// Sets the php class prefix which is prepended to all php generated classes // from this .proto. Default is empty. optional string php_class_prefix = 40;\n// Use this option to change the namespace of php generated classes. Default // is empty. When this option is empty, the package name will be used for // determining the namespace. optional string php_namespace = 41;\n// Use this option to change the namespace of php generated metadata classes. // Default is empty. When this option is empty, the proto file name will be // used for determining the namespace. optional string php_metadata_namespace = 44;\n// Use this option to change the package of ruby generated classes. Default // is empty. When this option is not set, the package name will be used for // determining the ruby package. optional string ruby_package = 45;\n// The parser stores options it doesn’t recognize here. // See the documentation for the “Options” section above. repeated UninterpretedOption uninterpreted_option = 999;\n// Clients can define custom options in extensions of this message. // See the documentation for the “Options” section above. extensions 1000 to max;\nreserved 38; }\nmessage MessageOptions { // Set true to use the old proto1 MessageSet wire format for extensions. // This is provided for backwards-compatibility with the MessageSet wire // format. You should not use this for any other reason: It’s less // efficient, has fewer features, and is more complicated. // // The message must be defined exactly as follows: // message Foo { // option message_set_wire_format = true; // extensions 4 to max; // } // Note that the message cannot have any defined fields; MessageSets only // have extensions. // // All extensions of your type must be singular messages; e.g. they cannot // be int32s, enums, or repeated messages. // // Because this is an option, the above two restrictions are not enforced by // the protocol compiler. optional bool message_set_wire_format = 1 [[]default = false];\n// Disables the generation of the standard “descriptor()” accessor, which can // conflict with a field of the same name. This is meant to make migration // from proto1 easier; new code should avoid fields named “descriptor”. optional bool no_standard_descriptor_accessor = 2 [[]default = false];\n// Is this message deprecated? // Depending on the target platform, this can emit Deprecated annotations // for the message, or it will be completely ignored; in the very least, // this is a formalization for deprecating messages. optional bool deprecated = 3 [[]default = false];\nreserved 4, 5, 6;\n// Whether the message is an automatically generated map entry type for the // maps field. // // For maps fields: // map\u003cKeyType, ValueType\u003e map_field = 1; // The parsed descriptor looks like: // message MapFieldEntry { // option map_entry = true; // optional KeyType key = 1; // optional ValueType value = 2; // } // repeated MapFieldEntry map_field = 1; // // Implementations may choose not to generate the map_entry=true message, but // use a native map in the target language to hold the keys and values. // The reflection APIs in such implementations still need to work as // if the field is a repeated message field. // // NOTE: Do not set the option in .proto files. Always use the maps syntax // instead. The option should only be implicitly set by the proto compiler // parser. optional bool map_entry = 7;\nreserved 8; // javalite_serializable reserved 9; // javanano_as_lite\n// The parser stores options it doesn’t recognize here. See above. repeated UninterpretedOption uninterpreted_option = 999;\n// Clients can define custom options in extensions of this message. See above. extensions 1000 to max; }\nmessage FieldOptions { // The ctype option instructs the C++ code generator to use a different // representation of the field than it normally would. See the specific // options below. This option is not yet implemented in the open source // release – sorry, we’ll try to include it in a future version! optional CType ctype = 1 [[]default = STRING]; enum CType { // Default mode. STRING = 0;\nCORD = 1; STRING_PIECE = 2; } // The packed option can be enabled for repeated primitive fields to enable // a more efficient representation on the wire. Rather than repeatedly // writing the tag and type for each element, the entire array is encoded as // a single length-delimited blob. In proto3, only explicit setting it to // false will avoid using packed encoding. optional bool packed = 2;\n// The jstype option determines the JavaScript type used for values of the // field. The option is permitted only for 64 bit integral and fixed types // (int64, uint64, sint64, fixed64, sfixed64). A field with jstype JS_STRING // is represented as JavaScript string, which avoids loss of precision that // can happen when a large value is converted to a floating point JavaScript. // Specifying JS_NUMBER for the jstype causes the generated JavaScript code to // use the JavaScript “number” type. The behavior of the default option // JS_NORMAL is implementation dependent. // // This option is an enum to permit additional types to be added, e.g. // goog.math.Integer. optional JSType jstype = 6 [[]default = JS_NORMAL]; enum JSType { // Use the default type. JS_NORMAL = 0;\n// Use JavaScript strings. JS_STRING = 1; // Use JavaScript numbers. JS_NUMBER = 2; }\n// Should this field be parsed lazily? Lazy applies only to message-type // fields. It means that when the outer message is initially parsed, the // inner message’s contents will not be parsed but instead stored in encoded // form. The inner message will actually be parsed when it is first accessed. // // This is only a hint. Implementations are free to choose whether to use // eager or lazy parsing regardless of the value of this option. However, // setting this option true suggests that the protocol author believes that // using lazy parsing on this field is worth the additional bookkeeping // overhead typically needed to implement it. // // This option does not affect the public interface of any generated code; // all method signatures remain the same. Furthermore, thread-safety of the // interface is not affected by this option; const methods remain safe to // call from multiple threads concurrently, while non-const methods continue // to require exclusive access. // // // Note that implementations may choose not to check required fields within // a lazy sub-message. That is, calling IsInitialized() on the outer message // may return true even if the inner message has missing required fields. // This is necessary because otherwise the inner message would have to be // parsed in order to perform the check, defeating the purpose of lazy // parsing. An implementation which chooses not to check required fields // must be consistent about it. That is, for any particular sub-message, the // implementation must either always check its required fields, or never // check its required fields, regardless of whether or not the message has // been parsed. optional bool lazy = 5 [[]default = false];\n// Is this field deprecated? // Depending on the target platform, this can emit Deprecated annotations // for accessors, or it will be completely ignored; in the very least, this // is a formalization for deprecating fields. optional bool deprecated = 3 [[]default = false];\n// For Google-internal migration only. Do not use. optional bool weak = 10 [[]default = false];\n// The parser stores options it doesn’t recognize here. See above. repeated UninterpretedOption uninterpreted_option = 999;\n// Clients can define custom options in extensions of this message. See above. extensions 1000 to max;\nreserved 4; // removed jtype }\nmessage OneofOptions { // The parser stores options it doesn’t recognize here. See above. repeated UninterpretedOption uninterpreted_option = 999;\n// Clients can define custom options in extensions of this message. See above. extensions 1000 to max; }\nmessage EnumOptions {\n// Set this option to true to allow mapping different tag names to the same // value. optional bool allow_alias = 2;\n// Is this enum deprecated? // Depending on the target platform, this can emit Deprecated annotations // for the enum, or it will be completely ignored; in the very least, this // is a formalization for deprecating enums. optional bool deprecated = 3 [[]default = false];\nreserved 5; // javanano_as_lite\n// The parser stores options it doesn’t recognize here. See above. repeated UninterpretedOption uninterpreted_option = 999;\n// Clients can define custom options in extensions of this message. See above. extensions 1000 to max; }\nmessage EnumValueOptions { // Is this enum value deprecated? // Depending on the target platform, this can emit Deprecated annotations // for the enum value, or it will be completely ignored; in the very least, // this is a formalization for deprecating enum values. optional bool deprecated = 1 [[]default = false];\n// The parser stores options it doesn’t recognize here. See above. repeated UninterpretedOption uninterpreted_option = 999;\n// Clients can define custom options in extensions of this message. See above. extensions 1000 to max; }\nmessage ServiceOptions {\n// Note: Field numbers 1 through 32 are reserved for Google’s internal RPC // framework. We apologize for hoarding these numbers to ourselves, but // we were already using them long before we decided to release Protocol // Buffers.\n// Is this service deprecated? // Depending on the target platform, this can emit Deprecated annotations // for the service, or it will be completely ignored; in the very least, // this is a formalization for deprecating services. optional bool deprecated = 33 [[]default = false];\n// The parser stores options it doesn’t recognize here. See above. repeated UninterpretedOption uninterpreted_option = 999;\n// Clients can define custom options in extensions of this message. See above. extensions 1000 to max; }\nmessage MethodOptions {\n// Note: Field numbers 1 through 32 are reserved for Google’s internal RPC // framework. We apologize for hoarding these numbers to ourselves, but // we were already using them long before we decided to release Protocol // Buffers.\n// Is this method deprecated? // Depending on the target platform, this can emit Deprecated annotations // for the method, or it will be completely ignored; in the very least, // this is a formalization for deprecating methods. optional bool deprecated = 33 [[]default = false];\n// Is this method side-effect-free (or safe in HTTP parlance), or idempotent, // or neither? HTTP based RPC implementation may choose GET verb for safe // methods, and PUT verb for idempotent methods instead of the default POST. enum IdempotencyLevel { IDEMPOTENCY_UNKNOWN = 0; NO_SIDE_EFFECTS = 1; // implies idempotent IDEMPOTENT = 2; // idempotent, but may have side effects } optional IdempotencyLevel idempotency_level = 34 [[]default = IDEMPOTENCY_UNKNOWN];\n// The parser stores options it doesn’t recognize here. See above. repeated UninterpretedOption uninterpreted_option = 999;\n// Clients can define custom options in extensions of this message. See above. extensions 1000 to max; }\n// A message representing a option the parser does not recognize. This only // appears in options protos created by the compiler::Parser class. // DescriptorPool resolves these when building Descriptor objects. Therefore, // options protos in descriptor objects (e.g. returned by Descriptor::options(), // or produced by Descriptor::CopyTo()) will never have UninterpretedOptions // in them. message UninterpretedOption { // The name of the uninterpreted option. Each string represents a segment in // a dot-separated name. is_extension is true iff a segment represents an // extension (denoted with parentheses in options specs in .proto files). // E.g.,{ [[]“foo”, false], [[]“bar.baz”, true], [[]“qux”, false] } represents // “foo.(bar.baz).qux”. message NamePart { required string name_part = 1; required bool is_extension = 2; } repeated NamePart name = 2;\n// The value of the uninterpreted option, in whatever type the tokenizer // identified it as during parsing. Exactly one of these should be set. optional string identifier_value = 3; optional uint64 positive_int_value = 4; optional int64 negative_int_value = 5; optional double double_value = 6; optional bytes string_value = 7; optional string aggregate_value = 8; }\n// =================================================================== // Optional source code info\n// Encapsulates information about the original source file from which a // FileDescriptorProto was generated. message SourceCodeInfo { // A Location identifies a piece of source code in a .proto file which // corresponds to a particular definition. This information is intended // to be useful to IDEs, code indexers, documentation generators, and similar // tools. // // For example, say we have a file like: // message Foo { // optional string foo = 1; // } // Let’s look at just the field definition: // optional string foo = 1; // ^ ^^ ^^ ^ ^^^ // a bc de f ghi // We have the following locations: // span path represents // [[]a,i) [[] 4, 0, 2, 0 ] The whole field definition. // [[]a,b) [[] 4, 0, 2, 0, 4 ] The label (optional). // [[]c,d) [[] 4, 0, 2, 0, 5 ] The type (string). // [[]e,f) [[] 4, 0, 2, 0, 1 ] The name (foo). // [[]g,h) [[] 4, 0, 2, 0, 3 ] The number (1). // // Notes: // - A location may refer to a repeated field itself (i.e. not to any // particular index within it). This is used whenever a set of elements are // logically enclosed in a single code segment. For example, an entire // extend block (possibly containing multiple extension definitions) will // have an outer location whose path refers to the “extensions” repeated // field without an index. // - Multiple locations may have the same path. This happens when a single // logical declaration is spread out across multiple places. The most // obvious example is the “extend” block again – there may be multiple // extend blocks in the same scope, each of which will have the same path. // - A location’s span is not always a subset of its parent’s span. For // example, the “extendee” of an extension declaration appears at the // beginning of the “extend” block and is shared by all extensions within // the block. // - Just because a location’s span is a subset of some other location’s span // does not mean that it is a descendant. For example, a “group” defines // both a type and a field in a single declaration. Thus, the locations // corresponding to the type and field and their components will overlap. // - Code which tries to interpret locations should probably be designed to // ignore those that it doesn’t understand, as more types of locations could // be recorded in the future. repeated Location location = 1; message Location { // Identifies which part of the FileDescriptorProto was defined at this // location. // // Each element is a field number or an index. They form a path from // the root FileDescriptorProto to the place where the definition. For // example, this path: // [[] 4, 3, 2, 7, 1 ] // refers to: // file.message_type(3) // 4, 3 // .field(7) // 2, 7 // .name() // 1 // This is because FileDescriptorProto.message_type has field number 4: // repeated DescriptorProto message_type = 4; // and DescriptorProto.field has field number 2: // repeated FieldDescriptorProto field = 2; // and FieldDescriptorProto.name has field number 1: // optional string name = 1; // // Thus, the above path gives the location of a field name. If we removed // the last element: // [[] 4, 3, 2, 7 ] // this path refers to the whole field declaration (from the beginning // of the label to the terminating semicolon). repeated int32 path = 1 [[]packed = true];\n// Always has exactly three or four elements: start line, start column, // end line (optional, otherwise assumed same as start line), end column. // These are packed into a single field for efficiency. Note that line // and column numbers are zero-based -- typically you will want to add // 1 to each before displaying to a user. repeated int32 span = 2 [[]packed = true]; // If this SourceCodeInfo represents a complete declaration, these are any // comments appearing before and after the declaration which appear to be // attached to the declaration. // // A series of line comments appearing on consecutive lines, with no other // tokens appearing on those lines, will be treated as a single comment. // // leading_detached_comments will keep paragraphs of comments that appear // before (but not connected to) the current element. Each paragraph, // separated by empty lines, will be one comment element in the repeated // field. // // Only the comment content is provided; comment markers (e.g. //) are // stripped out. For block comments, leading whitespace and an asterisk // will be stripped from the beginning of each line other than the first. // Newlines are included in the output. // // Examples: // // optional int32 foo = 1; // Comment attached to foo. // // Comment attached to bar. // optional int32 bar = 2; // // optional string baz = 3; // // Comment attached to baz. // // Another line attached to baz. // // // Comment attached to qux. // // // // Another line attached to qux. // optional double qux = 4; // // // Detached comment for corge. This is not leading or trailing comments // // to qux or corge because there are blank lines separating it from // // both. // // // Detached comment for corge paragraph 2. // // optional string corge = 5; // /* Block comment attached // * to corge. Leading asterisks // * will be removed. */ // /* Block comment attached to // * grault. */ // optional int32 grault = 6; // // // ignored detached comments. optional string leading_comments = 3; optional string trailing_comments = 4; repeated string leading_detached_comments = 6; } }\n// Describes the relationship between generated code and its original source // file. A GeneratedCodeInfo message is associated with only one generated // source file, but may contain references to different source .proto files. message GeneratedCodeInfo { // An Annotation connects some span of text in generated code to an element // of its generating .proto file. repeated Annotation annotation = 1; message Annotation { // Identifies the element in the original source .proto file. This field // is formatted the same as SourceCodeInfo.Location.path. repeated int32 path = 1 [[]packed = true];\n// Identifies the filesystem path to the original source .proto. optional string source_file = 2; // Identifies the starting offset in bytes in the generated code // that relates to the identified object. optional int32 begin = 3; // Identifies the ending offset in bytes in the generated code that // relates to the identified offset. The end offset should be one past // the last relevant byte (so the length of the text = end - begin). optional int32 end = 4; } } Classes in this fileFile MembersThese definitions are not part of any class.enum\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Type”\u003eFieldDescriptorProto_Type more…enum\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Label”\u003eFieldDescriptorProto_Label more…enum\u003ctd style=“border-left-width: 0px\"id=“FileOptions_OptimizeMode”\u003eFileOptions_OptimizeMode more…enum\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_CType”\u003eFieldOptions_CType more…enum\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_JSType”\u003eFieldOptions_JSType more…enum\u003ctd style=“border-left-width: 0px\"id=“MethodOptions_IdempotencyLevel”\u003eMethodOptions_IdempotencyLevel more…const ::protobuf::internal::DescriptorTable\u003ctd style=“border-left-width: 0px\"id=“descriptor_table_google_2fprotobuf_2fdescriptor_2eproto”\u003edescriptor_table_google_2fprotobuf_2fdescriptor_2eprotoDescriptorProtoDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"DescriptorProto_default_instance\"\u003eDescriptorProto_default_instanceDescriptorProto_ExtensionRangeDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"DescriptorProto_ExtensionRange_default_instance\"\u003eDescriptorProto_ExtensionRange_default_instanceDescriptorProto_ReservedRangeDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"DescriptorProto_ReservedRange_default_instance\"\u003eDescriptorProto_ReservedRange_default_instanceEnumDescriptorProtoDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"EnumDescriptorProto_default_instance\"\u003eEnumDescriptorProto_default_instanceEnumDescriptorProto_EnumReservedRangeDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"EnumDescriptorProto_EnumReservedRange_default_instance\"\u003eEnumDescriptorProto_EnumReservedRange_default_instanceEnumOptionsDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"EnumOptions_default_instance\"\u003eEnumOptions_default_instanceEnumValueDescriptorProtoDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"EnumValueDescriptorProto_default_instance\"\u003eEnumValueDescriptorProto_default_instanceEnumValueOptionsDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"EnumValueOptions_default_instance\"\u003eEnumValueOptions_default_instanceExtensionRangeOptionsDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"ExtensionRangeOptions_default_instance\"\u003eExtensionRangeOptions_default_instanceFieldDescriptorProtoDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"FieldDescriptorProto_default_instance\"\u003eFieldDescriptorProto_default_instanceFieldOptionsDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"FieldOptions_default_instance\"\u003eFieldOptions_default_instanceFileDescriptorProtoDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"FileDescriptorProto_default_instance\"\u003eFileDescriptorProto_default_instanceFileDescriptorSetDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"FileDescriptorSet_default_instance\"\u003eFileDescriptorSet_default_instanceFileOptionsDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"FileOptions_default_instance\"\u003eFileOptions_default_instanceGeneratedCodeInfoDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"GeneratedCodeInfo_default_instance\"\u003eGeneratedCodeInfo_default_instanceGeneratedCodeInfo_AnnotationDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"GeneratedCodeInfo_Annotation_default_instance\"\u003eGeneratedCodeInfo_Annotation_default_instanceMessageOptionsDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"MessageOptions_default_instance\"\u003eMessageOptions_default_instanceMethodDescriptorProtoDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"MethodDescriptorProto_default_instance\"\u003eMethodDescriptorProto_default_instanceMethodOptionsDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"MethodOptions_default_instance\"\u003eMethodOptions_default_instanceOneofDescriptorProtoDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"OneofDescriptorProto_default_instance\"\u003eOneofDescriptorProto_default_instanceOneofOptionsDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"OneofOptions_default_instance\"\u003eOneofOptions_default_instanceServiceDescriptorProtoDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"ServiceDescriptorProto_default_instance\"\u003eServiceDescriptorProto_default_instanceServiceOptionsDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"ServiceOptions_default_instance\"\u003eServiceOptions_default_instanceSourceCodeInfoDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"SourceCodeInfo_default_instance\"\u003eSourceCodeInfo_default_instanceSourceCodeInfo_LocationDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"SourceCodeInfo_Location_default_instance\"\u003eSourceCodeInfo_Location_default_instanceUninterpretedOptionDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"UninterpretedOption_default_instance\"\u003eUninterpretedOption_default_instanceUninterpretedOption_NamePartDefaultTypeInternal\u003ctd style=“border-left-width: 0px\"id=\"UninterpretedOption_NamePart_default_instance\"\u003eUninterpretedOption_NamePart_default_instanceconstexpr FieldDescriptorProto_Type\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Type_Type_MIN”\u003eFieldDescriptorProto_Type_Type_MIN = = FieldDescriptorProto_Type_TYPE_DOUBLEconstexpr FieldDescriptorProto_Type\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Type_Type_MAX”\u003eFieldDescriptorProto_Type_Type_MAX = = FieldDescriptorProto_Type_TYPE_SINT64constexpr int\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Type_Type_ARRAYSIZE”\u003eFieldDescriptorProto_Type_Type_ARRAYSIZE = = FieldDescriptorProto_Type_Type_MAX + 1constexpr FieldDescriptorProto_Label\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Label_Label_MIN”\u003eFieldDescriptorProto_Label_Label_MIN = = FieldDescriptorProto_Label_LABEL_OPTIONALconstexpr FieldDescriptorProto_Label\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Label_Label_MAX”\u003eFieldDescriptorProto_Label_Label_MAX = = FieldDescriptorProto_Label_LABEL_REPEATEDconstexpr int\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Label_Label_ARRAYSIZE”\u003eFieldDescriptorProto_Label_Label_ARRAYSIZE = = FieldDescriptorProto_Label_Label_MAX + 1constexpr FileOptions_OptimizeMode\u003ctd style=“border-left-width: 0px\"id=“FileOptions_OptimizeMode_OptimizeMode_MIN”\u003eFileOptions_OptimizeMode_OptimizeMode_MIN = = FileOptions_OptimizeMode_SPEEDconstexpr FileOptions_OptimizeMode\u003ctd style=“border-left-width: 0px\"id=“FileOptions_OptimizeMode_OptimizeMode_MAX”\u003eFileOptions_OptimizeMode_OptimizeMode_MAX = = FileOptions_OptimizeMode_LITE_RUNTIMEconstexpr int\u003ctd style=“border-left-width: 0px\"id=“FileOptions_OptimizeMode_OptimizeMode_ARRAYSIZE”\u003eFileOptions_OptimizeMode_OptimizeMode_ARRAYSIZE = = FileOptions_OptimizeMode_OptimizeMode_MAX + 1constexpr FieldOptions_CType\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_CType_CType_MIN”\u003eFieldOptions_CType_CType_MIN = = FieldOptions_CType_STRINGconstexpr FieldOptions_CType\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_CType_CType_MAX”\u003eFieldOptions_CType_CType_MAX = = FieldOptions_CType_STRING_PIECEconstexpr int\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_CType_CType_ARRAYSIZE”\u003eFieldOptions_CType_CType_ARRAYSIZE = = FieldOptions_CType_CType_MAX + 1constexpr FieldOptions_JSType\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_JSType_JSType_MIN”\u003eFieldOptions_JSType_JSType_MIN = = FieldOptions_JSType_JS_NORMALconstexpr FieldOptions_JSType\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_JSType_JSType_MAX”\u003eFieldOptions_JSType_JSType_MAX = = FieldOptions_JSType_JS_NUMBERconstexpr int\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_JSType_JSType_ARRAYSIZE”\u003eFieldOptions_JSType_JSType_ARRAYSIZE = = FieldOptions_JSType_JSType_MAX + 1constexpr MethodOptions_IdempotencyLevel\u003ctd style=“border-left-width: 0px\"id=“MethodOptions_IdempotencyLevel_IdempotencyLevel_MIN”\u003eMethodOptions_IdempotencyLevel_IdempotencyLevel_MIN = = MethodOptions_IdempotencyLevel_IDEMPOTENCY_UNKNOWNconstexpr MethodOptions_IdempotencyLevel\u003ctd style=“border-left-width: 0px\"id=“MethodOptions_IdempotencyLevel_IdempotencyLevel_MAX”\u003eMethodOptions_IdempotencyLevel_IdempotencyLevel_MAX = = MethodOptions_IdempotencyLevel_IDEMPOTENTconstexpr int\u003ctd style=“border-left-width: 0px\"id=“MethodOptions_IdempotencyLevel_IdempotencyLevel_ARRAYSIZE”\u003eMethodOptions_IdempotencyLevel_IdempotencyLevel_ARRAYSIZE = = MethodOptions_IdempotencyLevel_IdempotencyLevel_MAX + 1PROTOBUF_NAMESPACE_CLOSE PROTOBUF_NAMESPACE_OPEN protobuf::DescriptorProto *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::DescriptorProto \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::DescriptorProto \u003e(Arena * )protobuf::DescriptorProto_ExtensionRange *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::DescriptorProto_ExtensionRange \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::DescriptorProto_ExtensionRange \u003e(Arena * )protobuf::DescriptorProto_ReservedRange *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::DescriptorProto_ReservedRange \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::DescriptorProto_ReservedRange \u003e(Arena * )protobuf::EnumDescriptorProto *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::EnumDescriptorProto \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::EnumDescriptorProto \u003e(Arena * )protobuf::EnumDescriptorProto_EnumReservedRange *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::EnumDescriptorProto_EnumReservedRange \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::EnumDescriptorProto_EnumReservedRange \u003e(Arena * )protobuf::EnumOptions *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::EnumOptions \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::EnumOptions \u003e(Arena * )protobuf::EnumValueDescriptorProto *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::EnumValueDescriptorProto \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::EnumValueDescriptorProto \u003e(Arena * )protobuf::EnumValueOptions *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::EnumValueOptions \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::EnumValueOptions \u003e(Arena * )protobuf::ExtensionRangeOptions *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::ExtensionRangeOptions \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::ExtensionRangeOptions \u003e(Arena * )protobuf::FieldDescriptorProto *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::FieldDescriptorProto \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::FieldDescriptorProto \u003e(Arena * )protobuf::FieldOptions *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::FieldOptions \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::FieldOptions \u003e(Arena * )protobuf::FileDescriptorProto *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::FileDescriptorProto \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::FileDescriptorProto \u003e(Arena * )protobuf::FileDescriptorSet *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::FileDescriptorSet \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::FileDescriptorSet \u003e(Arena * )protobuf::FileOptions *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::FileOptions \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::FileOptions \u003e(Arena * )protobuf::GeneratedCodeInfo *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::GeneratedCodeInfo \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::GeneratedCodeInfo \u003e(Arena * )protobuf::GeneratedCodeInfo_Annotation *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::GeneratedCodeInfo_Annotation \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::GeneratedCodeInfo_Annotation \u003e(Arena * )protobuf::MessageOptions *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::MessageOptions \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::MessageOptions \u003e(Arena * )protobuf::MethodDescriptorProto *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::MethodDescriptorProto \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::MethodDescriptorProto \u003e(Arena * )protobuf::MethodOptions *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::MethodOptions \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::MethodOptions \u003e(Arena * )protobuf::OneofDescriptorProto *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::OneofDescriptorProto \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::OneofDescriptorProto \u003e(Arena * )protobuf::OneofOptions *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::OneofOptions \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::OneofOptions \u003e(Arena * )protobuf::ServiceDescriptorProto *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::ServiceDescriptorProto \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::ServiceDescriptorProto \u003e(Arena * )protobuf::ServiceOptions *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::ServiceOptions \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::ServiceOptions \u003e(Arena * )protobuf::SourceCodeInfo *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::SourceCodeInfo \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::SourceCodeInfo \u003e(Arena * )protobuf::SourceCodeInfo_Location *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::SourceCodeInfo_Location \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::SourceCodeInfo_Location \u003e(Arena * )protobuf::UninterpretedOption *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::UninterpretedOption \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::UninterpretedOption \u003e(Arena * )protobuf::UninterpretedOption_NamePart *\u003ctd style=“border-left-width: 0px\"id=“Arena::CreateMaybeMessage\u003c protobuf::UninterpretedOption_NamePart \u003e\"\u003eArena::CreateMaybeMessage\u003c protobuf::UninterpretedOption_NamePart \u003e(Arena * )bool\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Type_IsValid”\u003eFieldDescriptorProto_Type_IsValid(int value)const ::protobuf::EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Type_descriptor”\u003eFieldDescriptorProto_Type_descriptor()template const std::string \u0026\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Type_Name”\u003eFieldDescriptorProto_Type_Name(T enum_t_value)bool\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Type_Parse”\u003eFieldDescriptorProto_Type_Parse(::protobuf::ConstStringParam name, FieldDescriptorProto_Type * value)bool\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Label_IsValid”\u003eFieldDescriptorProto_Label_IsValid(int value)const ::protobuf::EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Label_descriptor”\u003eFieldDescriptorProto_Label_descriptor()template const std::string \u0026\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Label_Name”\u003eFieldDescriptorProto_Label_Name(T enum_t_value)bool\u003ctd style=“border-left-width: 0px\"id=“FieldDescriptorProto_Label_Parse”\u003eFieldDescriptorProto_Label_Parse(::protobuf::ConstStringParam name, FieldDescriptorProto_Label * value)bool\u003ctd style=“border-left-width: 0px\"id=“FileOptions_OptimizeMode_IsValid”\u003eFileOptions_OptimizeMode_IsValid(int value)const ::protobuf::EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“FileOptions_OptimizeMode_descriptor”\u003eFileOptions_OptimizeMode_descriptor()template const std::string \u0026\u003ctd style=“border-left-width: 0px\"id=“FileOptions_OptimizeMode_Name”\u003eFileOptions_OptimizeMode_Name(T enum_t_value)bool\u003ctd style=“border-left-width: 0px\"id=“FileOptions_OptimizeMode_Parse”\u003eFileOptions_OptimizeMode_Parse(::protobuf::ConstStringParam name, FileOptions_OptimizeMode * value)bool\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_CType_IsValid”\u003eFieldOptions_CType_IsValid(int value)const ::protobuf::EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_CType_descriptor”\u003eFieldOptions_CType_descriptor()template const std::string \u0026\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_CType_Name”\u003eFieldOptions_CType_Name(T enum_t_value)bool\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_CType_Parse”\u003eFieldOptions_CType_Parse(::protobuf::ConstStringParam name, FieldOptions_CType * value)bool\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_JSType_IsValid”\u003eFieldOptions_JSType_IsValid(int value)const ::protobuf::EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_JSType_descriptor”\u003eFieldOptions_JSType_descriptor()template const std::string \u0026\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_JSType_Name”\u003eFieldOptions_JSType_Name(T enum_t_value)bool\u003ctd style=“border-left-width: 0px\"id=“FieldOptions_JSType_Parse”\u003eFieldOptions_JSType_Parse(::protobuf::ConstStringParam name, FieldOptions_JSType * value)bool\u003ctd style=“border-left-width: 0px\"id=“MethodOptions_IdempotencyLevel_IsValid”\u003eMethodOptions_IdempotencyLevel_IsValid(int value)const ::protobuf::EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“MethodOptions_IdempotencyLevel_descriptor”\u003eMethodOptions_IdempotencyLevel_descriptor()template const std::string \u0026\u003ctd style=“border-left-width: 0px\"id=“MethodOptions_IdempotencyLevel_Name”\u003eMethodOptions_IdempotencyLevel_Name(T enum_t_value)bool\u003ctd style=“border-left-width: 0px\"id=“MethodOptions_IdempotencyLevel_Parse”\u003eMethodOptions_IdempotencyLevel_Parse(::protobuf::ConstStringParam name, MethodOptions_IdempotencyLevel * value)const EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“GetEnumDescriptor\u003c protobuf::FieldDescriptorProto_Type \u003e\"\u003eGetEnumDescriptor\u003c protobuf::FieldDescriptorProto_Type \u003e()const EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“GetEnumDescriptor\u003c protobuf::FieldDescriptorProto_Label \u003e\"\u003eGetEnumDescriptor\u003c protobuf::FieldDescriptorProto_Label \u003e()const EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“GetEnumDescriptor\u003c protobuf::FileOptions_OptimizeMode \u003e\"\u003eGetEnumDescriptor\u003c protobuf::FileOptions_OptimizeMode \u003e()const EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“GetEnumDescriptor\u003c protobuf::FieldOptions_CType \u003e\"\u003eGetEnumDescriptor\u003c protobuf::FieldOptions_CType \u003e()const EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“GetEnumDescriptor\u003c protobuf::FieldOptions_JSType \u003e\"\u003eGetEnumDescriptor\u003c protobuf::FieldOptions_JSType \u003e()const EnumDescriptor *\u003ctd style=“border-left-width: 0px\"id=“GetEnumDescriptor\u003c protobuf::MethodOptions_IdempotencyLevel \u003e\"\u003eGetEnumDescriptor\u003c protobuf::MethodOptions_IdempotencyLevel \u003e() enum protobuf::FieldDescriptorProto_Type {\nFieldDescriptorProto_Type_TYPE_DOUBLE = = 1,\nFieldDescriptorProto_Type_TYPE_FLOAT = = 2,\nFieldDescriptorProto_Type_TYPE_INT64 = = 3,\nFieldDescriptorProto_Type_TYPE_UINT64 = = 4,\nFieldDescriptorProto_Type_TYPE_INT32 = = 5,\nFieldDescriptorProto_Type_TYPE_FIXED64 = = 6,\nFieldDescriptorProto_Type_TYPE_FIXED32 = = 7,\nFieldDescriptorProto_Type_TYPE_BOOL = = 8,\nFieldDescriptorProto_Type_TYPE_STRING = = 9,\nFieldDescriptorProto_Type_TYPE_GROUP = = 10,\nFieldDescriptorProto_Type_TYPE_MESSAGE = = 11,\nFieldDescriptorProto_Type_TYPE_BYTES = = 12,\nFieldDescriptorProto_Type_TYPE_UINT32 = = 13,\nFieldDescriptorProto_Type_TYPE_ENUM = = 14,\nFieldDescriptorProto_Type_TYPE_SFIXED32 = = 15,\nFieldDescriptorProto_Type_TYPE_SFIXED64 = = 16,\nFieldDescriptorProto_Type_TYPE_SINT32 = = 17,\nFieldDescriptorProto_Type_TYPE_SINT64 = = 18\n}\nFieldDescriptorProto_Type_TYPE_DOUBLEFieldDescriptorProto_Type_TYPE_FLOATFieldDescriptorProto_Type_TYPE_INT64FieldDescriptorProto_Type_TYPE_UINT64FieldDescriptorProto_Type_TYPE_INT32FieldDescriptorProto_Type_TYPE_FIXED64FieldDescriptorProto_Type_TYPE_FIXED32FieldDescriptorProto_Type_TYPE_BOOLFieldDescriptorProto_Type_TYPE_STRINGFieldDescriptorProto_Type_TYPE_GROUPFieldDescriptorProto_Type_TYPE_MESSAGEFieldDescriptorProto_Type_TYPE_BYTESFieldDescriptorProto_Type_TYPE_UINT32FieldDescriptorProto_Type_TYPE_ENUMFieldDescriptorProto_Type_TYPE_SFIXED32FieldDescriptorProto_Type_TYPE_SFIXED64FieldDescriptorProto_Type_TYPE_SINT32FieldDescriptorProto_Type_TYPE_SINT64 enum protobuf::FieldDescriptorProto_Label {\nFieldDescriptorProto_Label_LABEL_OPTIONAL = = 1,\nFieldDescriptorProto_Label_LABEL_REQUIRED = = 2,\nFieldDescriptorProto_Label_LABEL_REPEATED = = 3\n}\nFieldDescriptorProto_Label_LABEL_OPTIONALFieldDescriptorProto_Label_LABEL_REQUIREDFieldDescriptorProto_Label_LABEL_REPEATED enum protobuf::FileOptions_OptimizeMode {\nFileOptions_OptimizeMode_SPEED = = 1,\nFileOptions_OptimizeMode_CODE_SIZE = = 2,\nFileOptions_OptimizeMode_LITE_RUNTIME = = 3\n}\nFileOptions_OptimizeMode_SPEEDFileOptions_OptimizeMode_CODE_SIZEFileOptions_OptimizeMode_LITE_RUNTIME enum protobuf::FieldOptions_CType {\nFieldOptions_CType_STRING = = 0,\nFieldOptions_CType_CORD = = 1,\nFieldOptions_CType_STRING_PIECE = = 2\n}\nFieldOptions_CType_STRINGFieldOptions_CType_CORDFieldOptions_CType_STRING_PIECE enum protobuf::FieldOptions_JSType {\nFieldOptions_JSType_JS_NORMAL = = 0,\nFieldOptions_JSType_JS_STRING = = 1,\nFieldOptions_JSType_JS_NUMBER = = 2\n}\nFieldOptions_JSType_JS_NORMALFieldOptions_JSType_JS_STRINGFieldOptions_JSType_JS_NUMBER enum protobuf::MethodOptions_IdempotencyLevel {\nMethodOptions_IdempotencyLevel_IDEMPOTENCY_UNKNOWN = = 0,\nMethodOptions_IdempotencyLevel_NO_SIDE_EFFECTS = = 1,\nMethodOptions_IdempotencyLevel_IDEMPOTENT = = 2\n}\nMethodOptions_IdempotencyLevel_IDEMPOTENCY_UNKNOWNMethodOptions_IdempotencyLevel_NO_SIDE_EFFECTSMethodOptions_IdempotencyLevel_IDEMPOTENT\n","categories":"","description":"","excerpt":"descriptor.pb.hdescriptor.pb.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.descriptor.pb/","tags":"","title":""},{"body":"descriptor_database.hdescriptor_database.h#include \u003cgoogle/protobuf/descriptor_database.h\u003e\nnamespace google::protobuf\nInterface for manipulating databases of descriptors. Classes in this fileDescriptorDatabaseAbstract interface for a database of descriptors. SimpleDescriptorDatabaseA DescriptorDatabase into which you can insert files manually. EncodedDescriptorDatabaseVery similar to SimpleDescriptorDatabase, but stores all the descriptors as raw bytes and generally tries to use as little memory as possible. DescriptorPoolDatabaseA DescriptorDatabase that fetches files from a given pool. MergedDescriptorDatabaseA DescriptorDatabase that wraps two or more others. class DescriptorDatabase#include \u003cgoogle/protobuf/descriptor_database.h\u003e\nnamespace google::protobuf\nAbstract interface for a database of descriptors. This is useful if you want to create a DescriptorPool which loads descriptors on-demand from some sort of large database. If the database is large, it may be inefficient to enumerate every .proto file inside it calling DescriptorPool::BuildFile() for each one. Instead, a DescriptorPool can be created which wraps a DescriptorDatabase and only builds particular descriptors when they are needed. Known subclasses:\nDescriptorPoolDatabaseEncodedDescriptorDatabaseMergedDescriptorDatabaseSimpleDescriptorDatabaseSourceTreeDescriptorDatabaseMembersDescriptorDatabase()virtual ~DescriptorDatabase()virtual boolFindFileByName(const std::string \u0026 filename, FileDescriptorProto * output) = 0Find a file by file name. more...virtual boolFindFileContainingSymbol(const std::string \u0026 symbol_name, FileDescriptorProto * output) = 0Find the file that declares the given fully-qualified symbol name. more...virtual boolFindFileContainingExtension(const std::string \u0026 containing_type, int field_number, FileDescriptorProto * output) = 0Find the file which defines an extension extending the given message type with the given field number. more...virtual boolFindAllExtensionNumbers(const std::string \u0026 , std::vector\u003c int \u003e * )Finds the tag numbers used by all known extensions of extendee_type, and appends them to output in an undefined order. more...virtual boolFindAllFileNames(std::vector\u003c std::string \u003e * )Finds the file names and appends them to the output in an undefined order. more...boolFindAllPackageNames(std::vector\u003c std::string \u003e * output)Finds the package names and appends them to the output in an undefined order. more...boolFindAllMessageNames(std::vector\u003c std::string \u003e * output)Finds the message names and appends them to the output in an undefined order. more... virtual bool DescriptorDatabase::FindFileByName(\n        const std::string \u0026 filename,\n        FileDescriptorProto * output) = 0Find a file by file name. Fills in in *output and returns true if found. Otherwise, returns false, leaving the contents of *output undefined. virtual bool DescriptorDatabase::FindFileContainingSymbol(\n        const std::string \u0026 symbol_name,\n        FileDescriptorProto * output) = 0Find the file that declares the given fully-qualified symbol name. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. virtual bool DescriptorDatabase::FindFileContainingExtension(\n        const std::string \u0026 containing_type,\n        int field_number,\n        FileDescriptorProto * output) = 0Find the file which defines an extension extending the given message type with the given field number. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. containing_type must be a fully-qualified type name. virtual bool DescriptorDatabase::FindAllExtensionNumbers(\n        const std::string \u0026 ,\n        std::vector\u003c int \u003e * )Finds the tag numbers used by all known extensions of extendee_type, and appends them to output in an undefined order. This method is best-effort: it's not guaranteed that the database will find all extensions, and it's not guaranteed that FindFileContainingExtension will return true on all of the found numbers. Returns true if the search was successful, otherwise returns false and leaves output unchanged.\nThis method has a default implementation that always returns false. virtual bool DescriptorDatabase::FindAllFileNames(\n        std::vector\u003c std::string \u003e * )Finds the file names and appends them to the output in an undefined order. This method is best-effort: it's not guaranteed that the database will find all files. Returns true if the database supports searching all file names, otherwise returns false and leaves output unchanged.\nThis method has a default implementation that always returns false. bool DescriptorDatabase::FindAllPackageNames(\n        std::vector\u003c std::string \u003e * output)Finds the package names and appends them to the output in an undefined order. This method is best-effort: it's not guaranteed that the database will find all packages. Returns true if the database supports searching all package names, otherwise returns false and leaves output unchanged. bool DescriptorDatabase::FindAllMessageNames(\n        std::vector\u003c std::string \u003e * output)Finds the message names and appends them to the output in an undefined order. This method is best-effort: it's not guaranteed that the database will find all messages. Returns true if the database supports searching all message names, otherwise returns false and leaves output unchanged. class SimpleDescriptorDatabase: public DescriptorDatabase#include \u003cgoogle/protobuf/descriptor_database.h\u003e\nnamespace google::protobuf\nA DescriptorDatabase into which you can insert files manually. FindFileContainingSymbol() is fully-implemented. When you add a file, its symbols will be indexed for this purpose. Note that the implementation may return false positives, but only if it isn't possible for the symbol to be defined in any other file. In particular, if a file defines a symbol \"Foo\", then searching for \"Foo.[[]anything]\" will match that file. This way, the database does not need to aggressively index all children of a symbol.\nFindFileContainingExtension() is mostly-implemented. It works if and only if the original FieldDescriptorProto defining the extension has a fully-qualified type name in its \"extendee\" field (i.e. starts with a '.'). If the extendee is a relative name, SimpleDescriptorDatabase will not attempt to resolve the type, so it will not know what type the extension is extending. Therefore, calling FindFileContainingExtension() with the extension's containing type will never actually find that extension. Note that this is an unlikely problem, as all FileDescriptorProtos created by the protocol compiler (as well as ones created by calling FileDescriptor::CopyTo()) will always use fully-qualified names for all types. You only need to worry if you are constructing FileDescriptorProtos yourself, or are calling compiler::Parser directly. MembersSimpleDescriptorDatabase()~SimpleDescriptorDatabase()boolAdd(const FileDescriptorProto \u0026 file)Adds the FileDescriptorProto to the database, making a copy. more...boolAddAndOwn(const FileDescriptorProto * file)Adds the FileDescriptorProto to the database and takes ownership of it. implements DescriptorDatabasevirtual boolFindFileByName(const std::string \u0026 filename, FileDescriptorProto * output)Find a file by file name. more...virtual boolFindFileContainingSymbol(const std::string \u0026 symbol_name, FileDescriptorProto * output)Find the file that declares the given fully-qualified symbol name. more...virtual boolFindFileContainingExtension(const std::string \u0026 containing_type, int field_number, FileDescriptorProto * output)Find the file which defines an extension extending the given message type with the given field number. more...virtual boolFindAllExtensionNumbers(const std::string \u0026 , std::vector\u003c int \u003e * )Finds the tag numbers used by all known extensions of extendee_type, and appends them to output in an undefined order. more...virtual boolFindAllFileNames(std::vector\u003c std::string \u003e * )Finds the file names and appends them to the output in an undefined order. more... bool SimpleDescriptorDatabase::Add(\n        const FileDescriptorProto \u0026 file)Adds the FileDescriptorProto to the database, making a copy. The object can be deleted after Add() returns. Returns false if the file conflicted with a file already in the database, in which case an error will have been written to GOOGLE_LOG(ERROR). virtual bool SimpleDescriptorDatabase::FindFileByName(\n        const std::string \u0026 filename,\n        FileDescriptorProto * output)Find a file by file name. Fills in in *output and returns true if found. Otherwise, returns false, leaving the contents of *output undefined. virtual bool SimpleDescriptorDatabase::FindFileContainingSymbol(\n        const std::string \u0026 symbol_name,\n        FileDescriptorProto * output)Find the file that declares the given fully-qualified symbol name. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. virtual bool SimpleDescriptorDatabase::FindFileContainingExtension(\n        const std::string \u0026 containing_type,\n        int field_number,\n        FileDescriptorProto * output)Find the file which defines an extension extending the given message type with the given field number. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. containing_type must be a fully-qualified type name. virtual bool SimpleDescriptorDatabase::FindAllExtensionNumbers(\n        const std::string \u0026 ,\n        std::vector\u003c int \u003e * )Finds the tag numbers used by all known extensions of extendee_type, and appends them to output in an undefined order. This method is best-effort: it's not guaranteed that the database will find all extensions, and it's not guaranteed that FindFileContainingExtension will return true on all of the found numbers. Returns true if the search was successful, otherwise returns false and leaves output unchanged.\nThis method has a default implementation that always returns false. virtual bool SimpleDescriptorDatabase::FindAllFileNames(\n        std::vector\u003c std::string \u003e * )Finds the file names and appends them to the output in an undefined order. This method is best-effort: it's not guaranteed that the database will find all files. Returns true if the database supports searching all file names, otherwise returns false and leaves output unchanged.\nThis method has a default implementation that always returns false. class EncodedDescriptorDatabase: public DescriptorDatabase#include \u003cgoogle/protobuf/descriptor_database.h\u003e\nnamespace google::protobuf\nVery similar to SimpleDescriptorDatabase, but stores all the descriptors as raw bytes and generally tries to use as little memory as possible. The same caveats regarding FindFileContainingExtension() apply as with SimpleDescriptorDatabase. MembersEncodedDescriptorDatabase()~EncodedDescriptorDatabase()boolAdd(const void * encoded_file_descriptor, int size)Adds the FileDescriptorProto to the database. more...boolAddCopy(const void * encoded_file_descriptor, int size)Like Add(), but makes a copy of the data, so that the caller does not need to keep it around. boolFindNameOfFileContainingSymbol(const std::string \u0026 symbol_name, std::string * output)Like FindFileContainingSymbol but returns only the name of the file. implements DescriptorDatabasevirtual boolFindFileByName(const std::string \u0026 filename, FileDescriptorProto * output)Find a file by file name. more...virtual boolFindFileContainingSymbol(const std::string \u0026 symbol_name, FileDescriptorProto * output)Find the file that declares the given fully-qualified symbol name. more...virtual boolFindFileContainingExtension(const std::string \u0026 containing_type, int field_number, FileDescriptorProto * output)Find the file which defines an extension extending the given message type with the given field number. more...virtual boolFindAllExtensionNumbers(const std::string \u0026 , std::vector\u003c int \u003e * )Finds the tag numbers used by all known extensions of extendee_type, and appends them to output in an undefined order. more...virtual boolFindAllFileNames(std::vector\u003c std::string \u003e * )Finds the file names and appends them to the output in an undefined order. more... bool EncodedDescriptorDatabase::Add(\n        const void * encoded_file_descriptor,\n        int size)Adds the FileDescriptorProto to the database. The descriptor is provided in encoded form. The database does not make a copy of the bytes, nor does it take ownership; it's up to the caller to make sure the bytes remain valid for the life of the database. Returns false and logs an error if the bytes are not a valid FileDescriptorProto or if the file conflicted with a file already in the database. virtual bool EncodedDescriptorDatabase::FindFileByName(\n        const std::string \u0026 filename,\n        FileDescriptorProto * output)Find a file by file name. Fills in in *output and returns true if found. Otherwise, returns false, leaving the contents of *output undefined. virtual bool EncodedDescriptorDatabase::FindFileContainingSymbol(\n        const std::string \u0026 symbol_name,\n        FileDescriptorProto * output)Find the file that declares the given fully-qualified symbol name. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. virtual bool EncodedDescriptorDatabase::FindFileContainingExtension(\n        const std::string \u0026 containing_type,\n        int field_number,\n        FileDescriptorProto * output)Find the file which defines an extension extending the given message type with the given field number. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. containing_type must be a fully-qualified type name. virtual bool EncodedDescriptorDatabase::FindAllExtensionNumbers(\n        const std::string \u0026 ,\n        std::vector\u003c int \u003e * )Finds the tag numbers used by all known extensions of extendee_type, and appends them to output in an undefined order. This method is best-effort: it's not guaranteed that the database will find all extensions, and it's not guaranteed that FindFileContainingExtension will return true on all of the found numbers. Returns true if the search was successful, otherwise returns false and leaves output unchanged.\nThis method has a default implementation that always returns false. virtual bool EncodedDescriptorDatabase::FindAllFileNames(\n        std::vector\u003c std::string \u003e * )Finds the file names and appends them to the output in an undefined order. This method is best-effort: it's not guaranteed that the database will find all files. Returns true if the database supports searching all file names, otherwise returns false and leaves output unchanged.\nThis method has a default implementation that always returns false. class DescriptorPoolDatabase: public DescriptorDatabase#include \u003cgoogle/protobuf/descriptor_database.h\u003e\nnamespace google::protobuf\nA DescriptorDatabase that fetches files from a given pool. Membersexplicit DescriptorPoolDatabase(const DescriptorPool \u0026 pool)~DescriptorPoolDatabase()implements DescriptorDatabasevirtual boolFindFileByName(const std::string \u0026 filename, FileDescriptorProto * output)Find a file by file name. more...virtual boolFindFileContainingSymbol(const std::string \u0026 symbol_name, FileDescriptorProto * output)Find the file that declares the given fully-qualified symbol name. more...virtual boolFindFileContainingExtension(const std::string \u0026 containing_type, int field_number, FileDescriptorProto * output)Find the file which defines an extension extending the given message type with the given field number. more...virtual boolFindAllExtensionNumbers(const std::string \u0026 , std::vector\u003c int \u003e * )Finds the tag numbers used by all known extensions of extendee_type, and appends them to output in an undefined order. more... virtual bool DescriptorPoolDatabase::FindFileByName(\n        const std::string \u0026 filename,\n        FileDescriptorProto * output)Find a file by file name. Fills in in *output and returns true if found. Otherwise, returns false, leaving the contents of *output undefined. virtual bool DescriptorPoolDatabase::FindFileContainingSymbol(\n        const std::string \u0026 symbol_name,\n        FileDescriptorProto * output)Find the file that declares the given fully-qualified symbol name. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. virtual bool DescriptorPoolDatabase::FindFileContainingExtension(\n        const std::string \u0026 containing_type,\n        int field_number,\n        FileDescriptorProto * output)Find the file which defines an extension extending the given message type with the given field number. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. containing_type must be a fully-qualified type name. virtual bool DescriptorPoolDatabase::FindAllExtensionNumbers(\n        const std::string \u0026 ,\n        std::vector\u003c int \u003e * )Finds the tag numbers used by all known extensions of extendee_type, and appends them to output in an undefined order. This method is best-effort: it's not guaranteed that the database will find all extensions, and it's not guaranteed that FindFileContainingExtension will return true on all of the found numbers. Returns true if the search was successful, otherwise returns false and leaves output unchanged.\nThis method has a default implementation that always returns false. class MergedDescriptorDatabase: public DescriptorDatabase#include \u003cgoogle/protobuf/descriptor_database.h\u003e\nnamespace google::protobuf\nA DescriptorDatabase that wraps two or more others. It first searches the first database and, if that fails, tries the second, and so on. MembersMergedDescriptorDatabase(DescriptorDatabase * source1, DescriptorDatabase * source2)Merge just two databases. The sources remain property of the caller. explicit MergedDescriptorDatabase(const std::vector\u003c DescriptorDatabase * \u003e \u0026 sources)Merge more than two databases. more...~MergedDescriptorDatabase()implements DescriptorDatabasevirtual boolFindFileByName(const std::string \u0026 filename, FileDescriptorProto * output)Find a file by file name. more...virtual boolFindFileContainingSymbol(const std::string \u0026 symbol_name, FileDescriptorProto * output)Find the file that declares the given fully-qualified symbol name. more...virtual boolFindFileContainingExtension(const std::string \u0026 containing_type, int field_number, FileDescriptorProto * output)Find the file which defines an extension extending the given message type with the given field number. more...virtual boolFindAllExtensionNumbers(const std::string \u0026 extendee_type, std::vector\u003c int \u003e * output)Merges the results of calling all databases. more... explicit MergedDescriptorDatabase::MergedDescriptorDatabase(\n        const std::vector\u003c DescriptorDatabase * \u003e \u0026 sources)Merge more than two databases. The sources remain property of the caller. The vector may be deleted after the constructor returns but the DescriptorDatabases need to stick around. virtual bool MergedDescriptorDatabase::FindFileByName(\n        const std::string \u0026 filename,\n        FileDescriptorProto * output)Find a file by file name. Fills in in *output and returns true if found. Otherwise, returns false, leaving the contents of *output undefined. virtual bool MergedDescriptorDatabase::FindFileContainingSymbol(\n        const std::string \u0026 symbol_name,\n        FileDescriptorProto * output)Find the file that declares the given fully-qualified symbol name. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. virtual bool MergedDescriptorDatabase::FindFileContainingExtension(\n        const std::string \u0026 containing_type,\n        int field_number,\n        FileDescriptorProto * output)Find the file which defines an extension extending the given message type with the given field number. If found, fills in *output and returns true, otherwise returns false and leaves *output undefined. containing_type must be a fully-qualified type name. virtual bool MergedDescriptorDatabase::FindAllExtensionNumbers(\n        const std::string \u0026 extendee_type,\n        std::vector\u003c int \u003e * output)Merges the results of calling all databases. Returns true iff any of the databases returned true. ","categories":"","description":"","excerpt":"descriptor_database.hdescriptor_database.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.descriptor_database/","tags":"","title":""},{"body":"dynamic_message.hdynamic_message.h#include \u003cgoogle/protobuf/dynamic_message.h\u003e\nnamespace google::protobuf\nDefines an implementation of Message which can emulate types which are not known at compile-time. Classes in this fileDynamicMessageFactoryConstructs implementations of Message which can emulate types which are not known at compile-time. DynamicMapSorterHelper for computing a sorted list of map entries via reflection. class DynamicMessageFactory: public MessageFactory#include \u003cgoogle/protobuf/dynamic_message.h\u003e\nnamespace google::protobuf\nConstructs implementations of Message which can emulate types which are not known at compile-time. Sometimes you want to be able to manipulate protocol types that you don't know about at compile time. It would be nice to be able to construct a Message object which implements the message type given by any arbitrary Descriptor. DynamicMessage provides this.\nAs it turns out, a DynamicMessage needs to construct extra information about its type in order to operate. Most of this information can be shared between all DynamicMessages of the same type. But, caching this information in some sort of global map would be a bad idea, since the cached information for a particular descriptor could outlive the descriptor itself. To avoid this problem, DynamicMessageFactory encapsulates this \"cache\". All DynamicMessages of the same type created from the same factory will share the same support data. Any Descriptors used with a particular factory must outlive the factory. MembersDynamicMessageFactory()Construct a DynamicMessageFactory that will search for extensions in the DescriptorPool in which the extendee is defined. DynamicMessageFactory(const DescriptorPool * pool)Construct a DynamicMessageFactory that will search for extensions in the given DescriptorPool. more...~DynamicMessageFactory()voidSetDelegateToGeneratedFactory(bool enable)Call this to tell the DynamicMessageFactory that if it is given a Descriptor d for which: more...implements MessageFactoryvirtual const Message *GetPrototype(const Descriptor * type)Given a Descriptor, constructs the default (prototype) Message of that type. more... DynamicMessageFactory::DynamicMessageFactory(\n        const DescriptorPool * pool)Construct a DynamicMessageFactory that will search for extensions in the given DescriptorPool. DEPRECATED: Use CodedInputStream::SetExtensionRegistry() to tell the parser to look for extensions in an alternate pool. However, note that this is almost never what you want to do. Almost all users should use the zero-arg constructor. void DynamicMessageFactory::SetDelegateToGeneratedFactory(\n        bool enable)Call this to tell the DynamicMessageFactory that if it is given a Descriptor d for which: d-\u003efile()-\u003epool() == DescriptorPool::generated_pool(), then it should delegate to MessageFactory::generated_factory() instead of constructing a dynamic implementation of the message. In theory there is no down side to doing this, so it may become the default in the future. virtual const Message * DynamicMessageFactory::GetPrototype(\n        const Descriptor * type)Given a Descriptor, constructs the default (prototype) Message of that type. You can then call that message's New() method to construct a mutable message of that type.\nCalling this method twice with the same Descriptor returns the same object. The returned object remains property of the factory and will be destroyed when the factory is destroyed. Also, any objects created by calling the prototype's New() method share some data with the prototype, so these must be destroyed before the DynamicMessageFactory is destroyed.\nThe given descriptor must outlive the returned message, and hence must outlive the DynamicMessageFactory.\nThe method is thread-safe. class DynamicMapSorter#include \u003cgoogle/protobuf/dynamic_message.h\u003e\nnamespace google::protobuf\nHelper for computing a sorted list of map entries via reflection. Membersstatic std::vector\u003c const Message * \u003eSort(const Message \u0026 message, int map_size, const Reflection * reflection, const FieldDescriptor * field)","categories":"","description":"","excerpt":"dynamic_message.hdynamic_message.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.dynamic_message/","tags":"","title":""},{"body":"coded_stream.hcoded_stream.h#include \u003cgoogle/protobuf/io/coded_stream.h\u003e\nnamespace google::protobuf::io\nThis file contains the CodedInputStream and CodedOutputStream classes, which wrap a ZeroCopyInputStream or ZeroCopyOutputStream, respectively, and allow you to read or write individual pieces of data in various formats. In particular, these implement the varint encoding for integers, a simple variable-length encoding in which smaller numbers take fewer bytes.\nTypically these classes will only be used internally by the protocol buffer library in order to encode and decode protocol buffers. Clients of the library only need to know about this class if they wish to write custom message parsing or serialization procedures.\nCodedOutputStream example: // Write some data to \"myfile\". First we write a 4-byte \"magic number\" // to identify the file type, then write a length-delimited string. The // string is composed of a varint giving the length followed by the raw // bytes. int fd = open(\"myfile\", O_CREAT | O_WRONLY); ZeroCopyOutputStream* raw_output = new FileOutputStream(fd); CodedOutputStream* coded_output = new CodedOutputStream(raw_output); int magic_number = 1234; char text[[]] = “Hello world!”; coded_output-\u003eWriteLittleEndian32(magic_number); coded_output-\u003eWriteVarint32(strlen(text)); coded_output-\u003eWriteRaw(text, strlen(text));\ndelete coded_output; delete raw_output; close(fd);\nCodedInputStream example: // Read a file created by the above code. int fd = open(\"myfile\", O_RDONLY); ZeroCopyInputStream* raw_input = new FileInputStream(fd); CodedInputStream* coded_input = new CodedInputStream(raw_input); coded_input-\u003eReadLittleEndian32(\u0026magic_number); if (magic_number != 1234) { cerr \u003c\u003c “File not in expected format.” \u003c\u003c endl; return; }\nuint32 size; coded_input-\u003eReadVarint32(\u0026size);\nchar* text = new char[[]size + 1]; coded_input-\u003eReadRaw(buffer, size); text[[]size] = ‘\\0’;\ndelete coded_input; delete raw_input; close(fd);\ncout \u003c\u003c “Text is: \" \u003c\u003c text \u003c\u003c endl; delete [[]] text;\nFor those who are interested, varint encoding is defined as follows:\nThe encoding operates on unsigned integers of up to 64 bits in length. Each byte of the encoded value has the format:\nbits 0-6: Seven bits of the number being encoded. bit 7: Zero if this is the last byte in the encoding (in which case all remaining bits of the number are zero) or 1 if more bytes follow. The first byte contains the least-significant 7 bits of the number, the second byte (if present) contains the next-least-significant 7 bits, and so on. So, the binary number 1011000101011 would be encoded in two bytes as \"10101011 00101100\". In theory, varint could be used to encode integers of any length. However, for practicality we set a limit at 64 bits. The maximum encoded length of a number is thus 10 bytes. Classes in this fileCodedInputStreamClass which reads and decodes binary data which is composed of varint- encoded integers and fixed-width pieces. EpsCopyOutputStreamEpsCopyOutputStream wraps a ZeroCopyOutputStream and exposes a new stream, which has the property you can write kSlopBytes (16 bytes) from the current position without bounds checks. CodedOutputStreamClass which encodes and writes binary data which is composed of varint- encoded integers and fixed-width pieces. CodedOutputStream::StaticVarintSize32Compile-time equivalent of VarintSize32(). class CodedInputStream#include \u003cgoogle/protobuf/io/coded_stream.h\u003e\nnamespace google::protobuf::io\nClass which reads and decodes binary data which is composed of varint- encoded integers and fixed-width pieces. Wraps a ZeroCopyInputStream. Most users will not need to deal with CodedInputStream.\nMost methods of CodedInputStream that return a bool return false if an underlying I/O error occurs or if the data is malformed. Once such a failure occurs, the CodedInputStream is broken and is no longer useful. After a failure, callers also should assume writes to \"out\" args may have occurred, though nothing useful can be determined from those writes. Membersexplicit CodedInputStream(ZeroCopyInputStream * input)Create a CodedInputStream that reads from the given ZeroCopyInputStream. explicit CodedInputStream(const uint8 * buffer, int size)Create a CodedInputStream that reads from the given flat array. more...~CodedInputStream()Destroy the CodedInputStream and position the underlying ZeroCopyInputStream at the first unread byte. more...boolIsFlat() constReturn true if this CodedInputStream reads from a flat array instead of a ZeroCopyInputStream. boolSkip(int count)Skips a number of bytes. more...boolGetDirectBufferPointer(const void ** data, int * size)Sets *data to point directly at the unread part of the CodedInputStream's underlying buffer, and *size to the size of that buffer, but does not advance the stream's current position. more...voidGetDirectBufferPointerInline(const void ** data, int * size)Like GetDirectBufferPointer, but this method is inlined, and does not attempt to Refresh() if the buffer is currently empty. boolReadRaw(void * buffer, int size)Read raw bytes, copying them into the given buffer. boolReadString(std::string * buffer, int size)Like ReadRaw, but reads into a string. boolReadLittleEndian32(uint32 * value)Read a 32-bit little-endian integer. boolReadLittleEndian64(uint64 * value)Read a 64-bit little-endian integer. boolReadVarint32(uint32 * value)Read an unsigned integer with Varint encoding, truncating to 32 bits. more...boolReadVarint64(uint64 * value)Read an unsigned integer with Varint encoding. boolReadVarintSizeAsInt(int * value)Reads a varint off the wire into an \"int\". more...uint32ReadTag()Read a tag. more...uint32ReadTagNoLastTag()std::pair\u003c uint32, bool \u003eReadTagWithCutoff(uint32 cutoff)This usually a faster alternative to ReadTag() when cutoff is a manifest constant. more...std::pair\u003c uint32, bool \u003eReadTagWithCutoffNoLastTag(uint32 cutoff)boolExpectTag(uint32 expected)Usually returns true if calling ReadVarint32() now would produce the given value. more...boolExpectAtEnd()Usually returns true if no more bytes can be read. more...boolLastTagWas(uint32 expected)If the last call to ReadTag() or ReadTagWithCutoff() returned the given value, returns true. more...voidSetLastTag(uint32 tag)boolConsumedEntireMessage()When parsing message (but NOT a group), this method must be called immediately after MergeFromCodedStream() returns (if it returns true) to further verify that the message ended in a legitimate way. more...voidSetConsumed()static const uint8 *ReadLittleEndian32FromArray(const uint8 * buffer, uint32 * value)These methods read from an externally provided buffer. more...static const uint8 *ReadLittleEndian64FromArray(const uint8 * buffer, uint64 * value)Read a 64-bit little-endian integer. more...static const uint8 *ExpectTagFromArray(const uint8 * buffer, uint32 expected)Like above, except this reads from the specified buffer. more...LimitsLimits are used when parsing length-delimited embedded messages. After the message's length is read, PushLimit() is used to prevent the CodedInputStream from reading beyond that length. Once the embedded message has been parsed, PopLimit() is called to undo the limit. typedefint LimitOpaque type used with PushLimit() and PopLimit(). more...LimitPushLimit(int byte_limit)Places a limit on the number of bytes that the stream may read, starting from the current position. more...voidPopLimit(Limit limit)Pops the last limit pushed by PushLimit(). more...intBytesUntilLimit() constReturns the number of bytes left until the nearest limit on the stack is hit, or -1 if no limits are in place. intCurrentPosition() constReturns current position relative to the beginning of the input stream. Total Bytes LimitTo prevent malicious users from sending excessively large messages and causing memory exhaustion, CodedInputStream imposes a hard limit on the total number of bytes it will read. int = { SetTotalBytesLimit(total_bytes_limit)voidSetTotalBytesLimit(int total_bytes_limit)Sets the maximum number of bytes that this CodedInputStream will read before refusing to continue. more...PROTOBUF_DEPRECATED_MSG(\"Please use the single parameter version of SetTotalBytesLimit(). The \" \"second parameter is ignored.\" )intBytesUntilTotalBytesLimit() constThe Total Bytes Limit minus the Current Position, or -1 if the total bytes limit is INT_MAX. Recursion Limit To prevent corrupt or malicious messages from causing stack overflows, we must keep track of the depth of recursion when parsing embedded messages and groups.\nCodedInputStream keeps track of this because it is the only object that is passed down the stack during parsing. voidSetRecursionLimit(int limit)Sets the maximum recursion depth. The default is 100. intRecursionBudget()boolIncrementRecursionDepth()Increments the current recursion depth. more...voidDecrementRecursionDepth()Decrements the recursion depth if possible. voidUnsafeDecrementRecursionDepth()Decrements the recursion depth blindly. more...std::pair\u003c CodedInputStream::Limit, int \u003eIncrementRecursionDepthAndPushLimit(int byte_limit)Shorthand for make_pair(PushLimit(byte_limit), –recursion_budget_). more...LimitReadLengthAndPushLimit()Shorthand for PushLimit(ReadVarint32(\u0026length) ? length : 0). boolDecrementRecursionDepthAndPopLimit(Limit limit)Helper that is equivalent to: { bool result = ConsumedEntireMessage(); PopLimit(limit); UnsafeDecrementRecursionDepth(); return result; } Using this can reduce code size and complexity in some cases. more...boolCheckEntireMessageConsumedAndPopLimit(Limit limit)Helper that is equivalent to: { bool result = ConsumedEntireMessage(); PopLimit(limit); return result; } Using this can reduce code size and complexity in some cases. static intGetDefaultRecursionLimit()Extension Registry ADVANCED USAGE: 99.9% of people can ignore this section.\nBy default, when parsing extensions, the parser looks for extension definitions in the pool which owns the outer message's Descriptor. However, you may call SetExtensionRegistry() to provide an alternative pool instead. This makes it possible, for example, to parse a message using a generated class, but represent some extensions using DynamicMessage. voidSetExtensionRegistry(const DescriptorPool * pool, MessageFactory * factory)Set the pool used to look up extensions. more...const DescriptorPool *GetExtensionPool()Get the DescriptorPool set via SetExtensionRegistry(), or NULL if no pool has been provided. MessageFactory *GetExtensionFactory()Get the MessageFactory set via SetExtensionRegistry(), or NULL if no factory has been provided. explicit CodedInputStream::CodedInputStream(\n        const uint8 * buffer,\n        int size)Create a CodedInputStream that reads from the given flat array. This is faster than using an ArrayInputStream. PushLimit(size) is implied by this constructor. CodedInputStream::~CodedInputStream()Destroy the CodedInputStream and position the underlying ZeroCopyInputStream at the first unread byte. If an error occurred while reading (causing a method to return false), then the exact position of the input stream may be anywhere between the last value that was read successfully and the stream's byte limit. bool CodedInputStream::Skip(\n        int count)Skips a number of bytes. Returns false if an underlying read error occurs. bool CodedInputStream::GetDirectBufferPointer(\n        const void ** data,\n        int * size)Sets *data to point directly at the unread part of the CodedInputStream's underlying buffer, and *size to the size of that buffer, but does not advance the stream's current position. This will always either produce a non-empty buffer or return false. If the caller consumes any of this data, it should then call Skip() to skip over the consumed bytes. This may be useful for implementing external fast parsing routines for types of data not covered by the CodedInputStream interface. bool CodedInputStream::ReadVarint32(\n        uint32 * value)Read an unsigned integer with Varint encoding, truncating to 32 bits. Reading a 32-bit value is equivalent to reading a 64-bit one and casting it to uint32, but may be more efficient. bool CodedInputStream::ReadVarintSizeAsInt(\n        int * value)Reads a varint off the wire into an \"int\". This should be used for reading sizes off the wire (sizes of strings, submessages, bytes fields, etc).\nThe value from the wire is interpreted as unsigned. If its value exceeds the representable value of an integer on this platform, instead of truncating we return false. Truncating (as performed by ReadVarint32() above) is an acceptable approach for fields representing an integer, but when we are parsing a size from the wire, truncating the value would result in us misparsing the payload. uint32 CodedInputStream::ReadTag()Read a tag. This calls ReadVarint32() and returns the result, or returns zero (which is not a valid tag) if ReadVarint32() fails. Also, ReadTag (but not ReadTagNoLastTag) updates the last tag value, which can be checked with LastTagWas().\nAlways inline because this is only called in one place per parse loop but it is called for every iteration of said loop, so it should be fast. GCC doesn't want to inline this by default. std::pair\u003c uint32, bool \u003e     CodedInputStream::ReadTagWithCutoff(\n        uint32 cutoff)This usually a faster alternative to ReadTag() when cutoff is a manifest constant. It does particularly well for cutoff \u003e= 127. The first part of the return value is the tag that was read, though it can also be 0 in the cases where ReadTag() would return 0. If the second part is true then the tag is known to be in [[]0, cutoff]. If not, the tag either is above cutoff or is 0. (There's intentional wiggle room when tag is 0, because that can arise in several ways, and for best performance we want to avoid an extra \"is tag == 0?\" check here.) bool CodedInputStream::ExpectTag(\n        uint32 expected)Usually returns true if calling ReadVarint32() now would produce the given value. Will always return false if ReadVarint32() would not return the given value. If ExpectTag() returns true, it also advances past the varint. For best performance, use a compile-time constant as the parameter. Always inline because this collapses to a small number of instructions when given a constant parameter, but GCC doesn't want to inline by default. bool CodedInputStream::ExpectAtEnd()Usually returns true if no more bytes can be read. Always returns false if more bytes can be read. If ExpectAtEnd() returns true, a subsequent call to LastTagWas() will act as if ReadTag() had been called and returned zero, and ConsumedEntireMessage() will return true. bool CodedInputStream::LastTagWas(\n        uint32 expected)If the last call to ReadTag() or ReadTagWithCutoff() returned the given value, returns true. Otherwise, returns false. ReadTagNoLastTag/ReadTagWithCutoffNoLastTag do not preserve the last returned value.\nThis is needed because parsers for some types of embedded messages (with field type TYPE_GROUP) don't actually know that they've reached the end of a message until they see an ENDGROUP tag, which was actually part of the enclosing message. The enclosing message would like to check that tag to make sure it had the right number, so it calls LastTagWas() on return from the embedded parser to check. bool CodedInputStream::ConsumedEntireMessage()When parsing message (but NOT a group), this method must be called immediately after MergeFromCodedStream() returns (if it returns true) to further verify that the message ended in a legitimate way. For example, this verifies that parsing did not end on an end-group tag. It also checks for some cases where, due to optimizations, MergeFromCodedStream() can incorrectly return true. static const uint8 * CodedInputStream::ReadLittleEndian32FromArray(\n        const uint8 * buffer,\n        uint32 * value)These methods read from an externally provided buffer. static\nThe caller is responsible for ensuring that the buffer has sufficient space. Read a 32-bit little-endian integer. static const uint8 * CodedInputStream::ReadLittleEndian64FromArray(\n        const uint8 * buffer,\n        uint64 * value)Read a 64-bit little-endian integer. static static const uint8 * CodedInputStream::ExpectTagFromArray(\n        const uint8 * buffer,\n        uint32 expected)Like above, except this reads from the specified buffer. The caller is responsible for ensuring that the buffer is large enough to read a varint of the expected size. For best performance, use a compile-time constant as the expected tag parameter.\nReturns a pointer beyond the expected tag if it was found, or NULL if it was not. typedef CodedInputStream::LimitOpaque type used with PushLimit() and PopLimit(). Do not modify values of this type yourself. The only reason that this isn't a struct with private internals is for efficiency. Limit CodedInputStream::PushLimit(\n        int byte_limit)Places a limit on the number of bytes that the stream may read, starting from the current position. Once the stream hits this limit, it will act like the end of the input has been reached until PopLimit() is called.\nAs the names imply, the stream conceptually has a stack of limits. The shortest limit on the stack is always enforced, even if it is not the top limit.\nThe value returned by PushLimit() is opaque to the caller, and must be passed unchanged to the corresponding call to PopLimit(). void CodedInputStream::PopLimit(\n        Limit limit)Pops the last limit pushed by PushLimit(). The input must be the value returned by that call to PushLimit(). void CodedInputStream::SetTotalBytesLimit(\n        int total_bytes_limit)Sets the maximum number of bytes that this CodedInputStream will read before refusing to continue. To prevent servers from allocating enormous amounts of memory to hold parsed messages, the maximum message length should be limited to the shortest length that will not harm usability. The default limit is INT_MAX (~2GB) and apps should set shorter limits if possible. An error will always be printed to stderr if the limit is reached.\nNote: setting a limit less than the current read position is interpreted as a limit on the current position.\nThis is unrelated to PushLimit()/PopLimit(). bool CodedInputStream::IncrementRecursionDepth()Increments the current recursion depth. Returns true if the depth is under the limit, false if it has gone over. void CodedInputStream::UnsafeDecrementRecursionDepth()Decrements the recursion depth blindly. This is faster than DecrementRecursionDepth(). It should be used only if all previous increments to recursion depth were successful. std::pair\u003c CodedInputStream::Limit, int \u003e     CodedInputStream::IncrementRecursionDepthAndPushLimit(\n        int byte_limit)Shorthand for make_pair(PushLimit(byte_limit), –recursion_budget_). Using this can reduce code size and complexity in some cases. The caller is expected to check that the second part of the result is non-negative (to bail out if the depth of recursion is too high) and, if all is well, to later pass the first part of the result to PopLimit() or similar. bool CodedInputStream::DecrementRecursionDepthAndPopLimit(\n        Limit limit)Helper that is equivalent to: { bool result = ConsumedEntireMessage(); PopLimit(limit); UnsafeDecrementRecursionDepth(); return result; } Using this can reduce code size and complexity in some cases. Do not use unless the current recursion depth is greater than zero. void CodedInputStream::SetExtensionRegistry(\n        const DescriptorPool * pool,\n        MessageFactory * factory)Set the pool used to look up extensions. Most users do not need to call this as the correct pool will be chosen automatically.\nWARNING: It is very easy to misuse this. Carefully read the requirements below. Do not use this unless you are sure you need it. Almost no one does.\nLet's say you are parsing a message into message object m, and you want to take advantage of SetExtensionRegistry(). You must follow these requirements:\nThe given DescriptorPool must contain m-\u003eGetDescriptor(). It is not sufficient for it to simply contain a descriptor that has the same name and content – it must be the exact object. In other words: assert(pool-\u003eFindMessageTypeByName(m-\u003eGetDescriptor()-\u003efull_name()) == m-\u003eGetDescriptor()); There are two ways to satisfy this requirement: 1) Use m-\u003eGetDescriptor()-\u003epool() as the pool. This is generally useless because this is the pool that would be used anyway if you didn't call SetExtensionRegistry() at all. 2) Use a DescriptorPool which has m-\u003eGetDescriptor()-\u003epool() as an \"underlay\". Read the documentation for DescriptorPool for more information about underlays. You must also provide a MessageFactory. This factory will be used to construct Message objects representing extensions. The factory's GetPrototype() MUST return non-NULL for any Descriptor which can be found through the provided pool.\nIf the provided factory might return instances of protocol-compiler- generated (i.e. compiled-in) types, or if the outer message object m is a generated type, then the given factory MUST have this property: If GetPrototype() is given a Descriptor which resides in DescriptorPool::generated_pool(), the factory MUST return the same prototype which MessageFactory::generated_factory() would return. That is, given a descriptor for a generated type, the factory must return an instance of the generated class (NOT DynamicMessage). However, when given a descriptor for a type that is NOT in generated_pool, the factory is free to return any implementation.\nThe reason for this requirement is that generated sub-objects may be accessed via the standard (non-reflection) extension accessor methods, and these methods will down-cast the object to the generated class type. If the object is not actually of that type, the results would be undefined. On the other hand, if an extension is not compiled in, then there is no way the code could end up accessing it via the standard accessors – the only way to access the extension is via reflection. When using reflection, DynamicMessage and generated messages are indistinguishable, so it's fine if these objects are represented using DynamicMessage.\nUsing DynamicMessageFactory on which you have called SetDelegateToGeneratedFactory(true) should be sufficient to satisfy the above requirement.\nIf either pool or factory is NULL, both must be NULL.\nNote that this feature is ignored when parsing \"lite\" messages as they do not have descriptors. class EpsCopyOutputStream#include \u003cgoogle/protobuf/io/coded_stream.h\u003e\nnamespace google::protobuf::io\nEpsCopyOutputStream wraps a ZeroCopyOutputStream and exposes a new stream, which has the property you can write kSlopBytes (16 bytes) from the current position without bounds checks. The cursor into the stream is managed by the user of the class and is an explicit parameter in the methods. Careful use of this class, ie. keep ptr a local variable, eliminates the need to for the compiler to sync the ptr value between register and memory. Membersenum@33 more...EpsCopyOutputStream(ZeroCopyOutputStream * stream, bool deterministic, uint8 ** pp)Initialize from a stream. EpsCopyOutputStream(void * data, int size, bool deterministic)Only for array serialization. more...EpsCopyOutputStream(void * data, int size, ZeroCopyOutputStream * stream, bool deterministic, uint8 ** pp)Initialize from stream but with the first buffer already given (eager). uint8 *Trim(uint8 * ptr)Flush everything that's written into the underlying ZeroCopyOutputStream and trims the underlying stream to the location of ptr. PROTOBUF_MUST_USE_RESULT uint8 *EnsureSpace(uint8 * ptr)After this it's guaranteed you can safely write kSlopBytes to ptr. more...uint8 *WriteRaw(const void * data, int size, uint8 * ptr)uint8 *WriteRawMaybeAliased(const void * data, int size, uint8 * ptr)Writes the buffer specified by data, size to the stream. more...uint8 *WriteStringMaybeAliased(uint32 num, const std::string \u0026 s, uint8 * ptr)uint8 *WriteBytesMaybeAliased(uint32 num, const std::string \u0026 s, uint8 * ptr)template uint8 *WriteString(uint32 num, const T \u0026 s, uint8 * ptr)template uint8 *WriteBytes(uint32 num, const T \u0026 s, uint8 * ptr)template uint8 *WriteInt32Packed(int num, const T \u0026 r, int size, uint8 * ptr)template uint8 *WriteUInt32Packed(int num, const T \u0026 r, int size, uint8 * ptr)template uint8 *WriteSInt32Packed(int num, const T \u0026 r, int size, uint8 * ptr)template uint8 *WriteInt64Packed(int num, const T \u0026 r, int size, uint8 * ptr)template uint8 *WriteUInt64Packed(int num, const T \u0026 r, int size, uint8 * ptr)template uint8 *WriteSInt64Packed(int num, const T \u0026 r, int size, uint8 * ptr)template uint8 *WriteEnumPacked(int num, const T \u0026 r, int size, uint8 * ptr)template uint8 *WriteFixedPacked(int num, const T \u0026 r, uint8 * ptr)boolHadError() constReturns true if there was an underlying I/O error since this object was created. voidEnableAliasing(bool enabled)Instructs the EpsCopyOutputStream to allow the underlying ZeroCopyOutputStream to hold pointers to the original structure instead of copying, if it supports it (i.e. more...voidSetSerializationDeterministic(bool value)See documentation on CodedOutputStream::SetSerializationDeterministic. boolIsSerializationDeterministic() constSee documentation on CodedOutputStream::IsSerializationDeterministic. int64ByteCount(uint8 * ptr) constThe number of bytes written to the stream at position ptr, relative to the stream's overall position. uint8 *SetInitialBuffer(void * data, int size)These methods are for CodedOutputStream. more... enum EpsCopyOutputStream::@33 {\n  kSlopBytes = = 16\n}\nkSlopBytes EpsCopyOutputStream::EpsCopyOutputStream(\n        void * data,\n        int size,\n        bool deterministic)Only for array serialization. No overflow protection, end_ will be the pointed to the end of the array. When using this the total size is already known, so no need to maintain the slop region. PROTOBUF_MUST_USE_RESULT uint8 *     EpsCopyOutputStream::EnsureSpace(\n        uint8 * ptr)After this it's guaranteed you can safely write kSlopBytes to ptr. This will never fail! The underlying stream can produce an error. Use HadError to check for errors. uint8 * EpsCopyOutputStream::WriteRawMaybeAliased(\n        const void * data,\n        int size,\n        uint8 * ptr)Writes the buffer specified by data, size to the stream. Possibly by aliasing the buffer (ie. not copying the data). The caller is responsible to make sure the buffer is alive for the duration of the ZeroCopyOutputStream. void EpsCopyOutputStream::EnableAliasing(\n        bool enabled)Instructs the EpsCopyOutputStream to allow the underlying ZeroCopyOutputStream to hold pointers to the original structure instead of copying, if it supports it (i.e. output-\u003eAllowsAliasing() is true). If the underlying stream does not support aliasing, then enabling it has no affect. For now, this only affects the behavior of WriteRawMaybeAliased().\nNOTE: It is caller's responsibility to ensure that the chunk of memory remains live until all of the data has been consumed from the stream. uint8 * EpsCopyOutputStream::SetInitialBuffer(\n        void * data,\n        int size)These methods are for CodedOutputStream. Ideally they should be private but to match current behavior of CodedOutputStream as close as possible we allow it some functionality. class CodedOutputStream#include \u003cgoogle/protobuf/io/coded_stream.h\u003e\nnamespace google::protobuf::io\nClass which encodes and writes binary data which is composed of varint- encoded integers and fixed-width pieces. Wraps a ZeroCopyOutputStream. Most users will not need to deal with CodedOutputStream.\nMost methods of CodedOutputStream which return a bool return false if an underlying I/O error occurs. Once such a failure occurs, the CodedOutputStream is broken and is no longer useful. The Write* methods do not return the stream status, but will invalidate the stream if an error occurs. The client can probe HadError() to determine the status.\nNote that every method of CodedOutputStream which writes some data has a corresponding static \"ToArray\" version. These versions write directly to the provided buffer, returning a pointer past the last written byte. They require that the buffer has sufficient capacity for the encoded data. This allows an optimization where we check if an output stream has enough space for an entire message before we start writing and, if there is, we call only the ToArray methods to avoid doing bound checks for each individual value. i.e., in the example above:\nCodedOutputStream* coded_output = new CodedOutputStream(raw_output); int magic_number = 1234; char text[[]] = \"Hello world!\"; int coded_size = sizeof(magic_number) + CodedOutputStream::VarintSize32(strlen(text)) + strlen(text);\nuint8* buffer = coded_output-\u003eGetDirectBufferForNBytesAndAdvance(coded_size); if (buffer != nullptr) { // The output stream has enough space in the buffer: write directly to // the array. buffer = CodedOutputStream::WriteLittleEndian32ToArray(magic_number, buffer); buffer = CodedOutputStream::WriteVarint32ToArray(strlen(text), buffer); buffer = CodedOutputStream::WriteRawToArray(text, strlen(text), buffer); } else { // Make bound-checked writes, which will ask the underlying stream for // more space as needed. coded_output-\u003eWriteLittleEndian32(magic_number); coded_output-\u003eWriteVarint32(strlen(text)); coded_output-\u003eWriteRaw(text, strlen(text)); }\ndelete coded_output;\nMembersexplicit CodedOutputStream(ZeroCopyOutputStream * stream)Create an CodedOutputStream that writes to the given ZeroCopyOutputStream. CodedOutputStream(ZeroCopyOutputStream * stream, bool do_eager_refresh)~CodedOutputStream()Destroy the CodedOutputStream and position the underlying ZeroCopyOutputStream immediately after the last byte written. boolHadError()Returns true if there was an underlying I/O error since this object was created. more...voidTrim()Trims any unused space in the underlying buffer so that its size matches the number of bytes written by this stream. more...boolSkip(int count)Skips a number of bytes, leaving the bytes unmodified in the underlying buffer. more...boolGetDirectBufferPointer(void ** data, int * size)Sets *data to point directly at the unwritten part of the CodedOutputStream's underlying buffer, and *size to the size of that buffer, but does not advance the stream's current position. more...uint8 *GetDirectBufferForNBytesAndAdvance(int size)If there are at least \"size\" bytes available in the current buffer, returns a pointer directly into the buffer and advances over these bytes. more...voidWriteRaw(const void * buffer, int size)Write raw bytes, copying them from the given buffer. voidWriteRawMaybeAliased(const void * data, int size)Like WriteRaw() but will try to write aliased data if aliasing is turned on. voidWriteString(const std::string \u0026 str)Equivalent to WriteRaw(str.data(), str.size()). voidWriteLittleEndian32(uint32 value)Write a 32-bit little-endian integer. voidWriteLittleEndian64(uint64 value)Write a 64-bit little-endian integer. voidWriteVarint32(uint32 value)Write an unsigned integer with Varint encoding. more...voidWriteVarint64(uint64 value)Write an unsigned integer with Varint encoding. voidWriteVarint32SignExtended(int32 value)Equivalent to WriteVarint32() except when the value is negative, in which case it must be sign-extended to a full 10 bytes. voidWriteTag(uint32 value)This is identical to WriteVarint32(), but optimized for writing tags. more...intByteCount() constReturns the total number of bytes written since this object was created. voidEnableAliasing(bool enabled)Instructs the CodedOutputStream to allow the underlying ZeroCopyOutputStream to hold pointers to the original structure instead of copying, if it supports it (i.e. more...voidSetSerializationDeterministic(bool value)Indicate to the serializer whether the user wants derministic serialization. more...boolIsSerializationDeterministic() constReturn whether the user wants deterministic serialization. See above. template voidSerialize(const Func \u0026 func)uint8 *Cur() constvoidSetCur(uint8 * ptr)EpsCopyOutputStream *EpsCopy()static uint8 *WriteRawToArray(const void * buffer, int size, uint8 * target)Like WriteRaw() but writing directly to the target array. more...static uint8 *WriteStringToArray(const std::string \u0026 str, uint8 * target)Like WriteString() but writing directly to the target array. static uint8 *WriteStringWithSizeToArray(const std::string \u0026 str, uint8 * target)Write the varint-encoded size of str followed by str. static uint8 *WriteLittleEndian32ToArray(uint32 value, uint8 * target)Like WriteLittleEndian32() but writing directly to the target array. static uint8 *WriteLittleEndian64ToArray(uint64 value, uint8 * target)Like WriteLittleEndian64() but writing directly to the target array. static uint8 *WriteVarint32ToArray(uint32 value, uint8 * target)Like WriteVarint32() but writing directly to the target array. static uint8 *WriteVarint32ToArrayOutOfLine(uint32 value, uint8 * target)Like WriteVarint32() but writing directly to the target array, and with the less common-case paths being out of line rather than inlined. static uint8 *WriteVarint64ToArray(uint64 value, uint8 * target)Like WriteVarint64() but writing directly to the target array. static uint8 *WriteVarint32SignExtendedToArray(int32 value, uint8 * target)Like WriteVarint32SignExtended() but writing directly to the target array. static uint8 *WriteTagToArray(uint32 value, uint8 * target)Like WriteTag() but writing directly to the target array. static size_tVarintSize32(uint32 value)Returns the number of bytes needed to encode the given value as a varint. static size_tVarintSize64(uint64 value)Returns the number of bytes needed to encode the given value as a varint. static size_tVarintSize32SignExtended(int32 value)If negative, 10 bytes. Otherwise, same as VarintSize32(). static boolIsDefaultSerializationDeterministic() bool CodedOutputStream::HadError()Returns true if there was an underlying I/O error since this object was created. On should call Trim before this function in order to catch all errors. void CodedOutputStream::Trim()Trims any unused space in the underlying buffer so that its size matches the number of bytes written by this stream. The underlying buffer will automatically be trimmed when this stream is destroyed; this call is only necessary if the underlying buffer is accessed before the stream is destroyed. bool CodedOutputStream::Skip(\n        int count)Skips a number of bytes, leaving the bytes unmodified in the underlying buffer. Returns false if an underlying write error occurs. This is mainly useful with GetDirectBufferPointer(). Note of caution, the skipped bytes may contain uninitialized data. The caller must make sure that the skipped bytes are properly initialized, otherwise you might leak bytes from your heap. bool CodedOutputStream::GetDirectBufferPointer(\n        void ** data,\n        int * size)Sets *data to point directly at the unwritten part of the CodedOutputStream's underlying buffer, and *size to the size of that buffer, but does not advance the stream's current position. This will always either produce a non-empty buffer or return false. If the caller writes any data to this buffer, it should then call Skip() to skip over the consumed bytes. This may be useful for implementing external fast serialization routines for types of data not covered by the CodedOutputStream interface. uint8 * CodedOutputStream::GetDirectBufferForNBytesAndAdvance(\n        int size)If there are at least \"size\" bytes available in the current buffer, returns a pointer directly into the buffer and advances over these bytes. The caller may then write directly into this buffer (e.g. using the *ToArray static methods) rather than go through CodedOutputStream. If there are not enough bytes available, returns NULL. The return pointer is invalidated as soon as any other non-const method of CodedOutputStream is called. void CodedOutputStream::WriteVarint32(\n        uint32 value)Write an unsigned integer with Varint encoding. Writing a 32-bit value is equivalent to casting it to uint64 and writing it as a 64-bit value, but may be more efficient. void CodedOutputStream::WriteTag(\n        uint32 value)This is identical to WriteVarint32(), but optimized for writing tags. In particular, if the input is a compile-time constant, this method compiles down to a couple instructions. Always inline because otherwise the aforementioned optimization can't work, but GCC by default doesn't want to inline this. void CodedOutputStream::EnableAliasing(\n        bool enabled)Instructs the CodedOutputStream to allow the underlying ZeroCopyOutputStream to hold pointers to the original structure instead of copying, if it supports it (i.e. output-\u003eAllowsAliasing() is true). If the underlying stream does not support aliasing, then enabling it has no affect. For now, this only affects the behavior of WriteRawMaybeAliased().\nNOTE: It is caller's responsibility to ensure that the chunk of memory remains live until all of the data has been consumed from the stream. void CodedOutputStream::SetSerializationDeterministic(\n        bool value)Indicate to the serializer whether the user wants derministic serialization. The default when this is not called comes from the global default, controlled by SetDefaultSerializationDeterministic.\nWhat deterministic serialization means is entirely up to the driver of the serialization process (i.e. the caller of methods like WriteVarint32). In the case of serializing a proto buffer message using one of the methods of MessageLite, this means that for a given binary equal messages will always be serialized to the same bytes. This implies:\nRepeated serialization of a message will return the same bytes. Different processes running the same binary (including on different machines) will serialize equal messages to the same bytes.\nNote that this is not canonical across languages. It is also unstable across different builds with intervening message definition changes, due to unknown fields. Users who need canonical serialization (e.g. persistent storage in a canonical form, fingerprinting) should define their own canonicalization specification and implement the serializer using reflection APIs rather than relying on this API. static uint8 * CodedOutputStream::WriteRawToArray(\n        const void * buffer,\n        int size,\n        uint8 * target)Like WriteRaw() but writing directly to the target array. This is not inlined, as the compiler often optimizes memcpy into inline copy loops. Since this gets called by every field with string or bytes type, inlining may lead to a significant amount of code bloat, with only a minor performance gain. template struct CodedOutputStream::StaticVarintSize32#include \u003cgoogle/protobuf/io/coded_stream.h\u003e\nnamespace google::protobuf::io\ntemplate \u003ctypename Value\u003e\nCompile-time equivalent of VarintSize32(). Membersconst size_tvalue = = (Value \u003c (1 \u003c\u003c 7)) ? 1 : (Value \u003c (1 \u003c\u003c 14)) ? 2 : (Value \u003c (1 \u003c\u003c 21)) ? 3 : (Value \u003c (1 \u003c\u003c 28)) ? 4 : 5","categories":"","description":"","excerpt":"coded_stream.hcoded_stream.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.io.coded_stream/","tags":"","title":""},{"body":"gzip_stream.hgzip_stream.h#include \u003cgoogle/protobuf/io/gzip_stream.h\u003e\nnamespace google::protobuf::io\nThis file contains the definition for classes GzipInputStream and GzipOutputStream. GzipInputStream decompresses data from an underlying ZeroCopyInputStream and provides the decompressed data as a ZeroCopyInputStream.\nGzipOutputStream is an ZeroCopyOutputStream that compresses data to an underlying ZeroCopyOutputStream. Classes in this fileGzipInputStreamA ZeroCopyInputStream that reads compressed data through zlib. GzipOutputStreamGzipOutputStream::Optionsclass GzipInputStream: public ZeroCopyInputStream#include \u003cgoogle/protobuf/io/gzip_stream.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyInputStream that reads compressed data through zlib. MembersenumFormatFormat key for constructor. more...explicit GzipInputStream(ZeroCopyInputStream * sub_stream, Format format = AUTO, int buffer_size = -1)buffer_size and format may be -1 for default of 64kB and GZIP format virtual ~GzipInputStream()const char *ZlibErrorMessage() constReturn last error message or NULL if no error. intZlibErrorCode() constimplements ZeroCopyInputStreamvirtual boolNext(const void ** data, int * size)Obtains a chunk of data from the stream. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). more...virtual boolSkip(int count)Skips a number of bytes. more...virtual int64ByteCount() constReturns the total number of bytes read since this object was created. enum GzipInputStream::Format {\n  AUTO = = 0,\n  GZIP = = 1,\n  ZLIB = = 2\n}Format key for constructor. AUTOzlib will autodetect gzip header or deflate stream GZIPGZIP streams have some extra header data for file attributes. ZLIBSimpler zlib stream format. virtual bool GzipInputStream::Next(\n        const void ** data,\n        int * size)Obtains a chunk of data from the stream. Preconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, there is no more data to return or an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes read and \"data\" points to a pointer to a buffer containing these bytes. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void GzipInputStream::BackUp(\n        int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If Next() returns a buffer that goes beyond what you wanted to read, you can use BackUp() to return to the point where you intended to finish.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be pushed back into the stream. Subsequent calls to Next() will return the same data again before producing new data. virtual bool GzipInputStream::Skip(\n        int count)Skips a number of bytes. Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so ByteCount() will return the total size of the stream). class GzipOutputStream: public ZeroCopyOutputStream#include \u003cgoogle/protobuf/io/gzip_stream.h\u003e\nnamespace google::protobuf::io\nMembersenumFormatFormat key for constructor. more...explicit GzipOutputStream(ZeroCopyOutputStream * sub_stream)Create a GzipOutputStream with default options. GzipOutputStream(ZeroCopyOutputStream * sub_stream, const Options \u0026 options)Create a GzipOutputStream with the given options. virtual ~GzipOutputStream()const char *ZlibErrorMessage() constReturn last error message or NULL if no error. intZlibErrorCode() constboolFlush()Flushes data written so far to zipped data in the underlying stream. more...boolClose()Writes out all data and closes the gzip stream. more...implements ZeroCopyOutputStreamvirtual boolNext(void ** data, int * size)Obtains a buffer into which data can be written. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. more...virtual int64ByteCount() constReturns the total number of bytes written since this object was created. enum GzipOutputStream::Format {\n  GZIP = = 1,\n  ZLIB = = 2\n}Format key for constructor. GZIPGZIP streams have some extra header data for file attributes. ZLIBSimpler zlib stream format. bool GzipOutputStream::Flush()Flushes data written so far to zipped data in the underlying stream. It is the caller's responsibility to flush the underlying stream if necessary. Compression may be less efficient stopping and starting around flushes. Returns true if no error.\nPlease ensure that block size is \u003e 6. Here is an excerpt from the zlib doc that explains why:\nIn the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that avail_out is greater than six to avoid repeated flush markers due to avail_out == 0 on return. bool GzipOutputStream::Close()Writes out all data and closes the gzip stream. It is the caller's responsibility to close the underlying stream if necessary. Returns true if no error. virtual bool GzipOutputStream::Next(\n        void ** data,\n        int * size)Obtains a buffer into which data can be written. Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.\nPreconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes in the buffer and \"data\" points to the buffer. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. Any data which the caller stores in this buffer will eventually be written to the output (unless BackUp() is called). It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void GzipOutputStream::BackUp(\n        int count)Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use BackUp() to back up.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). The caller must not have written anything to the last \"count\" bytes of that buffer. Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be ignored. struct GzipOutputStream::Options#include \u003cgoogle/protobuf/io/gzip_stream.h\u003e\nnamespace google::protobuf::io\nMembersFormatformatDefaults to GZIP. intbuffer_sizeWhat size buffer to use internally. Defaults to 64kB. intcompression_levelA number between 0 and 9, where 0 is no compression and 9 is best compression. more...intcompression_strategyDefaults to Z_DEFAULT_STRATEGY. more...Options()Initializes with default values. intOptions::compression_levelA number between 0 and 9, where 0 is no compression and 9 is best compression. Defaults to Z_DEFAULT_COMPRESSION (see zlib.h). intOptions::compression_strategyDefaults to Z_DEFAULT_STRATEGY. Can also be set to Z_FILTERED, Z_HUFFMAN_ONLY, or Z_RLE. See the documentation for deflateInit2 in zlib.h for definitions of these constants. ","categories":"","description":"","excerpt":"gzip_stream.hgzip_stream.h#include \u003cgoogle/protobuf/io/gzip_stream.h\u003e …","ref":"/reference/cpp/api-docs/google.protobuf.io.gzip_stream/","tags":"","title":""},{"body":"printer.hprinter.h#include \u003cgoogle/protobuf/io/printer.h\u003e\nnamespace google::protobuf::io\nUtility class for writing text to a ZeroCopyOutputStream. Classes in this fileAnnotationCollectorRecords annotations about a Printer's output. AnnotationProtoCollectorRecords annotations about a Printer's output to the given protocol buffer, assuming that the buffer has an ::Annotation message exposing path, source_file, begin and end fields. Printerclass AnnotationCollector#include \u003cgoogle/protobuf/io/printer.h\u003e\nnamespace google::protobuf::io\nRecords annotations about a Printer's output. Known subclasses:\nAnnotationProtoCollector\u003c AnnotationProto \u003eMemberstypedefstd::pair\u003c std::pair\u003c size_t, size_t \u003e, std::string \u003e AnnotationAnnotation is a offset range and a payload pair. virtual voidAddAnnotation(size_t begin_offset, size_t end_offset, const std::string \u0026 file_path, const std::vector\u003c int \u003e \u0026 path) = 0Records that the bytes in file_path beginning with begin_offset and ending before end_offset are associated with the SourceCodeInfo-style path. virtual voidAddAnnotationNew(Annotation \u0026 )more...virtual ~AnnotationCollector() virtual void AnnotationCollector::AddAnnotationNew(\n        Annotation \u0026 )\nJust a vector of range, payload pairs stored in a context should suffice. template class AnnotationProtoCollector: public AnnotationCollector#include \u003cgoogle/protobuf/io/printer.h\u003e\nnamespace google::protobuf::io\ntemplate \u003ctypename \u003e\nRecords annotations about a Printer's output to the given protocol buffer, assuming that the buffer has an ::Annotation message exposing path, source_file, begin and end fields. Membersexplicit AnnotationProtoCollector(AnnotationProto * annotation_proto)annotation_proto is the protocol buffer to which new Annotations should be added. more...virtual voidAddAnnotation(size_t begin_offset, size_t end_offset, const std::string \u0026 file_path, const std::vector\u003c int \u003e \u0026 path)Override for AnnotationCollector::AddAnnotation. virtual voidAddAnnotationNew(Annotation \u0026 a)Override for AnnotationCollector::AddAnnotation. explicit AnnotationProtoCollector::AnnotationProtoCollector(\n        AnnotationProto * annotation_proto)annotation_proto is the protocol buffer to which new Annotations should be added. It is not owned by the AnnotationProtoCollector. class Printer#include \u003cgoogle/protobuf/io/printer.h\u003e\nnamespace google::protobuf::io\nMembersPrinter(ZeroCopyOutputStream * output, char variable_delimiter)Create a printer that writes text to the given output stream. more...Printer(ZeroCopyOutputStream * output, char variable_delimiter, AnnotationCollector * annotation_collector)Create a printer that writes text to the given output stream. more...~Printer()template voidAnnotate(const char * varname, const SomeDescriptor * descriptor)Link a substitution variable emitted by the last call to Print to the object described by descriptor. template voidAnnotate(const char * begin_varname, const char * end_varname, const SomeDescriptor * descriptor)Link the output range defined by the substitution variables as emitted by the last call to Print to the object described by descriptor. more...voidAnnotate(const char * varname, const std::string \u0026 file_name)Link a substitution variable emitted by the last call to Print to the file with path file_name. voidAnnotate(const char * begin_varname, const char * end_varname, const std::string \u0026 file_name)Link the output range defined by the substitution variables as emitted by the last call to Print to the file with path file_name. more...voidPrint(const std::map\u003c std::string, std::string \u003e \u0026 variables, const char * text)Print some text after applying variable substitutions. more...template voidPrint(const char * text, const Args \u0026... args)Like the first Print(), except the substitutions are given as parameters. voidIndent()Indent text by two spaces. more...voidOutdent()Reduces the current indent level by two spaces, or crashes if the indent level is zero. voidPrintRaw(const std::string \u0026 data)Write a string to the output buffer. more...voidPrintRaw(const char * data)Write a zero-delimited string to output buffer. more...voidWriteRaw(const char * data, int size)Write some bytes to the output buffer. more...voidFormatInternal(const std::vector\u003c std::string \u003e \u0026 args, const std::map\u003c std::string, std::string \u003e \u0026 vars, const char * format)FormatInternal is a helper function not meant to use directly, use compiler::cpp::Formatter instead. more...boolfailed() constTrue if any write to the underlying stream failed. more... Printer::Printer(\n        ZeroCopyOutputStream * output,\n        char variable_delimiter)Create a printer that writes text to the given output stream. Use the given character as the delimiter for variables. Printer::Printer(\n        ZeroCopyOutputStream * output,\n        char variable_delimiter,\n        AnnotationCollector * annotation_collector)Create a printer that writes text to the given output stream. Use the given character as the delimiter for variables. If annotation_collector is not null, Printer will provide it with annotations about code written to the stream. annotation_collector is not owned by Printer. template void Printer::Annotate(\n        const char * begin_varname,\n        const char * end_varname,\n        const SomeDescriptor * descriptor)Link the output range defined by the substitution variables as emitted by the last call to Print to the object described by descriptor. The range begins at begin_varname's value and ends after the last character of the value substituted for end_varname. void Printer::Annotate(\n        const char * begin_varname,\n        const char * end_varname,\n        const std::string \u0026 file_name)Link the output range defined by the substitution variables as emitted by the last call to Print to the file with path file_name. The range begins at begin_varname's value and ends after the last character of the value substituted for end_varname. void Printer::Print(\n        const std::map\u003c std::string, std::string \u003e \u0026 variables,\n        const char * text)Print some text after applying variable substitutions. If a particular variable in the text is not defined, this will crash. Variables to be substituted are identified by their names surrounded by delimiter characters (as given to the constructor). The variable bindings are defined by the given map. void Printer::Indent()Indent text by two spaces. After calling Indent(), two spaces will be inserted at the beginning of each line of text. Indent() may be called multiple times to produce deeper indents. void Printer::PrintRaw(\n        const std::string \u0026 data)Write a string to the output buffer. This method does not look for newlines to add indentation. void Printer::PrintRaw(\n        const char * data)Write a zero-delimited string to output buffer. This method does not look for newlines to add indentation. void Printer::WriteRaw(\n        const char * data,\n        int size)Write some bytes to the output buffer. This method does not look for newlines to add indentation. void Printer::FormatInternal(\n        const std::vector\u003c std::string \u003e \u0026 args,\n        const std::map\u003c std::string, std::string \u003e \u0026 vars,\n        const char * format)FormatInternal is a helper function not meant to use directly, use compiler::cpp::Formatter instead. This function is meant to support formatting text using named variables (eq. \"$foo$) from a lookup map (vars) and variables directly supplied by arguments (eq \"$1$\" meaning first argument which is the zero index element of args). bool Printer::failed() constTrue if any write to the underlying stream failed. (We don't just crash in this case because this is an I/O failure, not a programming error.) ","categories":"","description":"","excerpt":"printer.hprinter.h#include \u003cgoogle/protobuf/io/printer.h\u003e\nnamespace …","ref":"/reference/cpp/api-docs/google.protobuf.io.printer/","tags":"","title":""},{"body":"tokenizer.htokenizer.h#include \u003cgoogle/protobuf/io/tokenizer.h\u003e\nnamespace google::protobuf::io\nClass for parsing tokenized text from a ZeroCopyInputStream. Classes in this fileErrorCollectorAbstract interface for an object which collects the errors that occur during parsing. TokenizerThis class converts a stream of raw text into a stream of tokens for the protocol definition parser to parse. Tokenizer::TokenStructure representing a token read from the token stream. File MembersThese definitions are not part of any class.typedefint ColumnNumberBy \"column number\", the proto compiler refers to a count of the number of bytes before a given byte, except that a tab character advances to the next multiple of 8 bytes. more... typedef io::ColumnNumberBy \"column number\", the proto compiler refers to a count of the number of bytes before a given byte, except that a tab character advances to the next multiple of 8 bytes. Note in particular that column numbers are zero-based, while many user interfaces use one-based column numbers. class ErrorCollector#include \u003cgoogle/protobuf/io/tokenizer.h\u003e\nnamespace google::protobuf::io\nAbstract interface for an object which collects the errors that occur during parsing. A typical implementation might simply print the errors to stdout. MembersErrorCollector()virtual ~ErrorCollector()virtual voidAddError(int line, ColumnNumber column, const std::string \u0026 message) = 0Indicates that there was an error in the input at the given line and column numbers. more...virtual voidAddWarning(int , ColumnNumber , const std::string \u0026 )Indicates that there was a warning in the input at the given line and column numbers. more... virtual void ErrorCollector::AddError(\n        int line,\n        ColumnNumber column,\n        const std::string \u0026 message) = 0Indicates that there was an error in the input at the given line and column numbers. The numbers are zero-based, so you may want to add 1 to each before printing them. virtual void ErrorCollector::AddWarning(\n        int ,\n        ColumnNumber ,\n        const std::string \u0026 )Indicates that there was a warning in the input at the given line and column numbers. The numbers are zero-based, so you may want to add 1 to each before printing them. class Tokenizer#include \u003cgoogle/protobuf/io/tokenizer.h\u003e\nnamespace google::protobuf::io\nThis class converts a stream of raw text into a stream of tokens for the protocol definition parser to parse. The tokens recognized are similar to those that make up the C language; see the TokenType enum for precise descriptions. Whitespace and comments are skipped. By default, C- and C++-style comments are recognized, but other styles can be used by calling set_comment_style(). MembersenumTokenType more...Tokenizer(ZeroCopyInputStream * input, ErrorCollector * error_collector)Construct a Tokenizer that reads and tokenizes text from the given input stream and writes errors to the given error_collector. more...~Tokenizer()const Token \u0026current()Get the current token. more...const Token \u0026previous()Return the previous token – i.e. more...boolNext()Advance to the next token. more...boolNextWithComments(std::string * prev_trailing_comments, std::vector\u003c std::string \u003e * detached_comments, std::string * next_leading_comments)Like Next(), but also collects comments which appear between the previous and next tokens. more...OptionsenumCommentStyleValid values for set_comment_style(). more...voidset_allow_f_after_float(bool value)Set true to allow floats to be suffixed with the letter 'f'. more...voidset_comment_style(CommentStyle style)Sets the comment style. voidset_require_space_after_number(bool require)Whether to require whitespace between a number and a field name. more...voidset_allow_multiline_strings(bool allow)Whether to allow string literals to span multiple lines. more...static boolIsIdentifier(const std::string \u0026 text)External helper: validate an identifier. Parse helpersstatic doubleParseFloat(const std::string \u0026 text)Parses a TYPE_FLOAT token. more...static voidParseString(const std::string \u0026 text, std::string * output)Parses a TYPE_STRING token. more...static voidParseStringAppend(const std::string \u0026 text, std::string * output)Identical to ParseString, but appends to output. static boolParseInteger(const std::string \u0026 text, uint64 max_value, uint64 * output)Parses a TYPE_INTEGER token. more... enum Tokenizer::TokenType {\n  TYPE_START,\n  TYPE_END,\n  TYPE_IDENTIFIER,\n  TYPE_INTEGER,\n  TYPE_FLOAT,\n  TYPE_STRING,\n  TYPE_SYMBOL\n}\nTYPE_STARTNext() has not yet been called. TYPE_ENDEnd of input reached. \"text\" is empty. TYPE_IDENTIFIERA sequence of letters, digits, and underscores, not starting with a digit. It is an error for a number to be followed by an identifier with no space in between. TYPE_INTEGERA sequence of digits representing an integer. Normally the digits are decimal, but a prefix of \"0x\" indicates a hex number and a leading zero indicates octal, just like with C numeric literals. A leading negative sign is NOT included in the token; it's up to the parser to interpret the unary minus operator on its own. TYPE_FLOATA floating point literal, with a fractional part and/or an exponent. Always in decimal. Again, never negative. TYPE_STRINGA quoted sequence of escaped characters. Either single or double quotes can be used, but they must match. A string literal cannot cross a line break. TYPE_SYMBOLAny other printable character, like '!' or '+'. Symbols are always a single character, so \"!+$%\" is four tokens. Tokenizer::Tokenizer(\n        ZeroCopyInputStream * input,\n        ErrorCollector * error_collector)Construct a Tokenizer that reads and tokenizes text from the given input stream and writes errors to the given error_collector. The caller keeps ownership of input and error_collector. const Token \u0026 Tokenizer::current()Get the current token. This is updated when Next() is called. Before the first call to Next(), current() has type TYPE_START and no contents. const Token \u0026 Tokenizer::previous()Return the previous token – i.e. what current() returned before the previous call to Next(). bool Tokenizer::Next()Advance to the next token. Returns false if the end of the input is reached. bool Tokenizer::NextWithComments(\n        std::string * prev_trailing_comments,\n        std::vector\u003c std::string \u003e * detached_comments,\n        std::string * next_leading_comments)Like Next(), but also collects comments which appear between the previous and next tokens. Comments which appear to be attached to the previous token are stored in *prev_tailing_comments. Comments which appear to be attached to the next token are stored in *next_leading_comments. Comments appearing in between which do not appear to be attached to either will be added to detached_comments. Any of these parameters can be NULL to simply discard the comments.\nA series of line comments appearing on consecutive lines, with no other tokens appearing on those lines, will be treated as a single comment.\nOnly the comment content is returned; comment markers (e.g. //) are stripped out. For block comments, leading whitespace and an asterisk will be stripped from the beginning of each line other than the first. Newlines are included in the output.\nExamples:\noptional int32 foo = 1; // Comment attached to foo. // Comment attached to bar. optional int32 bar = 2; optional string baz = 3; // Comment attached to baz. // Another line attached to baz.\n// Comment attached to qux. // // Another line attached to qux. optional double qux = 4;\n// Detached comment. This is not attached to qux or corge // because there are blank lines separating it from both.\noptional string corge = 5; /* Block comment attached\nto corge. Leading asterisks will be removed. * / /* Block comment attached to grault. * / optional int32 grault = 6; enum Tokenizer::CommentStyle {\n  CPP_COMMENT_STYLE,\n  SH_COMMENT_STYLE\n}Valid values for set_comment_style(). CPP_COMMENT_STYLELine comments begin with \"//\", block comments are delimited by \"/*\" and \"* /\". SH_COMMENT_STYLELine comments begin with \"#\". No way to write block comments. void Tokenizer::set_allow_f_after_float(\n        bool value)Set true to allow floats to be suffixed with the letter 'f'. Tokens which would otherwise be integers but which have the 'f' suffix will be forced to be interpreted as floats. For all other purposes, the 'f' is ignored. void Tokenizer::set_require_space_after_number(\n        bool require)Whether to require whitespace between a number and a field name. Default is true. Do not use this; for Google-internal cleanup only. void Tokenizer::set_allow_multiline_strings(\n        bool allow)Whether to allow string literals to span multiple lines. Default is false. Do not use this; for Google-internal cleanup only. static double Tokenizer::ParseFloat(\n        const std::string \u0026 text)Parses a TYPE_FLOAT token. This never fails, so long as the text actually comes from a TYPE_FLOAT token parsed by Tokenizer. If it doesn't, the result is undefined (possibly an assert failure). static void Tokenizer::ParseString(\n        const std::string \u0026 text,\n        std::string * output)Parses a TYPE_STRING token. This never fails, so long as the text actually comes from a TYPE_STRING token parsed by Tokenizer. If it doesn't, the result is undefined (possibly an assert failure). static bool Tokenizer::ParseInteger(\n        const std::string \u0026 text,\n        uint64 max_value,\n        uint64 * output)Parses a TYPE_INTEGER token. Returns false if the result would be greater than max_value. Otherwise, returns true and sets *output to the result. If the text is not from a Token of type TYPE_INTEGER originally parsed by a Tokenizer, the result is undefined (possibly an assert failure). struct Tokenizer::Token#include \u003cgoogle/protobuf/io/tokenizer.h\u003e\nnamespace google::protobuf::io\nStructure representing a token read from the token stream. MembersTokenTypetypestd::stringtextThe exact text of the token as it appeared in the input. more...intline\"line\" and \"column\" specify the position of the first character of the token within the input stream. more...ColumnNumbercolumnColumnNumberend_column std::string Token::textThe exact text of the token as it appeared in the input. e.g. tokens of TYPE_STRING will still be escaped and in quotes. int Token::line\"line\" and \"column\" specify the position of the first character of the token within the input stream. They are zero-based. ","categories":"","description":"","excerpt":"tokenizer.htokenizer.h#include \u003cgoogle/protobuf/io/tokenizer.h\u003e …","ref":"/reference/cpp/api-docs/google.protobuf.io.tokenizer/","tags":"","title":""},{"body":"zero_copy_stream.hzero_copy_stream.h#include \u003cgoogle/protobuf/io/zero_copy_stream.h\u003e\nnamespace google::protobuf::io\nThis file contains the ZeroCopyInputStream and ZeroCopyOutputStream interfaces, which represent abstract I/O streams to and from which protocol buffers can be read and written. For a few simple implementations of these interfaces, see zero_copy_stream_impl.h.\nThese interfaces are different from classic I/O streams in that they try to minimize the amount of data copying that needs to be done. To accomplish this, responsibility for allocating buffers is moved to the stream object, rather than being the responsibility of the caller. So, the stream can return a buffer which actually points directly into the final data structure where the bytes are to be stored, and the caller can interact directly with that buffer, eliminating an intermediate copy operation.\nAs an example, consider the common case in which you are reading bytes from an array that is already in memory (or perhaps an mmap()ed file). With classic I/O streams, you would do something like: char buffer[[]BUFFER_SIZE]; input-\u003eRead(buffer, BUFFER_SIZE); DoSomething(buffer, BUFFER_SIZE); Then, the stream basically just calls memcpy() to copy the data from the array into your buffer. With a ZeroCopyInputStream, you would do this instead: const void* buffer; int size; input-\u003eNext(\u0026buffer, \u0026size); DoSomething(buffer, size); Here, no copy is performed. The input stream returns a pointer directly into the backing array, and the caller ends up reading directly from it.\nIf you want to be able to read the old-fashion way, you can create a CodedInputStream or CodedOutputStream wrapping these objects and use their ReadRaw()/WriteRaw() methods. These will, of course, add a copy step, but Coded*Stream will handle buffering so at least it will be reasonably efficient.\nZeroCopyInputStream example: // Read in a file and print its contents to stdout. int fd = open(\"myfile\", O_RDONLY); ZeroCopyInputStream* input = new FileInputStream(fd); const void* buffer; int size; while (input-\u003eNext(\u0026buffer, \u0026size)) { cout.write(buffer, size); }\ndelete input; close(fd);\nZeroCopyOutputStream example: // Copy the contents of \"infile\" to \"outfile\", using plain read() for // \"infile\" but a ZeroCopyOutputStream for \"outfile\". int infd = open(\"infile\", O_RDONLY); int outfd = open(\"outfile\", O_WRONLY); ZeroCopyOutputStream* output = new FileOutputStream(outfd); void* buffer; int size; while (output-\u003eNext(\u0026buffer, \u0026size)) { int bytes = read(infd, buffer, size); if (bytes \u003c size) { // Reached EOF. output-\u003eBackUp(size - bytes); break; } }\ndelete output; close(infd); close(outfd);\nClasses in this fileZeroCopyInputStreamAbstract interface similar to an input stream but designed to minimize copying. ZeroCopyOutputStreamAbstract interface similar to an output stream but designed to minimize copying. class ZeroCopyInputStream#include \u003cgoogle/protobuf/io/zero_copy_stream.h\u003e\nnamespace google::protobuf::io\nAbstract interface similar to an input stream but designed to minimize copying. Known subclasses:\nArrayInputStreamConcatenatingInputStreamCopyingInputStreamAdaptorFileInputStreamIstreamInputStreamLimitingInputStreamMembersZeroCopyInputStream()virtual ~ZeroCopyInputStream()virtual boolNext(const void ** data, int * size) = 0Obtains a chunk of data from the stream. more...virtual voidBackUp(int count) = 0Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). more...virtual boolSkip(int count) = 0Skips a number of bytes. more...virtual int64_tByteCount() const = 0Returns the total number of bytes read since this object was created. virtual bool ZeroCopyInputStream::Next(\n        const void ** data,\n        int * size) = 0Obtains a chunk of data from the stream. Preconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, there is no more data to return or an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes read and \"data\" points to a pointer to a buffer containing these bytes. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void ZeroCopyInputStream::BackUp(\n        int count) = 0Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If Next() returns a buffer that goes beyond what you wanted to read, you can use BackUp() to return to the point where you intended to finish.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be pushed back into the stream. Subsequent calls to Next() will return the same data again before producing new data. virtual bool ZeroCopyInputStream::Skip(\n        int count) = 0Skips a number of bytes. Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so ByteCount() will return the total size of the stream). class ZeroCopyOutputStream#include \u003cgoogle/protobuf/io/zero_copy_stream.h\u003e\nnamespace google::protobuf::io\nAbstract interface similar to an output stream but designed to minimize copying. Known subclasses:\nArrayOutputStreamCopyingOutputStreamAdaptorOstreamOutputStreamStringOutputStreamMembersZeroCopyOutputStream()virtual ~ZeroCopyOutputStream()virtual boolNext(void ** data, int * size) = 0Obtains a buffer into which data can be written. more...virtual voidBackUp(int count) = 0Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. more...virtual int64_tByteCount() const = 0Returns the total number of bytes written since this object was created. virtual boolWriteAliasedRaw(const void * data, int size)Write a given chunk of data to the output. more...virtual boolAllowsAliasing() const virtual bool ZeroCopyOutputStream::Next(\n        void ** data,\n        int * size) = 0Obtains a buffer into which data can be written. Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.\nPreconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes in the buffer and \"data\" points to the buffer. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. Any data which the caller stores in this buffer will eventually be written to the output (unless BackUp() is called). It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void ZeroCopyOutputStream::BackUp(\n        int count) = 0Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use BackUp() to back up.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). The caller must not have written anything to the last \"count\" bytes of that buffer. Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be ignored. virtual bool ZeroCopyOutputStream::WriteAliasedRaw(\n        const void * data,\n        int size)Write a given chunk of data to the output. Some output streams may implement this in a way that avoids copying. Check AllowsAliasing() before calling WriteAliasedRaw(). It will GOOGLE_CHECK fail if WriteAliasedRaw() is called on a stream that does not allow aliasing.\nNOTE: It is caller's responsibility to ensure that the chunk of memory remains live until all of the data has been consumed from the stream. ","categories":"","description":"","excerpt":"zero_copy_stream.hzero_copy_stream.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream/","tags":"","title":""},{"body":"zero_copy_stream_impl.hzero_copy_stream_impl.h#include \u003cgoogle/protobuf/io/zero_copy_stream_impl.h\u003e\nnamespace google::protobuf::io\nThis file contains common implementations of the interfaces defined in zero_copy_stream.h which are only included in the full (non-lite) protobuf library. These implementations include Unix file descriptors and C++ iostreams. See also: zero_copy_stream_impl_lite.h Classes in this fileFileInputStreamA ZeroCopyInputStream which reads from a file descriptor. FileOutputStreamA ZeroCopyOutputStream which writes to a file descriptor. IstreamInputStreamA ZeroCopyInputStream which reads from a C++ istream. OstreamOutputStreamA ZeroCopyOutputStream which writes to a C++ ostream. ConcatenatingInputStreamA ZeroCopyInputStream which reads from several other streams in sequence. class FileInputStream: public ZeroCopyInputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyInputStream which reads from a file descriptor. FileInputStream is preferred over using an ifstream with IstreamInputStream. The latter will introduce an extra layer of buffering, harming performance. Also, it's conceivable that FileInputStream could someday be enhanced to use zero-copy file descriptors on OSs which support them. Membersexplicit FileInputStream(int file_descriptor, int block_size = -1)Creates a stream that reads from the given Unix file descriptor. more...boolClose()Flushes any buffers and closes the underlying file. more...voidSetCloseOnDelete(bool value)By default, the file descriptor is not closed when the stream is destroyed. more...intGetErrno() constIf an I/O error has occurred on this file descriptor, this is the errno from that error. more...implements ZeroCopyInputStreamvirtual boolNext(const void ** data, int * size)Obtains a chunk of data from the stream. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). more...virtual boolSkip(int count)Skips a number of bytes. more...virtual int64_tByteCount() constReturns the total number of bytes read since this object was created. explicit FileInputStream::FileInputStream(\n        int file_descriptor,\n        int block_size = -1)Creates a stream that reads from the given Unix file descriptor. If a block_size is given, it specifies the number of bytes that should be read and returned with each call to Next(). Otherwise, a reasonable default is used. bool FileInputStream::Close()Flushes any buffers and closes the underlying file. Returns false if an error occurs during the process; use GetErrno() to examine the error. Even if an error occurs, the file descriptor is closed when this returns. void FileInputStream::SetCloseOnDelete(\n        bool value)By default, the file descriptor is not closed when the stream is destroyed. Call SetCloseOnDelete(true) to change that. WARNING: This leaves no way for the caller to detect if close() fails. If detecting close() errors is important to you, you should arrange to close the descriptor yourself. int FileInputStream::GetErrno() constIf an I/O error has occurred on this file descriptor, this is the errno from that error. Otherwise, this is zero. Once an error occurs, the stream is broken and all subsequent operations will fail. virtual bool FileInputStream::Next(\n        const void ** data,\n        int * size)Obtains a chunk of data from the stream. Preconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, there is no more data to return or an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes read and \"data\" points to a pointer to a buffer containing these bytes. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void FileInputStream::BackUp(\n        int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If Next() returns a buffer that goes beyond what you wanted to read, you can use BackUp() to return to the point where you intended to finish.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be pushed back into the stream. Subsequent calls to Next() will return the same data again before producing new data. virtual bool FileInputStream::Skip(\n        int count)Skips a number of bytes. Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so ByteCount() will return the total size of the stream). class FileOutputStream: public CopyingOutputStreamAdaptor#include \u003cgoogle/protobuf/io/zero_copy_stream_impl.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyOutputStream which writes to a file descriptor. FileOutputStream is preferred over using an ofstream with OstreamOutputStream. The latter will introduce an extra layer of buffering, harming performance. Also, it's conceivable that FileOutputStream could someday be enhanced to use zero-copy file descriptors on OSs which support them. Membersexplicit FileOutputStream(int file_descriptor, int block_size = -1)Creates a stream that writes to the given Unix file descriptor. more...~FileOutputStream()boolClose()Flushes any buffers and closes the underlying file. more...voidSetCloseOnDelete(bool value)By default, the file descriptor is not closed when the stream is destroyed. more...intGetErrno() constIf an I/O error has occurred on this file descriptor, this is the errno from that error. more... explicit FileOutputStream::FileOutputStream(\n        int file_descriptor,\n        int block_size = -1)Creates a stream that writes to the given Unix file descriptor. If a block_size is given, it specifies the size of the buffers that should be returned by Next(). Otherwise, a reasonable default is used. bool FileOutputStream::Close()Flushes any buffers and closes the underlying file. Returns false if an error occurs during the process; use GetErrno() to examine the error. Even if an error occurs, the file descriptor is closed when this returns. void FileOutputStream::SetCloseOnDelete(\n        bool value)By default, the file descriptor is not closed when the stream is destroyed. Call SetCloseOnDelete(true) to change that. WARNING: This leaves no way for the caller to detect if close() fails. If detecting close() errors is important to you, you should arrange to close the descriptor yourself. int FileOutputStream::GetErrno() constIf an I/O error has occurred on this file descriptor, this is the errno from that error. Otherwise, this is zero. Once an error occurs, the stream is broken and all subsequent operations will fail. class IstreamInputStream: public ZeroCopyInputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyInputStream which reads from a C++ istream. Note that for reading files (or anything represented by a file descriptor), FileInputStream is more efficient. Membersexplicit IstreamInputStream(std::istream * stream, int block_size = -1)Creates a stream that reads from the given C++ istream. more...implements ZeroCopyInputStreamvirtual boolNext(const void ** data, int * size)Obtains a chunk of data from the stream. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). more...virtual boolSkip(int count)Skips a number of bytes. more...virtual int64_tByteCount() constReturns the total number of bytes read since this object was created. explicit IstreamInputStream::IstreamInputStream(\n        std::istream * stream,\n        int block_size = -1)Creates a stream that reads from the given C++ istream. If a block_size is given, it specifies the number of bytes that should be read and returned with each call to Next(). Otherwise, a reasonable default is used. virtual bool IstreamInputStream::Next(\n        const void ** data,\n        int * size)Obtains a chunk of data from the stream. Preconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, there is no more data to return or an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes read and \"data\" points to a pointer to a buffer containing these bytes. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void IstreamInputStream::BackUp(\n        int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If Next() returns a buffer that goes beyond what you wanted to read, you can use BackUp() to return to the point where you intended to finish.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be pushed back into the stream. Subsequent calls to Next() will return the same data again before producing new data. virtual bool IstreamInputStream::Skip(\n        int count)Skips a number of bytes. Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so ByteCount() will return the total size of the stream). class OstreamOutputStream: public ZeroCopyOutputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyOutputStream which writes to a C++ ostream. Note that for writing files (or anything represented by a file descriptor), FileOutputStream is more efficient. Membersexplicit OstreamOutputStream(std::ostream * stream, int block_size = -1)Creates a stream that writes to the given C++ ostream. more...~OstreamOutputStream()implements ZeroCopyOutputStreamvirtual boolNext(void ** data, int * size)Obtains a buffer into which data can be written. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. more...virtual int64_tByteCount() constReturns the total number of bytes written since this object was created. explicit OstreamOutputStream::OstreamOutputStream(\n        std::ostream * stream,\n        int block_size = -1)Creates a stream that writes to the given C++ ostream. If a block_size is given, it specifies the size of the buffers that should be returned by Next(). Otherwise, a reasonable default is used. virtual bool OstreamOutputStream::Next(\n        void ** data,\n        int * size)Obtains a buffer into which data can be written. Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.\nPreconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes in the buffer and \"data\" points to the buffer. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. Any data which the caller stores in this buffer will eventually be written to the output (unless BackUp() is called). It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void OstreamOutputStream::BackUp(\n        int count)Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use BackUp() to back up.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). The caller must not have written anything to the last \"count\" bytes of that buffer. Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be ignored. class ConcatenatingInputStream: public ZeroCopyInputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyInputStream which reads from several other streams in sequence. ConcatenatingInputStream is unable to distinguish between end-of-stream and read errors in the underlying streams, so it assumes any errors mean end-of-stream. So, if the underlying streams fail for any other reason, ConcatenatingInputStream may do odd things. It is suggested that you do not use ConcatenatingInputStream on streams that might produce read errors other than end-of-stream. MembersConcatenatingInputStream(ZeroCopyInputStream *const streams, int count)All streams passed in as well as the array itself must remain valid until the ConcatenatingInputStream is destroyed. ~ConcatenatingInputStream()implements ZeroCopyInputStreamvirtual boolNext(const void ** data, int * size)Obtains a chunk of data from the stream. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). more...virtual boolSkip(int count)Skips a number of bytes. more...virtual int64_tByteCount() constReturns the total number of bytes read since this object was created. virtual bool ConcatenatingInputStream::Next(\n        const void ** data,\n        int * size)Obtains a chunk of data from the stream. Preconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, there is no more data to return or an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes read and \"data\" points to a pointer to a buffer containing these bytes. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void ConcatenatingInputStream::BackUp(\n        int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If Next() returns a buffer that goes beyond what you wanted to read, you can use BackUp() to return to the point where you intended to finish.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be pushed back into the stream. Subsequent calls to Next() will return the same data again before producing new data. virtual bool ConcatenatingInputStream::Skip(\n        int count)Skips a number of bytes. Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so ByteCount() will return the total size of the stream). ","categories":"","description":"","excerpt":"zero_copy_stream_impl.hzero_copy_stream_impl.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl/","tags":"","title":""},{"body":"zero_copy_stream_impl_lite.hzero_copy_stream_impl_lite.h#include \u003cgoogle/protobuf/io/zero_copy_stream_impl_lite.h\u003e\nnamespace google::protobuf::io\nThis file contains common implementations of the interfaces defined in zero_copy_stream.h which are included in the \"lite\" protobuf library. These implementations cover I/O on raw arrays and strings, as well as adaptors which make it easy to implement streams based on traditional streams. Of course, many users will probably want to write their own implementations of these interfaces specific to the particular I/O abstractions they prefer to use, but these should cover the most common cases. Classes in this fileArrayInputStreamA ZeroCopyInputStream backed by an in-memory array of bytes. ArrayOutputStreamA ZeroCopyOutputStream backed by an in-memory array of bytes. StringOutputStreamA ZeroCopyOutputStream which appends bytes to a string. CopyingInputStreamA generic traditional input stream interface. CopyingInputStreamAdaptorA ZeroCopyInputStream which reads from a CopyingInputStream. CopyingOutputStreamA generic traditional output stream interface. CopyingOutputStreamAdaptorA ZeroCopyOutputStream which writes to a CopyingOutputStream. LimitingInputStreamA ZeroCopyInputStream which wraps some other stream and limits it to a particular byte count. File MembersThese definitions are not part of any class.char *mutable_string_data(std::string * s)Return a pointer to mutable characters underlying the given string. more...std::pair\u003c char *, bool \u003eas_string_data(std::string * s)as_string_data(s) is equivalent to ({ char* p = mutable_string_data(s); make_pair(p, p != NULL); }) Sometimes it's faster: in some scenarios p cannot be NULL, and then the code can avoid that check. char * io::mutable_string_data(\n        std::string * s)Return a pointer to mutable characters underlying the given string. The return value is valid until the next time the string is resized. We trust the caller to treat the return value as an array of length s-\u003esize(). class ArrayInputStream: public ZeroCopyInputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl_lite.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyInputStream backed by an in-memory array of bytes. MembersArrayInputStream(const void * data, int size, int block_size = -1)Create an InputStream that returns the bytes pointed to by \"data\". more...~ArrayInputStream()implements ZeroCopyInputStreamvirtual boolNext(const void ** data, int * size)Obtains a chunk of data from the stream. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). more...virtual boolSkip(int count)Skips a number of bytes. more...virtual int64_tByteCount() constReturns the total number of bytes read since this object was created. ArrayInputStream::ArrayInputStream(\n        const void * data,\n        int size,\n        int block_size = -1)Create an InputStream that returns the bytes pointed to by \"data\". \"data\" remains the property of the caller but must remain valid until the stream is destroyed. If a block_size is given, calls to Next() will return data blocks no larger than the given size. Otherwise, the first call to Next() returns the entire array. block_size is mainly useful for testing; in production you would probably never want to set it. virtual bool ArrayInputStream::Next(\n        const void ** data,\n        int * size)Obtains a chunk of data from the stream. Preconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, there is no more data to return or an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes read and \"data\" points to a pointer to a buffer containing these bytes. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void ArrayInputStream::BackUp(\n        int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If Next() returns a buffer that goes beyond what you wanted to read, you can use BackUp() to return to the point where you intended to finish.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be pushed back into the stream. Subsequent calls to Next() will return the same data again before producing new data. virtual bool ArrayInputStream::Skip(\n        int count)Skips a number of bytes. Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so ByteCount() will return the total size of the stream). class ArrayOutputStream: public ZeroCopyOutputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl_lite.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyOutputStream backed by an in-memory array of bytes. MembersArrayOutputStream(void * data, int size, int block_size = -1)Create an OutputStream that writes to the bytes pointed to by \"data\". more...~ArrayOutputStream()implements ZeroCopyOutputStreamvirtual boolNext(void ** data, int * size)Obtains a buffer into which data can be written. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. more...virtual int64_tByteCount() constReturns the total number of bytes written since this object was created. ArrayOutputStream::ArrayOutputStream(\n        void * data,\n        int size,\n        int block_size = -1)Create an OutputStream that writes to the bytes pointed to by \"data\". \"data\" remains the property of the caller but must remain valid until the stream is destroyed. If a block_size is given, calls to Next() will return data blocks no larger than the given size. Otherwise, the first call to Next() returns the entire array. block_size is mainly useful for testing; in production you would probably never want to set it. virtual bool ArrayOutputStream::Next(\n        void ** data,\n        int * size)Obtains a buffer into which data can be written. Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.\nPreconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes in the buffer and \"data\" points to the buffer. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. Any data which the caller stores in this buffer will eventually be written to the output (unless BackUp() is called). It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void ArrayOutputStream::BackUp(\n        int count)Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use BackUp() to back up.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). The caller must not have written anything to the last \"count\" bytes of that buffer. Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be ignored. class StringOutputStream: public ZeroCopyOutputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl_lite.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyOutputStream which appends bytes to a string. Membersexplicit StringOutputStream(std::string * target)Create a StringOutputStream which appends bytes to the given string. more...~StringOutputStream()implements ZeroCopyOutputStreamvirtual boolNext(void ** data, int * size)Obtains a buffer into which data can be written. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. more...virtual int64_tByteCount() constReturns the total number of bytes written since this object was created. explicit StringOutputStream::StringOutputStream(\n        std::string * target)Create a StringOutputStream which appends bytes to the given string. The string remains property of the caller, but it is mutated in arbitrary ways and MUST NOT be accessed in any way until you're done with the stream. Either be sure there's no further usage, or (safest) destroy the stream before using the contents.\nHint: If you call target-\u003ereserve(n) before creating the stream, the first call to Next() will return at least n bytes of buffer space. virtual bool StringOutputStream::Next(\n        void ** data,\n        int * size)Obtains a buffer into which data can be written. Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.\nPreconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes in the buffer and \"data\" points to the buffer. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. Any data which the caller stores in this buffer will eventually be written to the output (unless BackUp() is called). It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void StringOutputStream::BackUp(\n        int count)Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use BackUp() to back up.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). The caller must not have written anything to the last \"count\" bytes of that buffer. Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be ignored. class CopyingInputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl_lite.h\u003e\nnamespace google::protobuf::io\nA generic traditional input stream interface. Lots of traditional input streams (e.g. file descriptors, C stdio streams, and C++ iostreams) expose an interface where every read involves copying bytes into a buffer. If you want to take such an interface and make a ZeroCopyInputStream based on it, simply implement CopyingInputStream and then use CopyingInputStreamAdaptor.\nCopyingInputStream implementations should avoid buffering if possible. CopyingInputStreamAdaptor does its own buffering and will read data in large blocks. Membersvirtual ~CopyingInputStream()virtual intRead(void * buffer, int size) = 0Reads up to \"size\" bytes into the given buffer. more...virtual intSkip(int count)Skips the next \"count\" bytes of input. more... virtual int CopyingInputStream::Read(\n        void * buffer,\n        int size) = 0Reads up to \"size\" bytes into the given buffer. Returns the number of bytes read. Read() waits until at least one byte is available, or returns zero if no bytes will ever become available (EOF), or -1 if a permanent read error occurred. virtual int CopyingInputStream::Skip(\n        int count)Skips the next \"count\" bytes of input. Returns the number of bytes actually skipped. This will always be exactly equal to \"count\" unless EOF was reached or a permanent read error occurred.\nThe default implementation just repeatedly calls Read() into a scratch buffer. class CopyingInputStreamAdaptor: public ZeroCopyInputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl_lite.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyInputStream which reads from a CopyingInputStream. This is useful for implementing ZeroCopyInputStreams that read from traditional streams. Note that this class is not really zero-copy.\nIf you want to read from file descriptors or C++ istreams, this is already implemented for you: use FileInputStream or IstreamInputStream respectively. Membersexplicit CopyingInputStreamAdaptor(CopyingInputStream * copying_stream, int block_size = -1)Creates a stream that reads from the given CopyingInputStream. more...~CopyingInputStreamAdaptor()voidSetOwnsCopyingStream(bool value)Call SetOwnsCopyingStream(true) to tell the CopyingInputStreamAdaptor to delete the underlying CopyingInputStream when it is destroyed. implements ZeroCopyInputStreamvirtual boolNext(const void ** data, int * size)Obtains a chunk of data from the stream. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). more...virtual boolSkip(int count)Skips a number of bytes. more...virtual int64_tByteCount() constReturns the total number of bytes read since this object was created. explicit CopyingInputStreamAdaptor::CopyingInputStreamAdaptor(\n        CopyingInputStream * copying_stream,\n        int block_size = -1)Creates a stream that reads from the given CopyingInputStream. If a block_size is given, it specifies the number of bytes that should be read and returned with each call to Next(). Otherwise, a reasonable default is used. The caller retains ownership of copying_stream unless SetOwnsCopyingStream(true) is called. virtual bool CopyingInputStreamAdaptor::Next(\n        const void ** data,\n        int * size)Obtains a chunk of data from the stream. Preconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, there is no more data to return or an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes read and \"data\" points to a pointer to a buffer containing these bytes. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void CopyingInputStreamAdaptor::BackUp(\n        int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If Next() returns a buffer that goes beyond what you wanted to read, you can use BackUp() to return to the point where you intended to finish.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be pushed back into the stream. Subsequent calls to Next() will return the same data again before producing new data. virtual bool CopyingInputStreamAdaptor::Skip(\n        int count)Skips a number of bytes. Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so ByteCount() will return the total size of the stream). class CopyingOutputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl_lite.h\u003e\nnamespace google::protobuf::io\nA generic traditional output stream interface. Lots of traditional output streams (e.g. file descriptors, C stdio streams, and C++ iostreams) expose an interface where every write involves copying bytes from a buffer. If you want to take such an interface and make a ZeroCopyOutputStream based on it, simply implement CopyingOutputStream and then use CopyingOutputStreamAdaptor.\nCopyingOutputStream implementations should avoid buffering if possible. CopyingOutputStreamAdaptor does its own buffering and will write data in large blocks. Membersvirtual ~CopyingOutputStream()virtual boolWrite(const void * buffer, int size) = 0Writes \"size\" bytes from the given buffer to the output. more... virtual bool CopyingOutputStream::Write(\n        const void * buffer,\n        int size) = 0Writes \"size\" bytes from the given buffer to the output. Returns true if successful, false on a write error. class CopyingOutputStreamAdaptor: public ZeroCopyOutputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl_lite.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyOutputStream which writes to a CopyingOutputStream. This is useful for implementing ZeroCopyOutputStreams that write to traditional streams. Note that this class is not really zero-copy.\nIf you want to write to file descriptors or C++ ostreams, this is already implemented for you: use FileOutputStream or OstreamOutputStream respectively. Known subclasses:\nFileOutputStreamMembersexplicit CopyingOutputStreamAdaptor(CopyingOutputStream * copying_stream, int block_size = -1)Creates a stream that writes to the given Unix file descriptor. more...~CopyingOutputStreamAdaptor()boolFlush()Writes all pending data to the underlying stream. more...voidSetOwnsCopyingStream(bool value)Call SetOwnsCopyingStream(true) to tell the CopyingOutputStreamAdaptor to delete the underlying CopyingOutputStream when it is destroyed. implements ZeroCopyOutputStreamvirtual boolNext(void ** data, int * size)Obtains a buffer into which data can be written. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. more...virtual int64_tByteCount() constReturns the total number of bytes written since this object was created. virtual boolWriteAliasedRaw(const void * data, int size)Write a given chunk of data to the output. more...virtual boolAllowsAliasing() const explicit CopyingOutputStreamAdaptor::CopyingOutputStreamAdaptor(\n        CopyingOutputStream * copying_stream,\n        int block_size = -1)Creates a stream that writes to the given Unix file descriptor. If a block_size is given, it specifies the size of the buffers that should be returned by Next(). Otherwise, a reasonable default is used. bool CopyingOutputStreamAdaptor::Flush()Writes all pending data to the underlying stream. Returns false if a write error occurred on the underlying stream. (The underlying stream itself is not necessarily flushed.) virtual bool CopyingOutputStreamAdaptor::Next(\n        void ** data,\n        int * size)Obtains a buffer into which data can be written. Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.\nPreconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes in the buffer and \"data\" points to the buffer. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. Any data which the caller stores in this buffer will eventually be written to the output (unless BackUp() is called). It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void CopyingOutputStreamAdaptor::BackUp(\n        int count)Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually written. This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use BackUp() to back up.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). The caller must not have written anything to the last \"count\" bytes of that buffer. Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be ignored. virtual bool CopyingOutputStreamAdaptor::WriteAliasedRaw(\n        const void * data,\n        int size)Write a given chunk of data to the output. Some output streams may implement this in a way that avoids copying. Check AllowsAliasing() before calling WriteAliasedRaw(). It will GOOGLE_CHECK fail if WriteAliasedRaw() is called on a stream that does not allow aliasing.\nNOTE: It is caller's responsibility to ensure that the chunk of memory remains live until all of the data has been consumed from the stream. class LimitingInputStream: public ZeroCopyInputStream#include \u003cgoogle/protobuf/io/zero_copy_stream_impl_lite.h\u003e\nnamespace google::protobuf::io\nA ZeroCopyInputStream which wraps some other stream and limits it to a particular byte count. MembersLimitingInputStream(ZeroCopyInputStream * input, int64 limit)~LimitingInputStream()implements ZeroCopyInputStreamvirtual boolNext(const void ** data, int * size)Obtains a chunk of data from the stream. more...virtual voidBackUp(int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). more...virtual boolSkip(int count)Skips a number of bytes. more...virtual int64_tByteCount() constReturns the total number of bytes read since this object was created. virtual bool LimitingInputStream::Next(\n        const void ** data,\n        int * size)Obtains a chunk of data from the stream. Preconditions:\n\"size\" and \"data\" are not NULL. Postconditions:\nIf the returned value is false, there is no more data to return or an error occurred. All errors are permanent. Otherwise, \"size\" points to the actual number of bytes read and \"data\" points to a pointer to a buffer containing these bytes. Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed. It is legal for the returned buffer to have zero size, as long as repeatedly calling Next() eventually yields a buffer with non-zero size. virtual void LimitingInputStream::BackUp(\n        int count)Backs up a number of bytes, so that the next call to Next() returns data again that was already returned by the last call to Next(). This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If Next() returns a buffer that goes beyond what you wanted to read, you can use BackUp() to return to the point where you intended to finish.\nPreconditions:\nThe last method called must have been Next(). count must be less than or equal to the size of the last buffer returned by Next(). Postconditions:\nThe last \"count\" bytes of the last buffer returned by Next() will be pushed back into the stream. Subsequent calls to Next() will return the same data again before producing new data. virtual bool LimitingInputStream::Skip(\n        int count)Skips a number of bytes. Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so ByteCount() will return the total size of the stream). ","categories":"","description":"","excerpt":"zero_copy_stream_impl_lite.hzero_copy_stream_impl_lite.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream_impl_lite/","tags":"","title":""},{"body":"map.hmap.h#include \u003cgoogle/protobuf/map.h\u003e\nnamespace google::protobuf\nThis file defines the map container and its helpers to support protobuf maps. The Map and MapIterator types are provided by this header file. Please avoid using other types defined here, unless they are public types within Map or MapIterator, such as Map::value_type. Classes in this fileMapPairThis is the class for Map's internal value_type. MapMap is an associative container type used to store protobuf map fields. Map::const_iteratorIterators. Map::iteratortemplate alias MapPair#include \u003cgoogle/protobuf/map.h\u003e\nnamespace google::protobuf\ntemplate \u003ctypename , typename \u003e\nThis is the class for Map's internal value_type, which is just an alias to std::pair. template class Map#include \u003cgoogle/protobuf/map.h\u003e\nnamespace google::protobuf\ntemplate \u003ctypename , typename \u003e\nMap is an associative container type used to store protobuf map fields. Each Map instance may or may not use a different hash function, a different iteration order, and so on. E.g., please don't examine implementation details to decide if the following would work: Map\u003cint, int\u003e m0, m1; m0[[]0] = m1[[]0] = m0[[]1] = m1[[]1] = 0; assert(m0.begin()-\u003efirst == m1.begin()-\u003efirst); // Bug!\nMap's interface is similar to std::unordered_map, except that Map is not designed to play well with exceptions. MemberstypedefKey key_typetypedefT mapped_typetypedefMapPair\u003c Key, T \u003e value_typetypedefvalue_type * pointertypedefconst value_type * const_pointertypedefvalue_type \u0026 referencetypedefconst value_type \u0026 const_referencetypedefsize_t size_typetypedeftypename internal::TransparentSupport\u003c Key \u003e::hash hasherconstexprMap()explicit Map(Arena * arena)Map(const Map \u0026 other)Map(Map \u0026\u0026 other)Map \u0026operator=(Map \u0026\u0026 other)template Map(const InputIt \u0026 first, const InputIt \u0026 last)~Map()iteratorbegin()iteratorend()const_iteratorbegin() constconst_iteratorend() constconst_iteratorcbegin() constconst_iteratorcend() constsize_typesize() constCapacity. boolempty() consttemplate T \u0026operator[](const key_arg\u003c K \u003e \u0026 key)Element access. template T \u0026operator[](key_arg\u003c K \u003e \u0026\u0026 key)template const T \u0026at(const key_arg\u003c K \u003e \u0026 key) consttemplate T \u0026at(const key_arg\u003c K \u003e \u0026 key)template size_typecount(const key_arg\u003c K \u003e \u0026 key) constLookup. template const_iteratorfind(const key_arg\u003c K \u003e \u0026 key) consttemplate iteratorfind(const key_arg\u003c K \u003e \u0026 key)template boolcontains(const key_arg\u003c K \u003e \u0026 key) consttemplate std::pair\u003c const_iterator, const_iterator \u003eequal_range(const key_arg\u003c K \u003e \u0026 key) consttemplate std::pair\u003c iterator, iterator \u003eequal_range(const key_arg\u003c K \u003e \u0026 key)std::pair\u003c iterator, bool \u003einsert(const value_type \u0026 value)insert template voidinsert(InputIt first, InputIt last)voidinsert(std::initializer_list\u003c value_type \u003e values)template size_typeerase(const key_arg\u003c K \u003e \u0026 key)Erase and clear. iteratorerase(iterator pos)voiderase(iterator first, iterator last)voidclear()Map \u0026operator=(const Map \u0026 other)Assign. voidswap(Map \u0026 other)voidInternalSwap(Map \u0026 other)hasherhash_function() constAccess to hasher. more...size_tSpaceUsedExcludingSelfLong() const hasher Map::hash_function() constAccess to hasher. Currently this returns a copy, but it may be modified to return a const reference in the future. class Map::const_iterator#include \u003cgoogle/protobuf/map.h\u003e\nnamespace google::protobuf\nIterators. Memberstypedefstd::forward_iterator_tag iterator_categorytypedeftypename Map::value_type value_typetypedefptrdiff_t difference_typetypedefconst value_type * pointertypedefconst value_type \u0026 referenceconst_iterator()explicit const_iterator(const InnerIt \u0026 it)const_referenceoperator*() constconst_pointeroperator-\u003e() constconst_iterator \u0026operator++()const_iteratoroperator++(int )class Map::iterator#include \u003cgoogle/protobuf/map.h\u003e\nnamespace google::protobuf\nMemberstypedefstd::forward_iterator_tag iterator_categorytypedeftypename Map::value_type value_typetypedefptrdiff_t difference_typetypedefvalue_type * pointertypedefvalue_type \u0026 referenceiterator()explicit iterator(const InnerIt \u0026 it)referenceoperator*() constpointeroperator-\u003e() constiterator \u0026operator++()iteratoroperator++(int )operator const_iterator() constAllow implicit conversion to const_iterator. ","categories":"","description":"","excerpt":"map.hmap.h#include \u003cgoogle/protobuf/map.h\u003e\nnamespace google::protobuf …","ref":"/reference/cpp/api-docs/google.protobuf.map/","tags":"","title":""},{"body":"message.hmessage.h#include \u003cgoogle/protobuf/message.h\u003e\nnamespace google::protobuf\nDefines Message, the abstract interface implemented by non-lite protocol message objects. Although it's possible to implement this interface manually, most users will use the protocol compiler to generate implementations.\nExample usage:\nSay you have a message defined as:\nmessage Foo { optional string text = 1; repeated int32 numbers = 2; } Then, if you used the protocol compiler to generate a class from the above definition, you could use it like so:\nstd::string data; // Will store a serialized version of the message. { // Create a message and serialize it. Foo foo; foo.set_text(“Hello World!”); foo.add_numbers(1); foo.add_numbers(5); foo.add_numbers(42);\nfoo.SerializeToString(\u0026data); }\n{ // Parse the serialized message and check that it contains the // correct data. Foo foo; foo.ParseFromString(data);\nassert(foo.text() == “Hello World!”); assert(foo.numbers_size() == 3); assert(foo.numbers(0) == 1); assert(foo.numbers(1) == 5); assert(foo.numbers(2) == 42); }\n{ // Same as the last block, but do it dynamically via the Message // reflection interface. Message* foo = new Foo; const Descriptor* descriptor = foo-\u003eGetDescriptor();\n// Get the descriptors for the fields we’re interested in and verify // their types. const FieldDescriptor* text_field = descriptor-\u003eFindFieldByName(“text”); assert(text_field != nullptr); assert(text_field-\u003etype() == FieldDescriptor::TYPE_STRING); assert(text_field-\u003elabel() == FieldDescriptor::LABEL_OPTIONAL); const FieldDescriptor* numbers_field = descriptor-\u003e FindFieldByName(“numbers”); assert(numbers_field != nullptr); assert(numbers_field-\u003etype() == FieldDescriptor::TYPE_INT32); assert(numbers_field-\u003elabel() == FieldDescriptor::LABEL_REPEATED);\n// Parse the message. foo-\u003eParseFromString(data);\n// Use the reflection interface to examine the contents. const Reflection* reflection = foo-\u003eGetReflection(); assert(reflection-\u003eGetString(*foo, text_field) == “Hello World!”); assert(reflection-\u003eFieldSize(*foo, numbers_field) == 3); assert(reflection-\u003eGetRepeatedInt32(*foo, numbers_field, 0) == 1); assert(reflection-\u003eGetRepeatedInt32(*foo, numbers_field, 1) == 5); assert(reflection-\u003eGetRepeatedInt32(*foo, numbers_field, 2) == 42);\ndelete foo; }\nClasses in this fileMetadataA container to hold message metadata. MessageAbstract interface for protocol messages. ReflectionThis interface contains methods that can be used to dynamically access and modify the fields of a protocol message. MessageFactoryAbstract interface for a factory for message objects. File MembersThese definitions are not part of any class.template const T *DynamicCastToGenerated(const Message * from)Tries to downcast this message to a generated message type. more...template T *DynamicCastToGenerated(Message * from)template voidLinkMessageReflection()Call this function to ensure that this message's reflection is linked into the binary: more...const RepeatedPtrField\u003c std::string \u003e \u0026Reflection::GetRepeatedPtrFieldInternal\u003c std::string \u003e(const Message \u0026 message, const FieldDescriptor * field) constRepeatedPtrField\u003c std::string \u003e *Reflection::MutableRepeatedPtrFieldInternal\u003c std::string \u003e(Message * message, const FieldDescriptor * field) const template const T * protobuf::DynamicCastToGenerated(\n        const Message * from)Tries to downcast this message to a generated message type. Returns nullptr if this class is not an instance of T. This works even if RTTI is disabled.\nThis also has the effect of creating a strong reference to T that will prevent the linker from stripping it out at link time. This can be important if you are using a DynamicMessageFactory that delegates to the generated factory. template void protobuf::LinkMessageReflection()Call this function to ensure that this message's reflection is linked into the binary: google::protobuf::LinkMessageReflection\u003cFooMessage\u003e(); This will ensure that the following lookup will succeed:\nDescriptorPool::generated_pool()-\u003eFindMessageTypeByName(\"FooMessage\"); As a side-effect, it will also guarantee that anything else from the same .proto file will also be available for lookup in the generated pool.\nThis function does not actually register the message, so it does not need to be called before the lookup. However it does need to occur in a function that cannot be stripped from the binary (ie. it must be reachable from main).\nBest practice is to call this function as close as possible to where the reflection is actually needed. This function is very cheap to call, so you should not need to worry about its runtime overhead except in the tightest of loops (on x86-64 it compiles into two \"mov\" instructions). struct Metadata#include \u003cgoogle/protobuf/message.h\u003e\nnamespace google::protobuf\nA container to hold message metadata. Membersconst Descriptor *descriptorconst Reflection *reflectionclass Message: public MessageLite#include \u003cgoogle/protobuf/message.h\u003e\nnamespace google::protobuf\nAbstract interface for protocol messages. See also MessageLite, which contains most every-day operations. Message adds descriptors and reflection on top of that.\nThe methods of this class that are virtual but not pure-virtual have default implementations based on reflection. Message classes which are optimized for speed will want to override these with faster implementations, but classes optimized for code size may be happy with keeping them. See the optimize_for option in descriptor.proto.\nUsers must not derive from this class. Only the protocol compiler and the internal library are allowed to create subclasses. MembersconstexprMessage()protected virtual MetadataGetMetadata() const = 0Get a struct containing the metadata for the Message, which is used in turn to implement GetDescriptor() and GetReflection() above. protected explicit Message(Arena * arena)protected static uint64GetInvariantPerBuild(uint64 salt)Basic Operationsvirtual Message *New() const = 0Construct a new instance of the same type. more...virtual Message *New(Arena * arena) constConstruct a new instance on the arena. more...virtual voidCopyFrom(const Message \u0026 from)Make this message into a copy of the given message. more...virtual voidMergeFrom(const Message \u0026 from)Merge the fields from the given message into this message. more...voidCheckInitialized() constVerifies that IsInitialized() returns true. more...voidFindInitializationErrors(std::vector\u003c std::string \u003e * errors) constSlowly build a list of all required fields that are not set. more...virtual std::stringInitializationErrorString() constLike FindInitializationErrors, but joins all the strings, delimited by commas, and returns them. virtual voidDiscardUnknownFields()Clears all unknown fields from this message and all embedded messages. more...virtual size_tSpaceUsedLong() constComputes (an estimate of) the total number of bytes currently used for storing the message in memory. more...intSpaceUsed() constDebugging \u0026 Testingstd::stringDebugString() constGenerates a human readable form of this message, useful for debugging and other purposes. std::stringShortDebugString() constLike DebugString(), but with less whitespace. std::stringUtf8DebugString() constLike DebugString(), but do not escape UTF-8 byte sequences. voidPrintDebugString() constConvenience function useful in GDB. Prints DebugString() to stdout. Reflection-based methodsThese methods are pure-virtual in MessageLite, but Message provides reflection-based default implementations. virtual std::stringGetTypeName() constGet the name of this message type, e.g. \"foo.bar.BazProto\". virtual voidClear()Clear all fields of the message and set them to their default values. more...virtual boolIsInitialized() constReturns whether all required fields have been set. more...virtual voidCheckTypeAndMergeFrom(const MessageLite \u0026 other)If |other| is the exact same class as this, calls MergeFrom(). more...virtual const char *_InternalParse(const char * ptr, internal::ParseContext * ctx)Reflective parser. virtual size_tByteSizeLong() constComputes the serialized size of the message. more...virtual uint8 *_InternalSerialize(uint8 * ptr, io::EpsCopyOutputStream * stream) constFast path when conditions match (ie. more...Introspectionconst Descriptor *GetDescriptor() constGet a non-owning pointer to a Descriptor for this message's type. more...const Reflection *GetReflection() constGet a non-owning pointer to the Reflection interface for this Message, which can be used to read and modify the fields of the Message dynamically (in other words, without knowing the message type at compile time). more... virtual Message * Message::New() const = 0Construct a new instance of the same type. Ownership is passed to the caller. (This is also defined in MessageLite, but is defined again here for return-type covariance.) virtual Message * Message::New(\n        Arena * arena) constConstruct a new instance on the arena. Ownership is passed to the caller if arena is a nullptr. Default implementation allows for API compatibility during the Arena transition. virtual void Message::CopyFrom(\n        const Message \u0026 from)Make this message into a copy of the given message. The given message must have the same descriptor, but need not necessarily be the same class. By default this is just implemented as \"Clear(); MergeFrom(from);\". virtual void Message::MergeFrom(\n        const Message \u0026 from)Merge the fields from the given message into this message. Singular fields will be overwritten, if specified in from, except for embedded messages which will be merged. Repeated fields will be concatenated. The given message must be of the same type as this message (i.e. the exact same class). void Message::CheckInitialized() constVerifies that IsInitialized() returns true. GOOGLE_CHECK-fails otherwise, with a nice error message. void Message::FindInitializationErrors(\n        std::vector\u003c std::string \u003e * errors) constSlowly build a list of all required fields that are not set. This is much, much slower than IsInitialized() as it is implemented purely via reflection. Generally, you should not call this unless you have already determined that an error exists by calling IsInitialized(). virtual void Message::DiscardUnknownFields()Clears all unknown fields from this message and all embedded messages. Normally, if unknown tag numbers are encountered when parsing a message, the tag and value are stored in the message's UnknownFieldSet and then written back out when the message is serialized. This allows servers which simply route messages to other servers to pass through messages that have new field definitions which they don't yet know about. However, this behavior can have security implications. To avoid it, call this method after parsing.\nSee Reflection::GetUnknownFields() for more on unknown fields. virtual size_t Message::SpaceUsedLong() constComputes (an estimate of) the total number of bytes currently used for storing the message in memory. The default implementation calls the Reflection object's SpaceUsed() method.\nSpaceUsed() is noticeably slower than ByteSize(), as it is implemented using reflection (rather than the generated code implementation for ByteSize()). Like ByteSize(), its CPU time is linear in the number of fields defined for the proto. virtual void Message::Clear()Clear all fields of the message and set them to their default values. Clear() avoids freeing memory, assuming that any memory allocated to hold parts of the message will be needed again to hold the next message. If you actually want to free the memory used by a Message, you must delete it. virtual bool Message::IsInitialized() constReturns whether all required fields have been set. Note that required fields no longer exist starting in proto3. virtual void Message::CheckTypeAndMergeFrom(\n        const MessageLite \u0026 other)If |other| is the exact same class as this, calls MergeFrom(). Otherwise, results are undefined (probably crash). virtual size_t Message::ByteSizeLong() constComputes the serialized size of the message. This recursively calls ByteSizeLong() on all embedded messages.\nByteSizeLong() is generally linear in the number of fields defined for the proto. virtual uint8 * Message::_InternalSerialize(\n        uint8 * ptr,\n        io::EpsCopyOutputStream * stream) constFast path when conditions match (ie. non-deterministic) uint8* _InternalSerialize(uint8* ptr) const; const Descriptor *     Message::GetDescriptor() constGet a non-owning pointer to a Descriptor for this message's type. This describes what fields the message contains, the types of those fields, etc. This object remains property of the Message. const Reflection *     Message::GetReflection() constGet a non-owning pointer to the Reflection interface for this Message, which can be used to read and modify the fields of the Message dynamically (in other words, without knowing the message type at compile time). This object remains property of the Message. class Reflection#include \u003cgoogle/protobuf/message.h\u003e\nnamespace google::protobuf\nThis interface contains methods that can be used to dynamically access and modify the fields of a protocol message. Their semantics are similar to the accessors the protocol compiler generates.\nTo get the Reflection for a given Message, call Message::GetReflection().\nThis interface is separate from Message only for efficiency reasons; the vast majority of implementations of Message will share the same implementation of Reflection (GeneratedMessageReflection, defined in generated_message.h), and all Messages of a particular class should share the same Reflection object (though you should not rely on the latter fact).\nThere are several ways that these methods can be used incorrectly. For example, any of the following conditions will lead to undefined results (probably assertion failures):\nThe FieldDescriptor is not a field of this message type. The method called is not appropriate for the field's type. For each field type in FieldDescriptor::TYPE_*, there is only one Get*() method, one Set*() method, and one Add*() method that is valid for that type. It should be obvious which (except maybe for TYPE_BYTES, which are represented using strings in C++). A Get*() or Set*() method for singular fields is called on a repeated field. GetRepeated*(), SetRepeated*(), or Add*() is called on a non-repeated field. The Message object passed to any method is not of the right type for this Reflection object (i.e. message.GetReflection() != reflection). You might wonder why there is not any abstract representation for a field of arbitrary type. E.g., why isn't there just a \"GetField()\" method that returns \"const Field\u0026\", where \"Field\" is some class with accessors like \"GetInt32Value()\". The problem is that someone would have to deal with allocating these Field objects. For generated message classes, having to allocate space for an additional object to wrap every field would at least double the message's memory footprint, probably worse. Allocating the objects on-demand, on the other hand, would be expensive and prone to memory leaks. So, instead we ended up with this flat interface. Membersconst UnknownFieldSet \u0026GetUnknownFields(const Message \u0026 message) constGet the UnknownFieldSet for the message. more...UnknownFieldSet *MutableUnknownFields(Message * message) constGet a mutable pointer to the UnknownFieldSet for the message. more...size_tSpaceUsedLong(const Message \u0026 message) constEstimate the amount of memory used by the message object. intSpaceUsed(const Message \u0026 message) constboolHasField(const Message \u0026 message, const FieldDescriptor * field) constCheck if the given non-repeated field is set. intFieldSize(const Message \u0026 message, const FieldDescriptor * field) constGet the number of elements of a repeated field. voidClearField(Message * message, const FieldDescriptor * field) constClear the value of a field, so that HasField() returns false or FieldSize() returns zero. boolHasOneof(const Message \u0026 message, const OneofDescriptor * oneof_descriptor) constCheck if the oneof is set. more...voidClearOneof(Message * message, const OneofDescriptor * oneof_descriptor) constconst FieldDescriptor *GetOneofFieldDescriptor(const Message \u0026 message, const OneofDescriptor * oneof_descriptor) constReturns the field descriptor if the oneof is set. nullptr otherwise. voidRemoveLast(Message * message, const FieldDescriptor * field) constRemoves the last element of a repeated field. more...PROTOBUF_FUTURE_MUST_USE_RESULT Message *ReleaseLast(Message * message, const FieldDescriptor * field) constRemoves the last element of a repeated message field, and returns the pointer to the caller. more...voidSwap(Message * message1, Message * message2) constSwap the complete contents of two messages. voidSwapFields(Message * message1, Message * message2, const std::vector\u003c const FieldDescriptor * \u003e \u0026 fields) constSwap fields listed in fields vector of two messages. voidSwapElements(Message * message, const FieldDescriptor * field, int index1, int index2) constSwap two elements of a repeated field. voidListFields(const Message \u0026 message, std::vector\u003c const FieldDescriptor * \u003e * output) constList all fields of the message which are currently set, except for unknown fields, but including extension known to the parser (i.e. more...const RepeatedPtrField\u003c Message \u003e \u0026GetRepeatedPtrFieldInternal(const Message \u0026 message, const FieldDescriptor * field) constRepeatedPtrField\u003c Message \u003e *MutableRepeatedPtrFieldInternal(Message * message, const FieldDescriptor * field) constSingular field gettersThese get the value of a non-repeated field. They return the default value for fields that aren't set. int32GetInt32(const Message \u0026 message, const FieldDescriptor * field) constint64GetInt64(const Message \u0026 message, const FieldDescriptor * field) constuint32GetUInt32(const Message \u0026 message, const FieldDescriptor * field) constuint64GetUInt64(const Message \u0026 message, const FieldDescriptor * field) constfloatGetFloat(const Message \u0026 message, const FieldDescriptor * field) constdoubleGetDouble(const Message \u0026 message, const FieldDescriptor * field) constboolGetBool(const Message \u0026 message, const FieldDescriptor * field) conststd::stringGetString(const Message \u0026 message, const FieldDescriptor * field) constconst EnumValueDescriptor *GetEnum(const Message \u0026 message, const FieldDescriptor * field) constintGetEnumValue(const Message \u0026 message, const FieldDescriptor * field) constGetEnumValue() returns an enum field's value as an integer rather than an EnumValueDescriptor*. more...const Message \u0026GetMessage(const Message \u0026 message, const FieldDescriptor * field, MessageFactory * factory = nullptr) constSee MutableMessage() for the meaning of the \"factory\" parameter. const std::string \u0026GetStringReference(const Message \u0026 message, const FieldDescriptor * field, std::string * scratch) constGet a string value without copying, if possible. more...Singular field mutatorsThese mutate the value of a non-repeated field. voidSetInt32(Message * message, const FieldDescriptor * field, int32 value) constvoidSetInt64(Message * message, const FieldDescriptor * field, int64 value) constvoidSetUInt32(Message * message, const FieldDescriptor * field, uint32 value) constvoidSetUInt64(Message * message, const FieldDescriptor * field, uint64 value) constvoidSetFloat(Message * message, const FieldDescriptor * field, float value) constvoidSetDouble(Message * message, const FieldDescriptor * field, double value) constvoidSetBool(Message * message, const FieldDescriptor * field, bool value) constvoidSetString(Message * message, const FieldDescriptor * field, std::string value) constvoidSetEnum(Message * message, const FieldDescriptor * field, const EnumValueDescriptor * value) constvoidSetEnumValue(Message * message, const FieldDescriptor * field, int value) constSet an enum field's value with an integer rather than EnumValueDescriptor. more...Message *MutableMessage(Message * message, const FieldDescriptor * field, MessageFactory * factory = nullptr) constGet a mutable pointer to a field with a message type. more...voidSetAllocatedMessage(Message * message, Message * sub_message, const FieldDescriptor * field) constReplaces the message specified by 'field' with the already-allocated object sub_message, passing ownership to the message. more...voidUnsafeArenaSetAllocatedMessage(Message * message, Message * sub_message, const FieldDescriptor * field) constSimilar to SetAllocatedMessage, but omits all internal safety and ownership checks. more...PROTOBUF_FUTURE_MUST_USE_RESULT Message *ReleaseMessage(Message * message, const FieldDescriptor * field, MessageFactory * factory = nullptr) constReleases the message specified by 'field' and returns the pointer, ReleaseMessage() will return the message the message object if it exists. more...Message *UnsafeArenaReleaseMessage(Message * message, const FieldDescriptor * field, MessageFactory * factory = nullptr) constSimilar to ReleaseMessage, but omits all internal safety and ownership checks. more...Repeated field gettersThese get the value of one element of a repeated field. int32GetRepeatedInt32(const Message \u0026 message, const FieldDescriptor * field, int index) constint64GetRepeatedInt64(const Message \u0026 message, const FieldDescriptor * field, int index) constuint32GetRepeatedUInt32(const Message \u0026 message, const FieldDescriptor * field, int index) constuint64GetRepeatedUInt64(const Message \u0026 message, const FieldDescriptor * field, int index) constfloatGetRepeatedFloat(const Message \u0026 message, const FieldDescriptor * field, int index) constdoubleGetRepeatedDouble(const Message \u0026 message, const FieldDescriptor * field, int index) constboolGetRepeatedBool(const Message \u0026 message, const FieldDescriptor * field, int index) conststd::stringGetRepeatedString(const Message \u0026 message, const FieldDescriptor * field, int index) constconst EnumValueDescriptor *GetRepeatedEnum(const Message \u0026 message, const FieldDescriptor * field, int index) constintGetRepeatedEnumValue(const Message \u0026 message, const FieldDescriptor * field, int index) constGetRepeatedEnumValue() returns an enum field's value as an integer rather than an EnumValueDescriptor*. more...const Message \u0026GetRepeatedMessage(const Message \u0026 message, const FieldDescriptor * field, int index) constconst std::string \u0026GetRepeatedStringReference(const Message \u0026 message, const FieldDescriptor * field, int index, std::string * scratch) constSee GetStringReference(), above. Repeated field mutatorsThese mutate the value of one element of a repeated field. voidSetRepeatedInt32(Message * message, const FieldDescriptor * field, int index, int32 value) constvoidSetRepeatedInt64(Message * message, const FieldDescriptor * field, int index, int64 value) constvoidSetRepeatedUInt32(Message * message, const FieldDescriptor * field, int index, uint32 value) constvoidSetRepeatedUInt64(Message * message, const FieldDescriptor * field, int index, uint64 value) constvoidSetRepeatedFloat(Message * message, const FieldDescriptor * field, int index, float value) constvoidSetRepeatedDouble(Message * message, const FieldDescriptor * field, int index, double value) constvoidSetRepeatedBool(Message * message, const FieldDescriptor * field, int index, bool value) constvoidSetRepeatedString(Message * message, const FieldDescriptor * field, int index, std::string value) constvoidSetRepeatedEnum(Message * message, const FieldDescriptor * field, int index, const EnumValueDescriptor * value) constvoidSetRepeatedEnumValue(Message * message, const FieldDescriptor * field, int index, int value) constSet an enum field's value with an integer rather than EnumValueDescriptor. more...Message *MutableRepeatedMessage(Message * message, const FieldDescriptor * field, int index) constGet a mutable pointer to an element of a repeated field with a message type. Repeated field addersThese add an element to a repeated field. voidAddInt32(Message * message, const FieldDescriptor * field, int32 value) constvoidAddInt64(Message * message, const FieldDescriptor * field, int64 value) constvoidAddUInt32(Message * message, const FieldDescriptor * field, uint32 value) constvoidAddUInt64(Message * message, const FieldDescriptor * field, uint64 value) constvoidAddFloat(Message * message, const FieldDescriptor * field, float value) constvoidAddDouble(Message * message, const FieldDescriptor * field, double value) constvoidAddBool(Message * message, const FieldDescriptor * field, bool value) constvoidAddString(Message * message, const FieldDescriptor * field, std::string value) constvoidAddEnum(Message * message, const FieldDescriptor * field, const EnumValueDescriptor * value) constvoidAddEnumValue(Message * message, const FieldDescriptor * field, int value) constAdd an integer value to a repeated enum field rather than EnumValueDescriptor. more...Message *AddMessage(Message * message, const FieldDescriptor * field, MessageFactory * factory = nullptr) constSee MutableMessage() for comments on the \"factory\" parameter. voidAddAllocatedMessage(Message * message, const FieldDescriptor * field, Message * new_entry) constAppends an already-allocated object 'new_entry' to the repeated field specified by 'field' passing ownership to the message. template RepeatedFieldRef\u003c T \u003eGetRepeatedFieldRef(const Message \u0026 message, const FieldDescriptor * field) constGet a RepeatedFieldRef object that can be used to read the underlying repeated field. more...template MutableRepeatedFieldRef\u003c T \u003eGetMutableRepeatedFieldRef(Message * message, const FieldDescriptor * field) constLike GetRepeatedFieldRef() but return an object that can also be used manipulate the underlying repeated field. template const RepeatedField\u003c T \u003e \u0026GetRepeatedField(const Message \u0026 msg, const FieldDescriptor * d) constDEPRECATED. more...template RepeatedField\u003c T \u003e *MutableRepeatedField(Message * msg, const FieldDescriptor * d) constDEPRECATED. more...template const RepeatedPtrField\u003c T \u003e \u0026GetRepeatedPtrField(const Message \u0026 msg, const FieldDescriptor * d) constDEPRECATED. more...template RepeatedPtrField\u003c T \u003e *MutableRepeatedPtrField(Message * msg, const FieldDescriptor * d) constDEPRECATED. more...Extensionsconst FieldDescriptor *FindKnownExtensionByName(const std::string \u0026 name) constTry to find an extension of this message type by fully-qualified field name. more...const FieldDescriptor *FindKnownExtensionByNumber(int number) constTry to find an extension of this message type by field number. more...Feature FlagsboolSupportsUnknownEnumValues() constDoes this message support storing arbitrary integer values in enum fields? If |true|, GetEnumValue/SetEnumValue and associated repeated-field versions take arbitrary integer values, and the legacy GetEnum() getter will dynamically create an EnumValueDescriptor for any integer value without one. more...MessageFactory *GetMessageFactory() constReturns the MessageFactory associated with this message. more... const UnknownFieldSet \u0026     Reflection::GetUnknownFields(\n        const Message \u0026 message) constGet the UnknownFieldSet for the message. This contains fields which were seen when the Message was parsed but were not recognized according to the Message's definition. UnknownFieldSet *     Reflection::MutableUnknownFields(\n        Message * message) constGet a mutable pointer to the UnknownFieldSet for the message. This contains fields which were seen when the Message was parsed but were not recognized according to the Message's definition. bool Reflection::HasOneof(\n        const Message \u0026 message,\n        const OneofDescriptor * oneof_descriptor) constCheck if the oneof is set. Returns true if any field in oneof is set, false otherwise. void Reflection::RemoveLast(\n        Message * message,\n        const FieldDescriptor * field) constRemoves the last element of a repeated field. We don't provide a way to remove any element other than the last because it invites inefficient use, such as O(n^2) filtering loops that should have been O(n). If you want to remove an element other than the last, the best way to do it is to re-arrange the elements (using Swap()) so that the one you want removed is at the end, then call RemoveLast(). PROTOBUF_FUTURE_MUST_USE_RESULT Message *     Reflection::ReleaseLast(\n        Message * message,\n        const FieldDescriptor * field) constRemoves the last element of a repeated message field, and returns the pointer to the caller. Caller takes ownership of the returned pointer. void Reflection::ListFields(\n        const Message \u0026 message,\n        std::vector\u003c const FieldDescriptor * \u003e * output) constList all fields of the message which are currently set, except for unknown fields, but including extension known to the parser (i.e. compiled in). Singular fields will only be listed if HasField(field) would return true and repeated fields will only be listed if FieldSize(field) would return non-zero. Fields (both normal fields and extension fields) will be listed ordered by field number. Use Reflection::GetUnknownFields() or message.unknown_fields() to also get access to fields/extensions unknown to the parser. int Reflection::GetEnumValue(\n        const Message \u0026 message,\n        const FieldDescriptor * field) constGetEnumValue() returns an enum field's value as an integer rather than an EnumValueDescriptor*. If the integer value does not correspond to a known value descriptor, a new value descriptor is created. (Such a value will only be present when the new unknown-enum-value semantics are enabled for a message.) const std::string \u0026     Reflection::GetStringReference(\n        const Message \u0026 message,\n        const FieldDescriptor * field,\n        std::string * scratch) constGet a string value without copying, if possible. GetString() necessarily returns a copy of the string. This can be inefficient when the std::string is already stored in a std::string object in the underlying message. GetStringReference() will return a reference to the underlying std::string in this case. Otherwise, it will copy the string into *scratch and return that.\nNote: It is perfectly reasonable and useful to write code like: str = reflection-\u003eGetStringReference(message, field, \u0026str); This line would ensure that only one copy of the string is made regardless of the field's underlying representation. When initializing a newly-constructed string, though, it's just as fast and more readable to use code like: std::string str = reflection-\u003eGetString(message, field); void Reflection::SetEnumValue(\n        Message * message,\n        const FieldDescriptor * field,\n        int value) constSet an enum field's value with an integer rather than EnumValueDescriptor. For proto3 this is just setting the enum field to the value specified, for proto2 it's more complicated. If value is a known enum value the field is set as usual. If the value is unknown then it is added to the unknown field set. Note this matches the behavior of parsing unknown enum values. If multiple calls with unknown values happen than they are all added to the unknown field set in order of the calls. Message * Reflection::MutableMessage(\n        Message * message,\n        const FieldDescriptor * field,\n        MessageFactory * factory = nullptr) constGet a mutable pointer to a field with a message type. If a MessageFactory is provided, it will be used to construct instances of the sub-message; otherwise, the default factory is used. If the field is an extension that does not live in the same pool as the containing message's descriptor (e.g. it lives in an overlay pool), then a MessageFactory must be provided. If you have no idea what that meant, then you probably don't need to worry about it (don't provide a MessageFactory). WARNING: If the FieldDescriptor is for a compiled-in extension, then factory-\u003eGetPrototype(field-\u003emessage_type()) MUST return an instance of the compiled-in class for this type, NOT DynamicMessage. void Reflection::SetAllocatedMessage(\n        Message * message,\n        Message * sub_message,\n        const FieldDescriptor * field) constReplaces the message specified by 'field' with the already-allocated object sub_message, passing ownership to the message. If the field contained a message, that message is deleted. If sub_message is nullptr, the field is cleared. void Reflection::UnsafeArenaSetAllocatedMessage(\n        Message * message,\n        Message * sub_message,\n        const FieldDescriptor * field) constSimilar to SetAllocatedMessage, but omits all internal safety and ownership checks. This method should only be used when the objects are on the same arena or paired with a call to UnsafeArenaReleaseMessage. PROTOBUF_FUTURE_MUST_USE_RESULT Message *     Reflection::ReleaseMessage(\n        Message * message,\n        const FieldDescriptor * field,\n        MessageFactory * factory = nullptr) constReleases the message specified by 'field' and returns the pointer, ReleaseMessage() will return the message the message object if it exists. Otherwise, it may or may not return nullptr. In any case, if the return value is non-null, the caller takes ownership of the pointer. If the field existed (HasField() is true), then the returned pointer will be the same as the pointer returned by MutableMessage(). This function has the same effect as ClearField(). Message * Reflection::UnsafeArenaReleaseMessage(\n        Message * message,\n        const FieldDescriptor * field,\n        MessageFactory * factory = nullptr) constSimilar to ReleaseMessage, but omits all internal safety and ownership checks. This method should only be used when the objects are on the same arena or paired with a call to UnsafeArenaSetAllocatedMessage. int Reflection::GetRepeatedEnumValue(\n        const Message \u0026 message,\n        const FieldDescriptor * field,\n        int index) constGetRepeatedEnumValue() returns an enum field's value as an integer rather than an EnumValueDescriptor*. If the integer value does not correspond to a known value descriptor, a new value descriptor is created. (Such a value will only be present when the new unknown-enum-value semantics are enabled for a message.) void Reflection::SetRepeatedEnumValue(\n        Message * message,\n        const FieldDescriptor * field,\n        int index,\n        int value) constSet an enum field's value with an integer rather than EnumValueDescriptor. For proto3 this is just setting the enum field to the value specified, for proto2 it's more complicated. If value is a known enum value the field is set as usual. If the value is unknown then it is added to the unknown field set. Note this matches the behavior of parsing unknown enum values. If multiple calls with unknown values happen than they are all added to the unknown field set in order of the calls. void Reflection::AddEnumValue(\n        Message * message,\n        const FieldDescriptor * field,\n        int value) constAdd an integer value to a repeated enum field rather than EnumValueDescriptor. For proto3 this is just setting the enum field to the value specified, for proto2 it's more complicated. If value is a known enum value the field is set as usual. If the value is unknown then it is added to the unknown field set. Note this matches the behavior of parsing unknown enum values. If multiple calls with unknown values happen than they are all added to the unknown field set in order of the calls. template RepeatedFieldRef\u003c T \u003e     Reflection::GetRepeatedFieldRef(\n        const Message \u0026 message,\n        const FieldDescriptor * field) constGet a RepeatedFieldRef object that can be used to read the underlying repeated field. The type parameter T must be set according to the field's cpp type. The following table shows the mapping from cpp type to acceptable T.\nfield-\u003ecpp_type() T CPPTYPE_INT32 int32 CPPTYPE_UINT32 uint32 CPPTYPE_INT64 int64 CPPTYPE_UINT64 uint64 CPPTYPE_DOUBLE double CPPTYPE_FLOAT float CPPTYPE_BOOL bool CPPTYPE_ENUM generated enum type or int32 CPPTYPE_STRING std::string CPPTYPE_MESSAGE generated message type or google::protobuf::Message A RepeatedFieldRef object can be copied and the resulted object will point to the same repeated field in the same message. The object can be used as long as the message is not destroyed.\nNote that to use this method users need to include the header file \"reflection.h\" (which defines the RepeatedFieldRef class templates). template const RepeatedField\u003c T \u003e \u0026     Reflection::GetRepeatedField(\n        const Message \u0026 msg,\n        const FieldDescriptor * d) constDEPRECATED. Please use GetRepeatedFieldRef().\nfor T = Cord and all protobuf scalar types except enums. template RepeatedField\u003c T \u003e *     Reflection::MutableRepeatedField(\n        Message * msg,\n        const FieldDescriptor * d) constDEPRECATED. Please use GetMutableRepeatedFieldRef().\nfor T = Cord and all protobuf scalar types except enums. template const RepeatedPtrField\u003c T \u003e \u0026     Reflection::GetRepeatedPtrField(\n        const Message \u0026 msg,\n        const FieldDescriptor * d) constDEPRECATED. Please use GetRepeatedFieldRef().\nfor T = std::string, google::protobuf::internal::StringPieceField google::protobuf::Message \u0026 descendants. template RepeatedPtrField\u003c T \u003e *     Reflection::MutableRepeatedPtrField(\n        Message * msg,\n        const FieldDescriptor * d) constDEPRECATED. Please use GetMutableRepeatedFieldRef().\nfor T = std::string, google::protobuf::internal::StringPieceField google::protobuf::Message \u0026 descendants. const FieldDescriptor *     Reflection::FindKnownExtensionByName(\n        const std::string \u0026 name) constTry to find an extension of this message type by fully-qualified field name. Returns nullptr if no extension is known for this name or number. const FieldDescriptor *     Reflection::FindKnownExtensionByNumber(\n        int number) constTry to find an extension of this message type by field number. Returns nullptr if no extension is known for this name or number. bool Reflection::SupportsUnknownEnumValues() constDoes this message support storing arbitrary integer values in enum fields? If |true|, GetEnumValue/SetEnumValue and associated repeated-field versions take arbitrary integer values, and the legacy GetEnum() getter will dynamically create an EnumValueDescriptor for any integer value without one. If |false|, setting an unknown enum value via the integer-based setters results in undefined behavior (in practice, GOOGLE_DCHECK-fails).\nGeneric code that uses reflection to handle messages with enum fields should check this flag before using the integer-based setter, and either downgrade to a compatible value or use the UnknownFieldSet if not. For example:\nint new_value = GetValueFromApplicationLogic(); if (reflection-\u003eSupportsUnknownEnumValues()) { reflection-\u003eSetEnumValue(message, field, new_value); } else { if (field_descriptor-\u003eenum_type()-\u003e FindValueByNumber(new_value) != nullptr) { reflection-\u003eSetEnumValue(message, field, new_value); } else if (emit_unknown_enum_values) { reflection-\u003eMutableUnknownFields(message)-\u003eAddVarint( field-\u003enumber(), new_value); } else { // convert value to a compatible/default value. new_value = CompatibleDowngrade(new_value); reflection-\u003eSetEnumValue(message, field, new_value); } } MessageFactory * Reflection::GetMessageFactory() constReturns the MessageFactory associated with this message. This can be useful for determining if a message is a generated message or not, for example: if (message-\u003eGetReflection()-\u003eGetMessageFactory() == google::protobuf::MessageFactory::generated_factory()) { // This is a generated message. } It can also be used to create more messages of this type, though Message::New() is an easier way to accomplish this. class MessageFactory#include \u003cgoogle/protobuf/message.h\u003e\nnamespace google::protobuf\nAbstract interface for a factory for message objects. Known subclasses:\nDynamicMessageFactoryMembersMessageFactory()virtual ~MessageFactory()virtual const Message *GetPrototype(const Descriptor * type) = 0Given a Descriptor, gets or constructs the default (prototype) Message of that type. more...static MessageFactory *generated_factory()Gets a MessageFactory which supports all generated, compiled-in messages. more...static voidInternalRegisterGeneratedFile(const google::protobuf::internal::DescriptorTable * table)For internal use only: Registers a .proto file at static initialization time, to be placed in generated_factory. more...static voidInternalRegisterGeneratedMessage(const Descriptor * descriptor, const Message * prototype)For internal use only: Registers a message type. more... virtual const Message * MessageFactory::GetPrototype(\n        const Descriptor * type) = 0Given a Descriptor, gets or constructs the default (prototype) Message of that type. You can then call that message's New() method to construct a mutable message of that type.\nCalling this method twice with the same Descriptor returns the same object. The returned object remains property of the factory. Also, any objects created by calling the prototype's New() method share some data with the prototype, so these must be destroyed before the MessageFactory is destroyed.\nThe given descriptor must outlive the returned message, and hence must outlive the MessageFactory.\nSome implementations do not support all types. GetPrototype() will return nullptr if the descriptor passed in is not supported.\nThis method may or may not be thread-safe depending on the implementation. Each implementation should document its own degree thread-safety. static MessageFactory * MessageFactory::generated_factory()Gets a MessageFactory which supports all generated, compiled-in messages. In other words, for any compiled-in type FooMessage, the following is true: MessageFactory::generated_factory()-\u003eGetPrototype( FooMessage::descriptor()) == FooMessage::default_instance() This factory supports all types which are found in DescriptorPool::generated_pool(). If given a descriptor from any other pool, GetPrototype() will return nullptr. (You can also check if a descriptor is for a generated message by checking if descriptor-\u003efile()-\u003epool() == DescriptorPool::generated_pool().)\nThis factory is 100% thread-safe; calling GetPrototype() does not modify any shared data.\nThis factory is a singleton. The caller must not delete the object. static void MessageFactory::InternalRegisterGeneratedFile(\n        const google::protobuf::internal::DescriptorTable * table)For internal use only: Registers a .proto file at static initialization time, to be placed in generated_factory. The first time GetPrototype() is called with a descriptor from this file, |register_messages| will be called, with the file name as the parameter. It must call InternalRegisterGeneratedMessage() (below) to register each message type in the file. This strange mechanism is necessary because descriptors are built lazily, so we can't register types by their descriptor until we know that the descriptor exists. |filename| must be a permanent string. static void MessageFactory::InternalRegisterGeneratedMessage(\n        const Descriptor * descriptor,\n        const Message * prototype)For internal use only: Registers a message type. Called only by the functions which are registered with InternalRegisterGeneratedFile(), above. ","categories":"","description":"","excerpt":"message.hmessage.h#include \u003cgoogle/protobuf/message.h\u003e\nnamespace …","ref":"/reference/cpp/api-docs/google.protobuf.message/","tags":"","title":""},{"body":"message_lite.hmessage_lite.h#include \u003cgoogle/protobuf/message_lite.h\u003e\nnamespace google::protobuf\nDefines MessageLite, the abstract interface implemented by all (lite and non-lite) protocol message objects. Classes in this fileMessageLiteInterface to light weight protocol messages. File MembersThese definitions are not part of any class.voidShutdownProtobufLibrary()Shut down the entire protocol buffers library, deleting all static-duration objects allocated by the library or by generated .pb.cc files. more... void protobuf::ShutdownProtobufLibrary()Shut down the entire protocol buffers library, deleting all static-duration objects allocated by the library or by generated .pb.cc files. There are two reasons you might want to call this:\nYou use a draconian definition of \"memory leak\" in which you expect every single malloc() to have a corresponding free(), even for objects which live until program exit. You are writing a dynamically-loaded library which needs to clean up after itself when the library is unloaded. It is safe to call this multiple times. However, it is not safe to use any other part of the protocol buffers library after ShutdownProtobufLibrary() has been called. Furthermore this call is not thread safe, user needs to synchronize multiple calls. class MessageLite#include \u003cgoogle/protobuf/message_lite.h\u003e\nnamespace google::protobuf\nInterface to light weight protocol messages. This interface is implemented by all protocol message objects. Non-lite messages additionally implement the Message interface, which is a subclass of MessageLite. Use MessageLite instead when you only need the subset of features which it supports – namely, nothing that uses descriptors or reflection. You can instruct the protocol compiler to generate classes which implement only MessageLite, not the full Message interface, by adding the following line to the .proto file:\noption optimize_for = LITE_RUNTIME; This is particularly useful on resource-constrained systems where the full protocol buffers runtime library is too big.\nNote that on non-constrained systems (e.g. servers) when you need to link in lots of protocol definitions, a better way to reduce total code footprint is to use optimize_for = CODE_SIZE. This will make the generated code smaller while still supporting all the same features (at the expense of speed). optimize_for = LITE_RUNTIME is best when you only have a small number of message types linked into your binary, in which case the size of the protocol buffers runtime itself is the biggest problem.\nUsers must not derive from this class. Only the protocol compiler and the internal library are allowed to create subclasses. Known subclasses:\nMessageMembersenumParseFlags more...protected internal::InternalMetadata_internal_metadata_constexprMessageLite()virtual ~MessageLite()template boolParseFrom(const T \u0026 input)virtual uint8 *_InternalSerialize(uint8 * ptr, io::EpsCopyOutputStream * stream) const = 0Fast path when conditions match (ie. more...boolIsInitializedWithErrors() constIdentical to IsInitialized() except that it logs an error message. protected template static T *CreateMaybeMessage(Arena * arena)protected explicit MessageLite(Arena * arena)protected Arena *GetOwningArena() constReturns the arena, if any, that directly owns this message and its internal memory (Arena::Own is different in that the arena doesn't directly own the internal memory). more...protected Arena *GetArenaForAllocation() constReturns the arena, used for allocating internal objects(e.g., child messages, etc), or owning incoming objects (e.g., set allocated). Basic Operationsvirtual std::stringGetTypeName() const = 0Get the name of this message type, e.g. \"foo.bar.BazProto\". virtual MessageLite *New() const = 0Construct a new instance of the same type. more...virtual MessageLite *New(Arena * arena) constConstruct a new instance on the arena. more...Arena *GetArena() constSame as GetOwningArena. void *GetMaybeArenaPointer() constGet a pointer that may be equal to this message's arena, or may not be. more...virtual voidClear() = 0Clear all fields of the message and set them to their default values. more...virtual boolIsInitialized() const = 0Quickly check if all required fields have values set. virtual std::stringInitializationErrorString() constThis is not implemented for Lite messages – it just returns \"(cannot determine missing fields for lite message)\". more...virtual voidCheckTypeAndMergeFrom(const MessageLite \u0026 other) = 0If |other| is the exact same class as this, calls MergeFrom(). more...std::stringDebugString() constThese methods return a human-readable summary of the message. more...std::stringShortDebugString() conststd::stringUtf8DebugString() constMessageLite::DebugString is already Utf8 Safe. more...Parsing Methods for parsing in protocol buffer format.\nMost of these are just simple wrappers around MergeFromCodedStream(). Clear() will be called before merging the input. PROTOBUF_ATTRIBUTE_REINITIALIZES boolParseFromCodedStream(io::CodedInputStream * input)Fill the message with a protocol buffer parsed from the given input stream. more...PROTOBUF_ATTRIBUTE_REINITIALIZES boolParsePartialFromCodedStream(io::CodedInputStream * input)Like ParseFromCodedStream(), but accepts messages that are missing required fields. PROTOBUF_ATTRIBUTE_REINITIALIZES boolParseFromZeroCopyStream(io::ZeroCopyInputStream * input)Read a protocol buffer from the given zero-copy input stream. more...PROTOBUF_ATTRIBUTE_REINITIALIZES boolParsePartialFromZeroCopyStream(io::ZeroCopyInputStream * input)Like ParseFromZeroCopyStream(), but accepts messages that are missing required fields. PROTOBUF_ATTRIBUTE_REINITIALIZES boolParseFromFileDescriptor(int file_descriptor)Parse a protocol buffer from a file descriptor. more...PROTOBUF_ATTRIBUTE_REINITIALIZES boolParsePartialFromFileDescriptor(int file_descriptor)Like ParseFromFileDescriptor(), but accepts messages that are missing required fields. PROTOBUF_ATTRIBUTE_REINITIALIZES boolParseFromIstream(std::istream * input)Parse a protocol buffer from a C++ istream. more...PROTOBUF_ATTRIBUTE_REINITIALIZES boolParsePartialFromIstream(std::istream * input)Like ParseFromIstream(), but accepts messages that are missing required fields. boolMergePartialFromBoundedZeroCopyStream(io::ZeroCopyInputStream * input, int size)Read a protocol buffer from the given zero-copy input stream, expecting the message to be exactly \"size\" bytes long. more...boolMergeFromBoundedZeroCopyStream(io::ZeroCopyInputStream * input, int size)Like ParseFromBoundedZeroCopyStream(), but accepts messages that are missing required fields. PROTOBUF_ATTRIBUTE_REINITIALIZES boolParseFromBoundedZeroCopyStream(io::ZeroCopyInputStream * input, int size)PROTOBUF_ATTRIBUTE_REINITIALIZES boolParsePartialFromBoundedZeroCopyStream(io::ZeroCopyInputStream * input, int size)Like ParseFromBoundedZeroCopyStream(), but accepts messages that are missing required fields. PROTOBUF_ATTRIBUTE_REINITIALIZES boolParseFromString(ConstStringParam data)Parses a protocol buffer contained in a string. more...PROTOBUF_ATTRIBUTE_REINITIALIZES boolParsePartialFromString(ConstStringParam data)Like ParseFromString(), but accepts messages that are missing required fields. PROTOBUF_ATTRIBUTE_REINITIALIZES boolParseFromArray(const void * data, int size)Parse a protocol buffer contained in an array of bytes. PROTOBUF_ATTRIBUTE_REINITIALIZES boolParsePartialFromArray(const void * data, int size)Like ParseFromArray(), but accepts messages that are missing required fields. boolMergeFromCodedStream(io::CodedInputStream * input)Reads a protocol buffer from the stream and merges it into this Message. more...boolMergePartialFromCodedStream(io::CodedInputStream * input)Like MergeFromCodedStream(), but succeeds even if required fields are missing in the input. more...boolMergeFromString(ConstStringParam data)Merge a protocol buffer contained in a string. Serialization Methods for serializing in protocol buffer format.\nMost of these are just simple wrappers around ByteSize() and SerializeWithCachedSizes(). boolSerializeToCodedStream(io::CodedOutputStream * output) constWrite a protocol buffer of this message to the given output. more...boolSerializePartialToCodedStream(io::CodedOutputStream * output) constLike SerializeToCodedStream(), but allows missing required fields. boolSerializeToZeroCopyStream(io::ZeroCopyOutputStream * output) constWrite the message to the given zero-copy output stream. more...boolSerializePartialToZeroCopyStream(io::ZeroCopyOutputStream * output) constLike SerializeToZeroCopyStream(), but allows missing required fields. boolSerializeToString(std::string * output) constSerialize the message and store it in the given string. more...boolSerializePartialToString(std::string * output) constLike SerializeToString(), but allows missing required fields. boolSerializeToArray(void * data, int size) constSerialize the message and store it in the given byte array. more...boolSerializePartialToArray(void * data, int size) constLike SerializeToArray(), but allows missing required fields. std::stringSerializeAsString() constMake a string encoding the message. more...std::stringSerializePartialAsString() constLike SerializeAsString(), but allows missing required fields. boolSerializeToFileDescriptor(int file_descriptor) constSerialize the message and write it to the given file descriptor. more...boolSerializePartialToFileDescriptor(int file_descriptor) constLike SerializeToFileDescriptor(), but allows missing required fields. boolSerializeToOstream(std::ostream * output) constSerialize the message and write it to the given C++ ostream. more...boolSerializePartialToOstream(std::ostream * output) constLike SerializeToOstream(), but allows missing required fields. boolAppendToString(std::string * output) constLike SerializeToString(), but appends to the data to the string's existing contents. more...boolAppendPartialToString(std::string * output) constLike AppendToString(), but allows missing required fields. virtual size_tByteSizeLong() const = 0Computes the serialized size of the message. more...intByteSize() constLegacy ByteSize() API. voidSerializeWithCachedSizes(io::CodedOutputStream * output) constSerializes the message without recomputing the size. more...uint8 *SerializeWithCachedSizesToArray(uint8 * target) constLike SerializeWithCachedSizes, but writes directly to *target, returning a pointer to the byte immediately after the last byte written. more...virtual intGetCachedSize() const = 0Returns the result of the last call to ByteSize(). more...virtual const char *_InternalParse(const char * , internal::ParseContext * ) enum MessageLite::ParseFlags {\n  kMerge = = 0,\n  kParse = = 1,\n  kMergePartial = = 2,\n  kParsePartial = = 3,\n  kMergeWithAliasing = = 4,\n  kParseWithAliasing = = 5,\n  kMergePartialWithAliasing = = 6,\n  kParsePartialWithAliasing = = 7\n}\nkMergekParsekMergePartialkParsePartialkMergeWithAliasingkParseWithAliasingkMergePartialWithAliasingkParsePartialWithAliasing virtual uint8 * MessageLite::_InternalSerialize(\n        uint8 * ptr,\n        io::EpsCopyOutputStream * stream) const = 0Fast path when conditions match (ie. non-deterministic) uint8* _InternalSerialize(uint8* ptr) const; protected Arena * MessageLite::GetOwningArena() constReturns the arena, if any, that directly owns this message and its internal memory (Arena::Own is different in that the arena doesn't directly own the internal memory). This method is used in proto's implementation for swapping, moving and setting allocated, for deciding whether the ownership of this message or its internal memory could be changed. virtual MessageLite * MessageLite::New() const = 0Construct a new instance of the same type. Ownership is passed to the caller. virtual MessageLite * MessageLite::New(\n        Arena * arena) constConstruct a new instance on the arena. Ownership is passed to the caller if arena is a NULL. Default implementation for backwards compatibility. void * MessageLite::GetMaybeArenaPointer() constGet a pointer that may be equal to this message's arena, or may not be. If the value returned by this method is equal to some arena pointer, then this message is on that arena; however, if this message is on some arena, this method may or may not return that arena's pointer. As a tradeoff, this method may be more efficient than GetArena(). The intent is to allow underlying representations that use e.g. tagged pointers to sometimes store the arena pointer directly, and sometimes in a more indirect way, and allow a fastpath comparison against the arena pointer when it's easy to obtain. virtual void MessageLite::Clear() = 0Clear all fields of the message and set them to their default values. Clear() avoids freeing memory, assuming that any memory allocated to hold parts of the message will be needed again to hold the next message. If you actually want to free the memory used by a Message, you must delete it. virtual std::string MessageLite::InitializationErrorString() constThis is not implemented for Lite messages – it just returns \"(cannot determine missing fields for lite message)\". However, it is implemented for full messages. See message.h. virtual void MessageLite::CheckTypeAndMergeFrom(\n        const MessageLite \u0026 other) = 0If |other| is the exact same class as this, calls MergeFrom(). Otherwise, results are undefined (probably crash). std::string MessageLite::DebugString() constThese methods return a human-readable summary of the message. Note that since the MessageLite interface does not support reflection, there is very little information that these methods can provide. They are shadowed by methods of the same name on the Message interface which provide much more information. The methods here are intended primarily to facilitate code reuse for logic that needs to interoperate with both full and lite protos.\nThe format of the returned string is subject to change, so please do not assume it will remain stable over time. std::string MessageLite::Utf8DebugString() constMessageLite::DebugString is already Utf8 Safe. This is to add compatibility with Message. PROTOBUF_ATTRIBUTE_REINITIALIZES bool     MessageLite::ParseFromCodedStream(\n        io::CodedInputStream * input)Fill the message with a protocol buffer parsed from the given input stream. Returns false on a read error or if the input is in the wrong format. A successful return does not indicate the entire input is consumed, ensure you call ConsumedEntireMessage() to check that if applicable. PROTOBUF_ATTRIBUTE_REINITIALIZES bool     MessageLite::ParseFromZeroCopyStream(\n        io::ZeroCopyInputStream * input)Read a protocol buffer from the given zero-copy input stream. If successful, the entire input will be consumed. PROTOBUF_ATTRIBUTE_REINITIALIZES bool     MessageLite::ParseFromFileDescriptor(\n        int file_descriptor)Parse a protocol buffer from a file descriptor. If successful, the entire input will be consumed. PROTOBUF_ATTRIBUTE_REINITIALIZES bool     MessageLite::ParseFromIstream(\n        std::istream * input)Parse a protocol buffer from a C++ istream. If successful, the entire input will be consumed. bool MessageLite::MergePartialFromBoundedZeroCopyStream(\n        io::ZeroCopyInputStream * input,\n        int size)Read a protocol buffer from the given zero-copy input stream, expecting the message to be exactly \"size\" bytes long. If successful, exactly this many bytes will have been consumed from the input. PROTOBUF_ATTRIBUTE_REINITIALIZES bool     MessageLite::ParseFromString(\n        ConstStringParam data)Parses a protocol buffer contained in a string. Returns true on success. This function takes a string in the (non-human-readable) binary wire format, matching the encoding output by MessageLite::SerializeToString(). If you'd like to convert a human-readable string into a protocol buffer object, see google::protobuf::TextFormat::ParseFromString(). bool MessageLite::MergeFromCodedStream(\n        io::CodedInputStream * input)Reads a protocol buffer from the stream and merges it into this Message. Singular fields read from the what is already in the Message and repeated fields are appended to those already present.\nIt is the responsibility of the caller to call input-\u003eLastTagWas() (for groups) or input-\u003eConsumedEntireMessage() (for non-groups) after this returns to verify that the message's end was delimited correctly.\nParseFromCodedStream() is implemented as Clear() followed by MergeFromCodedStream(). bool MessageLite::MergePartialFromCodedStream(\n        io::CodedInputStream * input)Like MergeFromCodedStream(), but succeeds even if required fields are missing in the input. MergeFromCodedStream() is just implemented as MergePartialFromCodedStream() followed by IsInitialized(). bool MessageLite::SerializeToCodedStream(\n        io::CodedOutputStream * output) constWrite a protocol buffer of this message to the given output. Returns false on a write error. If the message is missing required fields, this may GOOGLE_CHECK-fail. bool MessageLite::SerializeToZeroCopyStream(\n        io::ZeroCopyOutputStream * output) constWrite the message to the given zero-copy output stream. All required fields must be set. bool MessageLite::SerializeToString(\n        std::string * output) constSerialize the message and store it in the given string. All required fields must be set. bool MessageLite::SerializeToArray(\n        void * data,\n        int size) constSerialize the message and store it in the given byte array. All required fields must be set. std::string MessageLite::SerializeAsString() constMake a string encoding the message. Is equivalent to calling SerializeToString() on a string and using that. Returns the empty string if SerializeToString() would have returned an error. Note: If you intend to generate many such strings, you may reduce heap fragmentation by instead re-using the same string object with calls to SerializeToString(). bool MessageLite::SerializeToFileDescriptor(\n        int file_descriptor) constSerialize the message and write it to the given file descriptor. All required fields must be set. bool MessageLite::SerializeToOstream(\n        std::ostream * output) constSerialize the message and write it to the given C++ ostream. All required fields must be set. bool MessageLite::AppendToString(\n        std::string * output) constLike SerializeToString(), but appends to the data to the string's existing contents. All required fields must be set. virtual size_t MessageLite::ByteSizeLong() const = 0Computes the serialized size of the message. This recursively calls ByteSizeLong() on all embedded messages.\nByteSizeLong() is generally linear in the number of fields defined for the proto. void MessageLite::SerializeWithCachedSizes(\n        io::CodedOutputStream * output) constSerializes the message without recomputing the size. The message must not have changed since the last call to ByteSize(), and the value returned by ByteSize must be non-negative. Otherwise the results are undefined. uint8 * MessageLite::SerializeWithCachedSizesToArray(\n        uint8 * target) constLike SerializeWithCachedSizes, but writes directly to *target, returning a pointer to the byte immediately after the last byte written. \"target\" must point at a byte array of at least ByteSize() bytes. Whether to use deterministic serialization, e.g., maps in sorted order, is determined by CodedOutputStream::IsDefaultSerializationDeterministic(). virtual int MessageLite::GetCachedSize() const = 0Returns the result of the last call to ByteSize(). An embedded message's size is needed both to serialize it (because embedded messages are length-delimited) and to compute the outer message's size. Caching the size avoids computing it multiple times.\nByteSize() does not automatically use the cached size when available because this would require invalidating it every time the message was modified, which would be too hard and expensive. (E.g. if a deeply-nested sub-message is changed, all of its parents' cached sizes would need to be invalidated, which is too much work for an otherwise inlined setter method.) ","categories":"","description":"","excerpt":"message_lite.hmessage_lite.h#include \u003cgoogle/protobuf/message_lite.h\u003e …","ref":"/reference/cpp/api-docs/google.protobuf.message_lite/","tags":"","title":""},{"body":"repeated_field.hrepeated_field.h#include \u003cgoogle/protobuf/repeated_field.h\u003e\nnamespace google::protobuf\nRepeatedField and RepeatedPtrField are used by generated protocol message classes to manipulate repeated fields. These classes are very similar to STL's vector, but include a number of optimizations found to be useful specifically in the case of Protocol Buffers. RepeatedPtrField is particularly different from STL vector as it manages ownership of the pointers that it contains.\nTypically, clients should not need to access RepeatedField objects directly, but should instead use the accessor functions generated automatically by the protocol compiler. Classes in this fileRepeatedFieldRepeatedField is used to represent repeated fields of a primitive type (in other words, everything except strings and nested Messages). RepeatedPtrFieldRepeatedPtrField is like RepeatedField, but used for repeated strings or Messages. File MembersThese definitions are not part of any class.template internal::RepeatedFieldBackInsertIterator\u003c T \u003eRepeatedFieldBackInserter(RepeatedField\u003c T \u003e *const mutable_field)Provides a back insert iterator for RepeatedField instances, similar to std::back_inserter(). template internal::RepeatedPtrFieldBackInsertIterator\u003c T \u003eRepeatedPtrFieldBackInserter(RepeatedPtrField\u003c T \u003e *const mutable_field)Provides a back insert iterator for RepeatedPtrField instances, similar to std::back_inserter(). template internal::RepeatedPtrFieldBackInsertIterator\u003c T \u003eRepeatedFieldBackInserter(RepeatedPtrField\u003c T \u003e *const mutable_field)Special back insert iterator for RepeatedPtrField instances, just in case someone wants to write generic template code that can access both RepeatedFields and RepeatedPtrFields using a common name. template internal::AllocatedRepeatedPtrFieldBackInsertIterator\u003c T \u003eAllocatedRepeatedPtrFieldBackInserter(RepeatedPtrField\u003c T \u003e *const mutable_field)Provides a back insert iterator for RepeatedPtrField instances similar to std::back_inserter() which transfers the ownership while copying elements. template internal::UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator\u003c T \u003eUnsafeArenaAllocatedRepeatedPtrFieldBackInserter(RepeatedPtrField\u003c T \u003e *const mutable_field)Similar to AllocatedRepeatedPtrFieldBackInserter, using UnsafeArenaAddAllocated instead of AddAllocated. more... template internal::UnsafeArenaAllocatedRepeatedPtrFieldBackInsertIterator\u003c T \u003e     protobuf::UnsafeArenaAllocatedRepeatedPtrFieldBackInserter(\n        RepeatedPtrField\u003c T \u003e *const mutable_field)Similar to AllocatedRepeatedPtrFieldBackInserter, using UnsafeArenaAddAllocated instead of AddAllocated. This is slightly faster if that matters. It is also useful in legacy code that uses temporary ownership to avoid copies. Example: RepeatedPtrField\u003cT\u003e temp_field; temp_field.AddAllocated(new T); ... // Do something with temp_field temp_field.ExtractSubrange(0, temp_field.size(), nullptr); If you put temp_field on the arena this fails, because the ownership transfers to the arena at the \"AddAllocated\" call and is not released anymore causing a double delete. Using UnsafeArenaAddAllocated prevents this. template class RepeatedField#include \u003cgoogle/protobuf/repeated_field.h\u003e\nnamespace google::protobuf\ntemplate \u003ctypename \u003e\nRepeatedField is used to represent repeated fields of a primitive type (in other words, everything except strings and nested Messages). Most users will not ever use a RepeatedField directly; they will use the get-by-index, set-by-index, and add accessors that are generated for all repeated fields. MemberstypedefElement * iteratorSTL-like iterator support. typedefconst Element * const_iteratortypedefElement value_typetypedefvalue_type \u0026 referencetypedefconst value_type \u0026 const_referencetypedefvalue_type * pointertypedefconst value_type * const_pointertypedefint size_typetypedefptrdiff_t difference_typetypedefstd::reverse_iterator\u003c const_iterator \u003e const_reverse_iteratorReverse iterator support. typedefstd::reverse_iterator\u003c iterator \u003e reverse_iteratorconstexprRepeatedField()explicit RepeatedField(Arena * arena)RepeatedField(const RepeatedField \u0026 other)template RepeatedField(Iter begin, Iter end)~RepeatedField()RepeatedField \u0026operator=(const RepeatedField \u0026 other)RepeatedField(RepeatedField \u0026\u0026 other)RepeatedField \u0026operator=(RepeatedField \u0026\u0026 other)boolempty() constintsize() constconst Element \u0026Get(int index) constElement *Mutable(int index)const Element \u0026operator[](int index) constElement \u0026operator[](int index)const Element \u0026at(int index) constElement \u0026at(int index)voidSet(int index, const Element \u0026 value)voidAdd(const Element \u0026 value)Element *Add()Appends a new element and return a pointer to it. more...template voidAdd(Iter begin, Iter end)Append elements in the range [[]begin, end) after reserving the appropriate number of elements. voidRemoveLast()Remove the last element in the array. voidExtractSubrange(int start, int num, Element * elements)Extract elements with indices in \"[[]start .. start+num-1]\". more...voidClear()voidMergeFrom(const RepeatedField \u0026 other)voidCopyFrom(const RepeatedField \u0026 other)template voidAssign(Iter begin, Iter end)Replaces the contents with RepeatedField(begin, end). voidReserve(int new_size)Reserve space to expand the field to at least the given size. more...voidTruncate(int new_size)Resize the RepeatedField to a new, smaller size. This is O(1). voidAddAlreadyReserved(const Element \u0026 value)Element *AddAlreadyReserved()Appends a new element and return a pointer to it. more...Element *AddNAlreadyReserved(int elements)intCapacity() constvoidResize(int new_size, const Element \u0026 value)Like STL resize. more...Element *mutable_data()Gets the underlying array. more...const Element *data() constvoidSwap(RepeatedField * other)Swap entire contents with \"other\". more...voidUnsafeArenaSwap(RepeatedField * other)Swap entire contents with \"other\". more...voidSwapElements(int index1, int index2)Swap two elements. iteratorbegin()const_iteratorbegin() constconst_iteratorcbegin() constiteratorend()const_iteratorend() constconst_iteratorcend() constreverse_iteratorrbegin()const_reverse_iteratorrbegin() constreverse_iteratorrend()const_reverse_iteratorrend() constsize_tSpaceUsedExcludingSelfLong() constReturns the number of bytes used by the repeated field, excluding sizeof(*this) intSpaceUsedExcludingSelf() constiteratorerase(const_iterator position)Removes the element referenced by position. more...iteratorerase(const_iterator first, const_iterator last)Removes the elements in the range [[]first, last). more...Arena *GetArena() constGet the Arena on which this RepeatedField stores its elements. voidInternalSwap(RepeatedField * other)For internal use only. more...template RepeatedField(Iter begin, Iter end) Element * RepeatedField::Add()Appends a new element and return a pointer to it. The new element is uninitialized if |Element| is a POD type. void RepeatedField::ExtractSubrange(\n        int start,\n        int num,\n        Element * elements)Extract elements with indices in \"[[]start .. start+num-1]\". Copy them into \"elements[[]0 .. num-1]\" if \"elements\" is not NULL. Caution: implementation also moves elements with indices [[]start+num ..]. Calling this routine inside a loop can cause quadratic behavior. void RepeatedField::Reserve(\n        int new_size)Reserve space to expand the field to at least the given size. Avoid inlining of Reserve(): new, copy, and delete[[]] lead to a significant amount of code bloat.\nIf the array is grown, it will always be at least doubled in size. Element * RepeatedField::AddAlreadyReserved()Appends a new element and return a pointer to it. The new element is uninitialized if |Element| is a POD type. Should be called only if Capacity() \u003e Size(). void RepeatedField::Resize(\n        int new_size,\n        const Element \u0026 value)Like STL resize. Uses value to fill appended elements. Like Truncate() if new_size \u003c= size(), otherwise this is O(new_size - size()). Element * RepeatedField::mutable_data()Gets the underlying array. This pointer is possibly invalidated by any add or remove operation. void RepeatedField::Swap(\n        RepeatedField * other)Swap entire contents with \"other\". If they are separate arenas then, copies data between each other. void RepeatedField::UnsafeArenaSwap(\n        RepeatedField * other)Swap entire contents with \"other\". Should be called only if the caller can guarantee that both repeated fields are on the same arena or are on the heap. Swapping between different arenas is disallowed and caught by a GOOGLE_DCHECK (see API docs for details). iterator RepeatedField::erase(\n        const_iterator position)Removes the element referenced by position. Returns an iterator to the element immediately following the removed element.\nInvalidates all iterators at or after the removed element, including end(). iterator RepeatedField::erase(\n        const_iterator first,\n        const_iterator last)Removes the elements in the range [[]first, last). Returns an iterator to the element immediately following the removed range.\nInvalidates all iterators at or after the removed range, including end(). void RepeatedField::InternalSwap(\n        RepeatedField * other)For internal use only. This is public due to it being called by generated code. template class RepeatedPtrField#include \u003cgoogle/protobuf/repeated_field.h\u003e\nnamespace google::protobuf\ntemplate \u003ctypename \u003e\nRepeatedPtrField is like RepeatedField, but used for repeated strings or Messages. Memberstypedefinternal::RepeatedPtrIterator\u003c Element \u003e iteratorSTL-like iterator support. typedefinternal::RepeatedPtrIterator\u003c const Element \u003e const_iteratortypedefElement value_typetypedefvalue_type \u0026 referencetypedefconst value_type \u0026 const_referencetypedefvalue_type * pointertypedefconst value_type * const_pointertypedefint size_typetypedefptrdiff_t difference_typetypedefstd::reverse_iterator\u003c const_iterator \u003e const_reverse_iteratorReverse iterator support. typedefstd::reverse_iterator\u003c iterator \u003e reverse_iteratortypedefinternal::RepeatedPtrOverPtrsIterator\u003c Element *, void * \u003e pointer_iteratorCustom STL-like iterator that iterates over and returns the underlying pointers to Element rather than Element itself. typedefinternal::RepeatedPtrOverPtrsIterator\u003c const Element *const, const void *const \u003e const_pointer_iteratorconstexprRepeatedPtrField()explicit RepeatedPtrField(Arena * arena)RepeatedPtrField(const RepeatedPtrField \u0026 other)template RepeatedPtrField(Iter begin, Iter end)~RepeatedPtrField()RepeatedPtrField \u0026operator=(const RepeatedPtrField \u0026 other)RepeatedPtrField(RepeatedPtrField \u0026\u0026 other)RepeatedPtrField \u0026operator=(RepeatedPtrField \u0026\u0026 other)boolempty() constintsize() constconst Element \u0026Get(int index) constElement *Mutable(int index)Element *Add()voidAdd(Element \u0026\u0026 value)template voidAdd(Iter begin, Iter end)Append elements in the range [[]begin, end) after reserving the appropriate number of elements. const Element \u0026operator[](int index) constElement \u0026operator[](int index)const Element \u0026at(int index) constElement \u0026at(int index)voidRemoveLast()Remove the last element in the array. more...voidDeleteSubrange(int start, int num)Delete elements with indices in the range [[]start . more...voidClear()voidMergeFrom(const RepeatedPtrField \u0026 other)voidCopyFrom(const RepeatedPtrField \u0026 other)template voidAssign(Iter begin, Iter end)Replaces the contents with RepeatedPtrField(begin, end). voidReserve(int new_size)Reserve space to expand the field to at least the given size. more...intCapacity() constElement **mutable_data()Gets the underlying array. more...const Element *const *data() constvoidSwap(RepeatedPtrField * other)Swap entire contents with \"other\". more...voidUnsafeArenaSwap(RepeatedPtrField * other)Swap entire contents with \"other\". more...voidSwapElements(int index1, int index2)Swap two elements. iteratorbegin()const_iteratorbegin() constconst_iteratorcbegin() constiteratorend()const_iteratorend() constconst_iteratorcend() constreverse_iteratorrbegin()const_reverse_iteratorrbegin() constreverse_iteratorrend()const_reverse_iteratorrend() constpointer_iteratorpointer_begin()const_pointer_iteratorpointer_begin() constpointer_iteratorpointer_end()const_pointer_iteratorpointer_end() constsize_tSpaceUsedExcludingSelfLong() constReturns (an estimate of) the number of bytes used by the repeated field, excluding sizeof(*this). intSpaceUsedExcludingSelf() consttemplate RepeatedPtrField(Iter begin, Iter end)Advanced memory managementWhen hardcore memory management becomes necessary – as it sometimes does here at Google – the following methods may be useful. voidAddAllocated(Element * value)Add an already-allocated object, passing ownership to the RepeatedPtrField. more...PROTOBUF_FUTURE_MUST_USE_RESULT Element *ReleaseLast()Remove the last element and return it, passing ownership to the caller. more...voidUnsafeArenaAddAllocated(Element * value)Add an already-allocated object, skipping arena-ownership checks. more...Element *UnsafeArenaReleaseLast()Remove the last element and return it. more...voidExtractSubrange(int start, int num, Element ** elements)Extract elements with indices in the range \"[[]start .. start+num-1]\". more...voidUnsafeArenaExtractSubrange(int start, int num, Element ** elements)Identical to ExtractSubrange() described above, except that when this repeated field is on an arena, no object copies are performed. more...intClearedCount() constGet the number of cleared objects that are currently being kept around for reuse. voidAddCleared(Element * value)Add an element to the pool of cleared objects, passing ownership to the RepeatedPtrField. more...PROTOBUF_FUTURE_MUST_USE_RESULT Element *ReleaseCleared()Remove a single element from the cleared pool and return it, passing ownership to the caller. more...iteratorerase(const_iterator position)Removes the element referenced by position. more...iteratorerase(const_iterator first, const_iterator last)Removes the elements in the range [[]first, last). more...Arena *GetArena() constGets the arena on which this RepeatedPtrField stores its elements. voidInternalSwap(RepeatedPtrField * other)For internal use only. more... void RepeatedPtrField::RemoveLast()Remove the last element in the array. Ownership of the element is retained by the array. void RepeatedPtrField::DeleteSubrange(\n        int start,\n        int num)Delete elements with indices in the range [[]start . . start+num-1]. Caution: implementation moves all elements with indices [[]start+num .. ]. Calling this routine inside a loop can cause quadratic behavior. void RepeatedPtrField::Reserve(\n        int new_size)Reserve space to expand the field to at least the given size. This only resizes the pointer array; it doesn't allocate any objects. If the array is grown, it will always be at least doubled in size. Element ** RepeatedPtrField::mutable_data()Gets the underlying array. This pointer is possibly invalidated by any add or remove operation. void RepeatedPtrField::Swap(\n        RepeatedPtrField * other)Swap entire contents with \"other\". If they are on separate arenas, then copies data. void RepeatedPtrField::UnsafeArenaSwap(\n        RepeatedPtrField * other)Swap entire contents with \"other\". Caller should guarantee that either both fields are on the same arena or both are on the heap. Swapping between different arenas with this function is disallowed and is caught via GOOGLE_DCHECK. void RepeatedPtrField::AddAllocated(\n        Element * value)Add an already-allocated object, passing ownership to the RepeatedPtrField. Note that some special behavior occurs with respect to arenas:\n(i) if this field holds submessages, the new submessage will be copied if the original is in an arena and this RepeatedPtrField is either in a different arena, or on the heap. (ii) if this field holds strings, the passed-in string *must* be heap-allocated, not arena-allocated. There is no way to dynamically check this at runtime, so User Beware. PROTOBUF_FUTURE_MUST_USE_RESULT Element *     RepeatedPtrField::ReleaseLast()Remove the last element and return it, passing ownership to the caller. Requires: size() \u003e 0\nIf this RepeatedPtrField is on an arena, an object copy is required to pass ownership back to the user (for compatible semantics). Use UnsafeArenaReleaseLast() if this behavior is undesired. void RepeatedPtrField::UnsafeArenaAddAllocated(\n        Element * value)Add an already-allocated object, skipping arena-ownership checks. The user must guarantee that the given object is in the same arena as this RepeatedPtrField. It is also useful in legacy code that uses temporary ownership to avoid copies. Example: RepeatedPtrField\u003cT\u003e temp_field; temp_field.AddAllocated(new T); ... // Do something with temp_field temp_field.ExtractSubrange(0, temp_field.size(), nullptr); If you put temp_field on the arena this fails, because the ownership transfers to the arena at the \"AddAllocated\" call and is not released anymore causing a double delete. UnsafeArenaAddAllocated prevents this. Element * RepeatedPtrField::UnsafeArenaReleaseLast()Remove the last element and return it. Works only when operating on an arena. The returned pointer is to the original object in the arena, hence has the arena's lifetime. Requires: current_size_ \u003e 0 void RepeatedPtrField::ExtractSubrange(\n        int start,\n        int num,\n        Element ** elements)Extract elements with indices in the range \"[[]start .. start+num-1]\". The caller assumes ownership of the extracted elements and is responsible for deleting them when they are no longer needed. If \"elements\" is non-NULL, then pointers to the extracted elements are stored in \"elements[[]0 .. num-1]\" for the convenience of the caller. If \"elements\" is NULL, then the caller must use some other mechanism to perform any further operations (like deletion) on these elements. Caution: implementation also moves elements with indices [[]start+num ..]. Calling this routine inside a loop can cause quadratic behavior.\nMemory copying behavior is identical to ReleaseLast(), described above: if this RepeatedPtrField is on an arena, an object copy is performed for each returned element, so that all returned element pointers are to heap-allocated copies. If this copy is not desired, the user should call UnsafeArenaExtractSubrange(). void RepeatedPtrField::UnsafeArenaExtractSubrange(\n        int start,\n        int num,\n        Element ** elements)Identical to ExtractSubrange() described above, except that when this repeated field is on an arena, no object copies are performed. Instead, the raw object pointers are returned. Thus, if on an arena, the returned objects must not be freed, because they will not be heap-allocated objects. void RepeatedPtrField::AddCleared(\n        Element * value)Add an element to the pool of cleared objects, passing ownership to the RepeatedPtrField. The element must be cleared prior to calling this method.\nThis method cannot be called when the repeated field is on an arena or when |value| is; both cases will trigger a GOOGLE_DCHECK-failure. PROTOBUF_FUTURE_MUST_USE_RESULT Element *     RepeatedPtrField::ReleaseCleared()Remove a single element from the cleared pool and return it, passing ownership to the caller. The element is guaranteed to be cleared. Requires: ClearedCount() \u003e 0\nThis method cannot be called when the repeated field is on an arena; doing so will trigger a GOOGLE_DCHECK-failure. iterator RepeatedPtrField::erase(\n        const_iterator position)Removes the element referenced by position. Returns an iterator to the element immediately following the removed element.\nInvalidates all iterators at or after the removed element, including end(). iterator RepeatedPtrField::erase(\n        const_iterator first,\n        const_iterator last)Removes the elements in the range [[]first, last). Returns an iterator to the element immediately following the removed range.\nInvalidates all iterators at or after the removed range, including end(). void RepeatedPtrField::InternalSwap(\n        RepeatedPtrField * other)For internal use only. This is public due to it being called by generated code. ","categories":"","description":"","excerpt":"repeated_field.hrepeated_field.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.repeated_field/","tags":"","title":""},{"body":"service.hservice.h#include \u003cgoogle/protobuf/service.h\u003e\nnamespace google::protobuf\nDEPRECATED: This module declares the abstract interfaces underlying proto2 RPC services. These are intended to be independent of any particular RPC implementation, so that proto2 services can be used on top of a variety of implementations. Starting with version 2.3.0, RPC implementations should not try to build on these, but should instead provide code generator plugins which generate code specific to the particular RPC implementation. This way the generated code can be more appropriate for the implementation in use and can avoid unnecessary layers of indirection.\nWhen you use the protocol compiler to compile a service definition, it generates two classes: An abstract interface for the service (with methods matching the service definition) and a \"stub\" implementation. A stub is just a type-safe wrapper around an RpcChannel which emulates a local implementation of the service.\nFor example, the service definition: service MyService { rpc Foo(MyRequest) returns(MyResponse); } will generate abstract interface \"MyService\" and class \"MyService::Stub\". You could implement a MyService as follows: class MyServiceImpl : public MyService { public: MyServiceImpl() {} ~MyServiceImpl() {} // implements MyService —————————————\nvoid Foo(google::protobuf::RpcController* controller, const MyRequest* request, MyResponse* response, Closure* done) { // … read request and fill in response … done-\u003eRun(); } };\nYou would then register an instance of MyServiceImpl with your RPC server implementation. (How to do that depends on the implementation.)\nTo call a remote MyServiceImpl, first you need an RpcChannel connected to it. How to construct a channel depends, again, on your RPC implementation. Here we use a hypothetical \"MyRpcChannel\" as an example: MyRpcChannel channel(\"rpc:hostname:1234/myservice\"); MyRpcController controller; MyServiceImpl::Stub stub(\u0026channel); FooRequest request; FooResponse response; // … fill in request …\nstub.Foo(\u0026controller, request, \u0026response, NewCallback(HandleResponse));\nOn Thread-Safety:\nDifferent RPC implementations may make different guarantees about what threads they may run callbacks on, and what threads the application is allowed to use to call the RPC system. Portable software should be ready for callbacks to be called on any thread, but should not try to call the RPC system from any thread except for the ones on which it received the callbacks. Realistically, though, simple software will probably want to use a single-threaded RPC system while high-end software will want to use multiple threads. RPC implementations should provide multiple choices. Classes in this fileServiceAbstract base interface for protocol-buffer-based RPC services. RpcControllerAn RpcController mediates a single method call. RpcChannelAbstract interface for an RPC channel. class Service#include \u003cgoogle/protobuf/service.h\u003e\nnamespace google::protobuf\nAbstract base interface for protocol-buffer-based RPC services. Services themselves are abstract interfaces (implemented either by servers or as stubs), but they subclass this base interface. The methods of this interface can be used to call the methods of the Service without knowing its exact type at compile time (analogous to Reflection). MembersenumChannelOwnershipWhen constructing a stub, you may pass STUB_OWNS_CHANNEL as the second parameter to the constructor to tell it to delete its RpcChannel when destroyed. more...Service()virtual ~Service()virtual const ServiceDescriptor *GetDescriptor() = 0Get the ServiceDescriptor describing this service and its methods. virtual voidCallMethod(const MethodDescriptor * method, RpcController * controller, const Message * request, Message * response, Closure * done) = 0Call a method of the service specified by MethodDescriptor. more...virtual const Message \u0026GetRequestPrototype(const MethodDescriptor * method) const = 0CallMethod() requires that the request and response passed in are of a particular subclass of Message. more...virtual const Message \u0026GetResponsePrototype(const MethodDescriptor * method) const = 0 enum Service::ChannelOwnership {\n  STUB_OWNS_CHANNEL,\n  STUB_DOESNT_OWN_CHANNEL\n}When constructing a stub, you may pass STUB_OWNS_CHANNEL as the second parameter to the constructor to tell it to delete its RpcChannel when destroyed. STUB_OWNS_CHANNELSTUB_DOESNT_OWN_CHANNEL virtual void Service::CallMethod(\n        const MethodDescriptor * method,\n        RpcController * controller,\n        const Message * request,\n        Message * response,\n        Closure * done) = 0Call a method of the service specified by MethodDescriptor. This is normally implemented as a simple switch() that calls the standard definitions of the service's methods.\nPreconditions:\nmethod-\u003eservice() == GetDescriptor() request and response are of the exact same classes as the objects returned by GetRequestPrototype(method) and GetResponsePrototype(method). After the call has started, the request must not be modified and the response must not be accessed at all until \"done\" is called. \"controller\" is of the correct type for the RPC implementation being used by this Service. For stubs, the \"correct type\" depends on the RpcChannel which the stub is using. Server-side Service implementations are expected to accept whatever type of RpcController the server-side RPC implementation uses. Postconditions:\n\"done\" will be called when the method is complete. This may be before CallMethod() returns or it may be at some point in the future. If the RPC succeeded, \"response\" contains the response returned by the server. If the RPC failed, \"response\"'s contents are undefined. The RpcController can be queried to determine if an error occurred and possibly to get more information about the error. virtual const Message \u0026 Service::GetRequestPrototype(\n        const MethodDescriptor * method) const = 0CallMethod() requires that the request and response passed in are of a particular subclass of Message. GetRequestPrototype() and GetResponsePrototype() get the default instances of these required types. You can then call Message::New() on these instances to construct mutable objects which you can then pass to CallMethod().\nExample: const MethodDescriptor* method = service-\u003eGetDescriptor()-\u003eFindMethodByName(\"Foo\"); Message* request = stub-\u003eGetRequestPrototype (method)-\u003eNew(); Message* response = stub-\u003eGetResponsePrototype(method)-\u003eNew(); request-\u003eParseFromString(input); service-\u003eCallMethod(method, *request, response, callback); class RpcController#include \u003cgoogle/protobuf/service.h\u003e\nnamespace google::protobuf\nAn RpcController mediates a single method call. The primary purpose of the controller is to provide a way to manipulate settings specific to the RPC implementation and to find out about RPC-level errors.\nThe methods provided by the RpcController interface are intended to be a \"least common denominator\" set of features which we expect all implementations to support. Specific implementations may provide more advanced features (e.g. deadline propagation). MembersRpcController()virtual ~RpcController()Client-side methodsThese calls may be made from the client side only. Their results are undefined on the server side (may crash). virtual voidReset() = 0Resets the RpcController to its initial state so that it may be reused in a new call. more...virtual boolFailed() const = 0After a call has finished, returns true if the call failed. more...virtual std::stringErrorText() const = 0If Failed() is true, returns a human-readable description of the error. virtual voidStartCancel() = 0Advises the RPC system that the caller desires that the RPC call be canceled. more...Server-side methods These calls may be made from the server side only.\nTheir results are undefined on the client side (may crash). virtual voidSetFailed(const std::string \u0026 reason) = 0Causes Failed() to return true on the client side. more...virtual boolIsCanceled() const = 0If true, indicates that the client canceled the RPC, so the server may as well give up on replying to it. more...virtual voidNotifyOnCancel(Closure * callback) = 0Asks that the given callback be called when the RPC is canceled. more... virtual void RpcController::Reset() = 0Resets the RpcController to its initial state so that it may be reused in a new call. Must not be called while an RPC is in progress. virtual bool RpcController::Failed() const = 0After a call has finished, returns true if the call failed. The possible reasons for failure depend on the RPC implementation. Failed() must not be called before a call has finished. If Failed() returns true, the contents of the response message are undefined. virtual void RpcController::StartCancel() = 0Advises the RPC system that the caller desires that the RPC call be canceled. The RPC system may cancel it immediately, may wait awhile and then cancel it, or may not even cancel the call at all. If the call is canceled, the \"done\" callback will still be called and the RpcController will indicate that the call failed at that time. virtual void RpcController::SetFailed(\n        const std::string \u0026 reason) = 0Causes Failed() to return true on the client side. \"reason\" will be incorporated into the message returned by ErrorText(). If you find you need to return machine-readable information about failures, you should incorporate it into your response protocol buffer and should NOT call SetFailed(). virtual bool RpcController::IsCanceled() const = 0If true, indicates that the client canceled the RPC, so the server may as well give up on replying to it. The server should still call the final \"done\" callback. virtual void RpcController::NotifyOnCancel(\n        Closure * callback) = 0Asks that the given callback be called when the RPC is canceled. The callback will always be called exactly once. If the RPC completes without being canceled, the callback will be called after completion. If the RPC has already been canceled when NotifyOnCancel() is called, the callback will be called immediately.\nNotifyOnCancel() must be called no more than once per request. class RpcChannel#include \u003cgoogle/protobuf/service.h\u003e\nnamespace google::protobuf\nAbstract interface for an RPC channel. An RpcChannel represents a communication line to a Service which can be used to call that Service's methods. The Service may be running on another machine. Normally, you should not call an RpcChannel directly, but instead construct a stub Service wrapping it. Example: RpcChannel* channel = new MyRpcChannel(\"remotehost.example.com:1234\"); MyService* service = new MyService::Stub(channel); service-\u003eMyMethod(request, \u0026response, callback); MembersRpcChannel()virtual ~RpcChannel()virtual voidCallMethod(const MethodDescriptor * method, RpcController * controller, const Message * request, Message * response, Closure * done) = 0Call the given method of the remote service. more... virtual void RpcChannel::CallMethod(\n        const MethodDescriptor * method,\n        RpcController * controller,\n        const Message * request,\n        Message * response,\n        Closure * done) = 0Call the given method of the remote service. The signature of this procedure looks the same as Service::CallMethod(), but the requirements are less strict in one important way: the request and response objects need not be of any specific class as long as their descriptors are method-\u003einput_type() and method-\u003eoutput_type(). ","categories":"","description":"","excerpt":"service.hservice.h#include \u003cgoogle/protobuf/service.h\u003e\nnamespace …","ref":"/reference/cpp/api-docs/google.protobuf.service/","tags":"","title":""},{"body":"text_format.htext_format.h#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nUtilities for printing and parsing protocol messages in a human-readable, text-based format. Classes in this fileTextFormatThis class implements protocol buffer text format, colloquially known as text proto. TextFormat::BaseTextGeneratorTextFormat::FastFieldValuePrinterThe default printer that converts scalar values from fields into their string representation. TextFormat::FieldValuePrinterDeprecated: please use FastFieldValuePrinter instead. TextFormat::FinderInterface that Printers or Parsers can use to find extensions, or types referenced in Any messages. TextFormat::MessagePrinterTextFormat::ParseInfoTreeData structure which is populated with the locations of each field value parsed from the text. TextFormat::ParseLocationA location in the parsed text. TextFormat::ParserFor more control over parsing, use this class. TextFormat::PrinterClass for those users which require more fine-grained control over how a protobuffer message is printed out. class TextFormat#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nThis class implements protocol buffer text format, colloquially known as text proto. Printing and parsing protocol messages in text format is useful for debugging and human editing of messages.\nThis class is really a namespace that contains only static methods. Membersstatic boolPrint(const Message \u0026 message, io::ZeroCopyOutputStream * output)Outputs a textual representation of the given message to the given output stream. more...static boolPrintUnknownFields(const UnknownFieldSet \u0026 unknown_fields, io::ZeroCopyOutputStream * output)Print the fields in an UnknownFieldSet. more...static boolPrintToString(const Message \u0026 message, std::string * output)Like Print(), but outputs directly to a string. more...static boolPrintUnknownFieldsToString(const UnknownFieldSet \u0026 unknown_fields, std::string * output)Like PrintUnknownFields(), but outputs directly to a string. more...static voidPrintFieldValueToString(const Message \u0026 message, const FieldDescriptor * field, int index, std::string * output)Outputs a textual representation of the value of the field supplied on the message supplied. more...static boolParse(io::ZeroCopyInputStream * input, Message * output)Parses a text-format protocol message from the given input stream to the given message object. more...static boolParseFromString(ConstStringParam input, Message * output)Like Parse(), but reads directly from a string. static boolMerge(io::ZeroCopyInputStream * input, Message * output)Like Parse(), but the data is merged into the given message, as if using Message::MergeFrom(). static boolMergeFromString(ConstStringParam input, Message * output)Like Merge(), but reads directly from a string. static boolParseFieldValueFromString(const std::string \u0026 input, const FieldDescriptor * field, Message * message)Parse the given text as a single field value and store it into the given field of the given message. more... static bool TextFormat::Print(\n        const Message \u0026 message,\n        io::ZeroCopyOutputStream * output)Outputs a textual representation of the given message to the given output stream. Returns false if printing fails. static bool TextFormat::PrintUnknownFields(\n        const UnknownFieldSet \u0026 unknown_fields,\n        io::ZeroCopyOutputStream * output)Print the fields in an UnknownFieldSet. They are printed by tag number only. Embedded messages are heuristically identified by attempting to parse them. Returns false if printing fails. static bool TextFormat::PrintToString(\n        const Message \u0026 message,\n        std::string * output)Like Print(), but outputs directly to a string. Note: output will be cleared prior to printing, and will be left empty even if printing fails. Returns false if printing fails. static bool TextFormat::PrintUnknownFieldsToString(\n        const UnknownFieldSet \u0026 unknown_fields,\n        std::string * output)Like PrintUnknownFields(), but outputs directly to a string. Returns false if printing fails. static void TextFormat::PrintFieldValueToString(\n        const Message \u0026 message,\n        const FieldDescriptor * field,\n        int index,\n        std::string * output)Outputs a textual representation of the value of the field supplied on the message supplied. For non-repeated fields, an index of -1 must be supplied. Note that this method will print the default value for a field if it is not set. static bool TextFormat::Parse(\n        io::ZeroCopyInputStream * input,\n        Message * output)Parses a text-format protocol message from the given input stream to the given message object. This function parses the human-readable format written by Print(). Returns true on success. The message is cleared first, even if the function fails – See Merge() to avoid this behavior.\nExample input: \"user {\\n id: 123 extra { gender: MALE language: 'en' }\\n}\"\nOne use for this function is parsing handwritten strings in test code. Another use is to parse the output from google::protobuf::Message::DebugString() (or ShortDebugString()), because these functions output using google::protobuf::TextFormat::Print().\nIf you would like to read a protocol buffer serialized in the (non-human-readable) binary wire format, see google::protobuf::MessageLite::ParseFromString(). static bool TextFormat::ParseFieldValueFromString(\n        const std::string \u0026 input,\n        const FieldDescriptor * field,\n        Message * message)Parse the given text as a single field value and store it into the given field of the given message. If the field is a repeated field, the new value will be added to the end class TextFormat::BaseTextGenerator#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nMembersvirtual ~BaseTextGenerator()virtual voidIndent()virtual voidOutdent()virtual size_tGetCurrentIndentationSize() constReturns the current indentation size in characters. virtual voidPrint(const char * text, size_t size) = 0Print text to the output stream. voidPrintString(const std::string \u0026 str)template voidPrintLiteral(const char(\u0026) text)class TextFormat::FastFieldValuePrinter#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nThe default printer that converts scalar values from fields into their string representation. You can derive from this FastFieldValuePrinter if you want to have fields to be printed in a different way and register it at the Printer. MembersFastFieldValuePrinter()virtual ~FastFieldValuePrinter()virtual voidPrintBool(bool val, BaseTextGenerator * generator) constvirtual voidPrintInt32(int32 val, BaseTextGenerator * generator) constvirtual voidPrintUInt32(uint32 val, BaseTextGenerator * generator) constvirtual voidPrintInt64(int64 val, BaseTextGenerator * generator) constvirtual voidPrintUInt64(uint64 val, BaseTextGenerator * generator) constvirtual voidPrintFloat(float val, BaseTextGenerator * generator) constvirtual voidPrintDouble(double val, BaseTextGenerator * generator) constvirtual voidPrintString(const std::string \u0026 val, BaseTextGenerator * generator) constvirtual voidPrintBytes(const std::string \u0026 val, BaseTextGenerator * generator) constvirtual voidPrintEnum(int32 val, const std::string \u0026 name, BaseTextGenerator * generator) constvirtual voidPrintFieldName(const Message \u0026 message, int field_index, int field_count, const Reflection * reflection, const FieldDescriptor * field, BaseTextGenerator * generator) constvirtual voidPrintFieldName(const Message \u0026 message, const Reflection * reflection, const FieldDescriptor * field, BaseTextGenerator * generator) constvirtual voidPrintMessageStart(const Message \u0026 message, int field_index, int field_count, bool single_line_mode, BaseTextGenerator * generator) constvirtual boolPrintMessageContent(const Message \u0026 message, int field_index, int field_count, bool single_line_mode, BaseTextGenerator * generator) constAllows to override the logic on how to print the content of a message. more...virtual voidPrintMessageEnd(const Message \u0026 message, int field_index, int field_count, bool single_line_mode, BaseTextGenerator * generator) const virtual bool FastFieldValuePrinter::PrintMessageContent(\n        const Message \u0026 message,\n        int field_index,\n        int field_count,\n        bool single_line_mode,\n        BaseTextGenerator * generator) constAllows to override the logic on how to print the content of a message. Return false to use the default printing logic. Note that it is legal for this function to print something and then return false to use the default content printing (although at that point it would behave similarly to PrintMessageStart). class TextFormat::FieldValuePrinter#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nDeprecated: please use FastFieldValuePrinter instead. MembersFieldValuePrinter()virtual ~FieldValuePrinter()virtual std::stringPrintBool(bool val) constvirtual std::stringPrintInt32(int32 val) constvirtual std::stringPrintUInt32(uint32 val) constvirtual std::stringPrintInt64(int64 val) constvirtual std::stringPrintUInt64(uint64 val) constvirtual std::stringPrintFloat(float val) constvirtual std::stringPrintDouble(double val) constvirtual std::stringPrintString(const std::string \u0026 val) constvirtual std::stringPrintBytes(const std::string \u0026 val) constvirtual std::stringPrintEnum(int32 val, const std::string \u0026 name) constvirtual std::stringPrintFieldName(const Message \u0026 message, const Reflection * reflection, const FieldDescriptor * field) constvirtual std::stringPrintMessageStart(const Message \u0026 message, int field_index, int field_count, bool single_line_mode) constvirtual std::stringPrintMessageEnd(const Message \u0026 message, int field_index, int field_count, bool single_line_mode) constclass TextFormat::Finder#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nInterface that Printers or Parsers can use to find extensions, or types referenced in Any messages. Membersvirtual ~Finder()virtual const FieldDescriptor *FindExtension(Message * message, const std::string \u0026 name) constTry to find an extension of *message by fully-qualified field name. more...virtual const FieldDescriptor *FindExtensionByNumber(const Descriptor * descriptor, int number) constSimilar to FindExtension, but uses a Descriptor and the extension number instead of using a Message and the name when doing the look up. virtual const Descriptor *FindAnyType(const Message \u0026 message, const std::string \u0026 prefix, const std::string \u0026 name) constFind the message type for an Any proto. more...virtual MessageFactory *FindExtensionFactory(const FieldDescriptor * field) constFind the message factory for the given extension field. more... virtual const FieldDescriptor *     Finder::FindExtension(\n        Message * message,\n        const std::string \u0026 name) constTry to find an extension of *message by fully-qualified field name. Returns NULL if no extension is known for this name or number. The base implementation uses the extensions already known by the message. virtual const Descriptor *     Finder::FindAnyType(\n        const Message \u0026 message,\n        const std::string \u0026 prefix,\n        const std::string \u0026 name) constFind the message type for an Any proto. Returns NULL if no message is known for this name. The base implementation only accepts prefixes of type.googleprod.com/ or type.googleapis.com/, and searches the DescriptorPool of the parent message. virtual MessageFactory * Finder::FindExtensionFactory(\n        const FieldDescriptor * field) constFind the message factory for the given extension field. This can be used to generalize the Parser to add extension fields to a message in the same way as the \"input\" message for the Parser. class TextFormat::MessagePrinter#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nMembersMessagePrinter()virtual ~MessagePrinter()virtual voidPrint(const Message \u0026 message, bool single_line_mode, BaseTextGenerator * generator) const = 0class TextFormat::ParseInfoTree#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nData structure which is populated with the locations of each field value parsed from the text. MembersParseInfoTree()ParseInfoTree(const ParseInfoTree \u0026 )ParseInfoTree \u0026operator=(const ParseInfoTree \u0026 )ParseLocationGetLocation(const FieldDescriptor * field, int index) constReturns the parse location for index-th value of the field in the parsed text. more...ParseInfoTree *GetTreeForNested(const FieldDescriptor * field, int index) constReturns the parse info tree for the given field, which must be a message type. more... ParseLocation ParseInfoTree::GetLocation(\n        const FieldDescriptor * field,\n        int index) constReturns the parse location for index-th value of the field in the parsed text. If none exists, returns a location with line = -1. Index should be -1 for not-repeated fields. ParseInfoTree * ParseInfoTree::GetTreeForNested(\n        const FieldDescriptor * field,\n        int index) constReturns the parse info tree for the given field, which must be a message type. The nested information tree is owned by the root tree and will be deleted when it is deleted. struct TextFormat::ParseLocation#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nA location in the parsed text. MembersintlineintcolumnParseLocation()ParseLocation(int line_param, int column_param)class TextFormat::Parser#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nFor more control over parsing, use this class. MembersParser()~Parser()boolParse(io::ZeroCopyInputStream * input, Message * output)Like TextFormat::Parse(). boolParseFromString(ConstStringParam input, Message * output)Like TextFormat::ParseFromString(). boolMerge(io::ZeroCopyInputStream * input, Message * output)Like TextFormat::Merge(). boolMergeFromString(ConstStringParam input, Message * output)Like TextFormat::MergeFromString(). voidRecordErrorsTo(io::ErrorCollector * error_collector)Set where to report parse errors. more...voidSetFinder(const Finder * finder)Set how parser finds extensions. more...voidWriteLocationsTo(ParseInfoTree * tree)Sets where location information about the parse will be written. more...voidAllowPartialMessage(bool allow)Normally parsing fails if, after parsing, output-\u003eIsInitialized() returns false. more...voidAllowCaseInsensitiveField(bool allow)Allow field names to be matched case-insensitively. more...boolParseFieldValueFromString(const std::string \u0026 input, const FieldDescriptor * field, Message * output)Like TextFormat::ParseFieldValueFromString. voidAllowUnknownExtension(bool allow)When an unknown extension is met, parsing will fail if this option is set to false (the default). more...voidAllowUnknownField(bool allow)When an unknown field is met, parsing will fail if this option is set to false (the default). more...voidAllowFieldNumber(bool allow)voidSetRecursionLimit(int limit)Sets maximum recursion depth which parser can use. more... void Parser::RecordErrorsTo(\n        io::ErrorCollector * error_collector)Set where to report parse errors. If NULL (the default), errors will be printed to stderr. void Parser::SetFinder(\n        const Finder * finder)Set how parser finds extensions. If NULL (the default), the parser will use the standard Reflection object associated with the message being parsed. void Parser::WriteLocationsTo(\n        ParseInfoTree * tree)Sets where location information about the parse will be written. If NULL (the default), then no location will be written. void Parser::AllowPartialMessage(\n        bool allow)Normally parsing fails if, after parsing, output-\u003eIsInitialized() returns false. Call AllowPartialMessage(true) to skip this check. void Parser::AllowCaseInsensitiveField(\n        bool allow)Allow field names to be matched case-insensitively. This is not advisable if there are fields that only differ in case, or if you want to enforce writing in the canonical form. This is 'false' by default. void Parser::AllowUnknownExtension(\n        bool allow)When an unknown extension is met, parsing will fail if this option is set to false (the default). If true, unknown extensions will be ignored and a warning message will be generated. Beware! Setting this option true may hide some errors (e.g. spelling error on extension name). This allows data loss; unlike binary format, text format cannot preserve unknown extensions. Avoid using this option if possible. void Parser::AllowUnknownField(\n        bool allow)When an unknown field is met, parsing will fail if this option is set to false (the default). If true, unknown fields will be ignored and a warning message will be generated. Beware! Setting this option true may hide some errors (e.g. spelling error on field name). This allows data loss; unlike binary format, text format cannot preserve unknown fields. Avoid using this option if possible. void Parser::SetRecursionLimit(\n        int limit)Sets maximum recursion depth which parser can use. This is effectively the maximum allowed nesting of proto messages. class TextFormat::Printer#include \u003cgoogle/protobuf/text_format.h\u003e\nnamespace google::protobuf\nClass for those users which require more fine-grained control over how a protobuffer message is printed out. MembersPrinter()boolPrint(const Message \u0026 message, io::ZeroCopyOutputStream * output) constLike TextFormat::Print. boolPrintUnknownFields(const UnknownFieldSet \u0026 unknown_fields, io::ZeroCopyOutputStream * output) constLike TextFormat::PrintUnknownFields. boolPrintToString(const Message \u0026 message, std::string * output) constLike TextFormat::PrintToString. boolPrintUnknownFieldsToString(const UnknownFieldSet \u0026 unknown_fields, std::string * output) constLike TextFormat::PrintUnknownFieldsToString. voidPrintFieldValueToString(const Message \u0026 message, const FieldDescriptor * field, int index, std::string * output) constLike TextFormat::PrintFieldValueToString. voidSetInitialIndentLevel(int indent_level)Adjust the initial indent level of all output. more...voidSetSingleLineMode(bool single_line_mode)If printing in single line mode, then the entire message will be output on a single line with no line breaks. boolIsInSingleLineMode() constvoidSetUseFieldNumber(bool use_field_number)If use_field_number is true, uses field number instead of field name. voidSetUseShortRepeatedPrimitives(bool use_short_repeated_primitives)Set true to print repeated primitives in a format like: more...voidSetUseUtf8StringEscaping(bool as_utf8)Set true to output UTF-8 instead of ASCII. more...voidSetDefaultFieldValuePrinter(const FastFieldValuePrinter * printer)Set the default FastFieldValuePrinter that is used for all fields that don't have a field-specific printer registered. more...voidSetDefaultFieldValuePrinter(const FieldValuePrinter * printer)voidSetHideUnknownFields(bool hide)Sets whether we want to hide unknown fields or not. more...voidSetPrintMessageFieldsInIndexOrder(bool print_message_fields_in_index_order)If print_message_fields_in_index_order is true, fields of a proto message will be printed using the order defined in source code instead of the field number, extensions will be printed at the end of the message and their relative order is determined by the extension number. more...voidSetExpandAny(bool expand)If expand==true, expand google.protobuf.Any payloads. more...voidSetFinder(const Finder * finder)Set how parser finds message for Any payloads. voidSetTruncateStringFieldLongerThan(const int64 truncate_string_field_longer_than)If non-zero, we truncate all string fields that are longer than this threshold. more...boolRegisterFieldValuePrinter(const FieldDescriptor * field, const FastFieldValuePrinter * printer)Register a custom field-specific FastFieldValuePrinter for fields with a particular FieldDescriptor. more...boolRegisterFieldValuePrinter(const FieldDescriptor * field, const FieldValuePrinter * printer)boolRegisterMessagePrinter(const Descriptor * descriptor, const MessagePrinter * printer)Register a custom message-specific MessagePrinter for messages with a particular Descriptor. more... void Printer::SetInitialIndentLevel(\n        int indent_level)Adjust the initial indent level of all output. Each indent level is equal to two spaces. void Printer::SetUseShortRepeatedPrimitives(\n        bool use_short_repeated_primitives)Set true to print repeated primitives in a format like: field_name: [[]1, 2, 3, 4] instead of printing each value on its own line. Short format applies only to primitive values – i.e. everything except strings and sub-messages/groups. void Printer::SetUseUtf8StringEscaping(\n        bool as_utf8)Set true to output UTF-8 instead of ASCII. The only difference is that bytes \u003e= 0x80 in string fields will not be escaped, because they are assumed to be part of UTF-8 multi-byte sequences. This will change the default FastFieldValuePrinter. void Printer::SetDefaultFieldValuePrinter(\n        const FastFieldValuePrinter * printer)Set the default FastFieldValuePrinter that is used for all fields that don't have a field-specific printer registered. Takes ownership of the printer. void Printer::SetHideUnknownFields(\n        bool hide)Sets whether we want to hide unknown fields or not. Usually unknown fields are printed in a generic way that includes the tag number of the field instead of field name. However, sometimes it is useful to be able to print the message without unknown fields (e.g. for the python protobuf version to maintain consistency between its pure python and c++ implementations). void Printer::SetPrintMessageFieldsInIndexOrder(\n        bool print_message_fields_in_index_order)If print_message_fields_in_index_order is true, fields of a proto message will be printed using the order defined in source code instead of the field number, extensions will be printed at the end of the message and their relative order is determined by the extension number. By default, use the field number order. void Printer::SetExpandAny(\n        bool expand)If expand==true, expand google.protobuf.Any payloads. The output will be of form [[]type_url] { \u003cvalue_printed_in_text\u003e } If expand==false, print Any using the default printer. The output will look like type_url: \"\u003ctype_url\u003e\" value: \"serialized_content\" void Printer::SetTruncateStringFieldLongerThan(\n        const int64 truncate_string_field_longer_than)If non-zero, we truncate all string fields that are longer than this threshold. This is useful when the proto message has very long strings, e.g., dump of encoded image file.\nNOTE(hfgong): Setting a non-zero value breaks round-trip safe property of TextFormat::Printer. That is, from the printed message, we cannot fully recover the original string field any more. bool Printer::RegisterFieldValuePrinter(\n        const FieldDescriptor * field,\n        const FastFieldValuePrinter * printer)Register a custom field-specific FastFieldValuePrinter for fields with a particular FieldDescriptor. Returns \"true\" if the registration succeeded, or \"false\", if there is already a printer for that FieldDescriptor. Takes ownership of the printer on successful registration. bool Printer::RegisterMessagePrinter(\n        const Descriptor * descriptor,\n        const MessagePrinter * printer)Register a custom message-specific MessagePrinter for messages with a particular Descriptor. Returns \"true\" if the registration succeeded, or \"false\" if there is already a printer for that Descriptor. ","categories":"","description":"","excerpt":"text_format.htext_format.h#include \u003cgoogle/protobuf/text_format.h\u003e …","ref":"/reference/cpp/api-docs/google.protobuf.text_format/","tags":"","title":""},{"body":"unknown_field_set.hunknown_field_set.h#include \u003cgoogle/protobuf/unknown_field_set.h\u003e\nnamespace google::protobuf\nContains classes used to keep track of unrecognized fields seen while parsing a protocol message. Classes in this fileUnknownFieldSetAn UnknownFieldSet contains fields that were encountered while parsing a message but were not defined by its type. UnknownFieldRepresents one field in an UnknownFieldSet. UnknownField::LengthDelimitedclass UnknownFieldSet#include \u003cgoogle/protobuf/unknown_field_set.h\u003e\nnamespace google::protobuf\nAn UnknownFieldSet contains fields that were encountered while parsing a message but were not defined by its type. Keeping track of these can be useful, especially in that they may be written if the message is serialized again without being cleared in between. This means that software which simply receives messages and forwards them to other servers does not need to be updated every time a new field is added to the message definition.\nTo get the UnknownFieldSet attached to any message, call Reflection::GetUnknownFields().\nThis class is necessarily tied to the protocol buffer wire format, unlike the Reflection interface which is independent of any serialization scheme. MembersUnknownFieldSet()~UnknownFieldSet()voidClear()Remove all fields. voidClearAndFreeMemory()Remove all fields and deallocate internal data objects. boolempty() constIs this set empty? voidMergeFrom(const UnknownFieldSet \u0026 other)Merge the contents of some other UnknownFieldSet with this one. voidMergeFromAndDestroy(UnknownFieldSet * other)Similar to above, but this function will destroy the contents of other. voidSwap(UnknownFieldSet * x)Swaps the contents of some other UnknownFieldSet with this one. size_tSpaceUsedExcludingSelfLong() constComputes (an estimate of) the total number of bytes currently used for storing the unknown fields in memory. more...intSpaceUsedExcludingSelf() constsize_tSpaceUsedLong() constVersion of SpaceUsed() including sizeof(*this). intSpaceUsed() constintfield_count() constReturns the number of fields present in the UnknownFieldSet. const UnknownField \u0026field(int index) constGet a field in the set, where 0 \u003c= index \u003c field_count(). more...UnknownField *mutable_field(int index)Get a mutable pointer to a field in the set, where 0 \u003c= index \u003c field_count(). more...static voidMergeToInternalMetadata(const UnknownFieldSet \u0026 other, internal::InternalMetadata * metadata)Merge the contents an UnknownFieldSet with the UnknownFieldSet in *metadata, if there is one. more...Adding fieldsvoidAddVarint(int number, uint64 value)voidAddFixed32(int number, uint32 value)voidAddFixed64(int number, uint64 value)voidAddLengthDelimited(int number, const std::string \u0026 value)std::string *AddLengthDelimited(int number)UnknownFieldSet *AddGroup(int number)voidAddField(const UnknownField \u0026 field)Adds an unknown field from another set. voidDeleteSubrange(int start, int num)Delete fields with indices in the range [[]start . more...voidDeleteByNumber(int number)Delete all fields with a specific field number. more...Parsing helpersThese work exactly like the similarly-named methods of Message. boolMergeFromCodedStream(io::CodedInputStream * input)boolParseFromCodedStream(io::CodedInputStream * input)boolParseFromZeroCopyStream(io::ZeroCopyInputStream * input)boolParseFromArray(const void * data, int size)boolParseFromString(const std::string \u0026 data)template boolMergeFromMessage(const MessageType \u0026 message)Merges this message's unknown field data (if any). more...static const UnknownFieldSet \u0026default_instance() size_t UnknownFieldSet::SpaceUsedExcludingSelfLong() constComputes (an estimate of) the total number of bytes currently used for storing the unknown fields in memory. Does NOT include sizeof(*this) in the calculation. const UnknownField \u0026     UnknownFieldSet::field(\n        int index) constGet a field in the set, where 0 \u003c= index \u003c field_count(). The fields appear in the order in which they were added. UnknownField * UnknownFieldSet::mutable_field(\n        int index)Get a mutable pointer to a field in the set, where 0 \u003c= index \u003c field_count(). The fields appear in the order in which they were added. static void UnknownFieldSet::MergeToInternalMetadata(\n        const UnknownFieldSet \u0026 other,\n        internal::InternalMetadata * metadata)Merge the contents an UnknownFieldSet with the UnknownFieldSet in *metadata, if there is one. If *metadata doesn't have an UnknownFieldSet then add one to it and make it be a copy of the first arg. void UnknownFieldSet::DeleteSubrange(\n        int start,\n        int num)Delete fields with indices in the range [[]start . . start+num-1]. Caution: implementation moves all fields with indices [[]start+num .. ]. void UnknownFieldSet::DeleteByNumber(\n        int number)Delete all fields with a specific field number. The order of left fields is preserved. Caution: implementation moves all fields after the first deleted field. template bool UnknownFieldSet::MergeFromMessage(\n        const MessageType \u0026 message)Merges this message's unknown field data (if any). This works whether the message is a lite or full proto (for legacy reasons, lite and full return different types for MessageType::unknown_fields()). class UnknownField#include \u003cgoogle/protobuf/unknown_field_set.h\u003e\nnamespace google::protobuf\nRepresents one field in an UnknownFieldSet. MembersenumType more...uint64varint_uint32fixed32_uint64fixed64_union LengthDelimitedlength_delimited_UnknownFieldSet *group_intnumber() constThe field's field number, as seen on the wire. Typetype() constThe field type. AccessorsEach method works only for UnknownFields of the corresponding type. uint32number_uint32type_union google::protobuf::UnknownField::@35data_uint64varint() constuint32fixed32() constuint64fixed64() constconst std::string \u0026length_delimited() constconst UnknownFieldSet \u0026group() constvoidset_varint(uint64 value)voidset_fixed32(uint32 value)voidset_fixed64(uint64 value)voidset_length_delimited(const std::string \u0026 value)std::string *mutable_length_delimited()UnknownFieldSet *mutable_group()voidSerializeLengthDelimitedNoTag(io::CodedOutputStream * output) constSerialization API. more...size_tGetLengthDelimitedSize() constuint8 *InternalSerializeLengthDelimitedNoTag(uint8 * target, io::EpsCopyOutputStream * stream) constvoidDelete()If this UnknownField contains a pointer, delete it. voidDeepCopy(const UnknownField \u0026 other)Make a deep copy of any pointers in this UnknownField. voidSetType(Type type)Set the wire type of this UnknownField. more... enum UnknownField::Type {\n  TYPE_VARINT,\n  TYPE_FIXED32,\n  TYPE_FIXED64,\n  TYPE_LENGTH_DELIMITED,\n  TYPE_GROUP\n}\nTYPE_VARINTTYPE_FIXED32TYPE_FIXED64TYPE_LENGTH_DELIMITEDTYPE_GROUP void UnknownField::SerializeLengthDelimitedNoTag(\n        io::CodedOutputStream * output) constSerialization API. These methods can take advantage of the underlying implementation and may archieve a better performance than using getters to retrieve the data and do the serialization yourself. void UnknownField::SetType(\n        Type type)Set the wire type of this UnknownField. Should only be used when this UnknownField is being created. union UnknownField::LengthDelimited#include \u003cgoogle/protobuf/unknown_field_set.h\u003e\nnamespace google::protobuf\nMembersstd::string *string_value","categories":"","description":"","excerpt":"unknown_field_set.hunknown_field_set.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.unknown_field_set/","tags":"","title":""},{"body":"field_comparator.hfield_comparator.h#include \u003cgoogle/protobuf/util/field_comparator.h\u003e\nnamespace google::protobuf::util\nDefines classes for field comparison. Classes in this fileFieldComparatorBase class specifying the interface for comparing protocol buffer fields. SimpleFieldComparatorBasic implementation of FieldComparator. DefaultFieldComparatorclass FieldComparator#include \u003cgoogle/protobuf/util/field_comparator.h\u003e\nnamespace google::protobuf::util\nBase class specifying the interface for comparing protocol buffer fields. Regular users should consider using or subclassing DefaultFieldComparator rather than this interface. Currently, this does not support comparing unknown fields. Known subclasses:\nSimpleFieldComparatorMembersenumComparisonResult more...FieldComparator()virtual ~FieldComparator()virtual ComparisonResultCompare(const Message \u0026 message_1, const Message \u0026 message_2, const FieldDescriptor * field, int index_1, int index_2, const util::FieldContext * field_context) = 0Compares the values of a field in two protocol buffer messages. more... enum FieldComparator::ComparisonResult {\n  SAME,\n  DIFFERENT,\n  RECURSE\n}\nSAMECompared fields are equal. In case of comparing submessages, user should not recursively compare their contents. DIFFERENTCompared fields are different. In case of comparing submessages, user should not recursively compare their contents. RECURSECompared submessages need to be compared recursively. FieldComparator does not specify the semantics of recursive comparison. This value should not be returned for simple values. virtual ComparisonResult FieldComparator::Compare(\n        const Message \u0026 message_1,\n        const Message \u0026 message_2,\n        const FieldDescriptor * field,\n        int index_1,\n        int index_2,\n        const util::FieldContext * field_context) = 0Compares the values of a field in two protocol buffer messages. Returns SAME or DIFFERENT for simple values, and SAME, DIFFERENT or RECURSE for submessages. Returning RECURSE for fields not being submessages is illegal. In case the given FieldDescriptor points to a repeated field, the indices need to be valid. Otherwise they should be ignored.\nFieldContext contains information about the specific instances of the fields being compared, versus FieldDescriptor which only contains general type information about the fields. class SimpleFieldComparator: public FieldComparator#include \u003cgoogle/protobuf/util/field_comparator.h\u003e\nnamespace google::protobuf::util\nBasic implementation of FieldComparator. Supports three modes of floating point value comparison: exact, approximate using MathUtil::AlmostEqual method, and arbitrarily precise using MathUtil::WithinFractionOrMargin. Known subclasses:\nDefaultFieldComparatorMembersenumFloatComparison more...SimpleFieldComparator()Creates new comparator with float comparison set to EXACT. ~SimpleFieldComparator()voidset_float_comparison(FloatComparison float_comparison)FloatComparisonfloat_comparison() constvoidset_treat_nan_as_equal(bool treat_nan_as_equal)Set whether the FieldComparator shall treat floats or doubles that are both NaN as equal (treat_nan_as_equal = true) or as different (treat_nan_as_equal = false). more...booltreat_nan_as_equal() constvoidSetFractionAndMargin(const FieldDescriptor * field, double fraction, double margin)Sets the fraction and margin for the float comparison of a given field. more...voidSetDefaultFractionAndMargin(double fraction, double margin)Sets the fraction and margin for the float comparison of all float and double fields, unless a field has been given a specific setting via SetFractionAndMargin() above. more...protected ComparisonResultSimpleCompare(const Message \u0026 message_1, const Message \u0026 message_2, const FieldDescriptor * field, int index_1, int index_2, const util::FieldContext * field_context)Returns the comparison result for the given field in two messages. more...protected boolCompareWithDifferencer(MessageDifferencer * differencer, const Message \u0026 message1, const Message \u0026 message2, const util::FieldContext * field_context)Compare using the provided message_differencer. more...protected ComparisonResultResultFromBoolean(bool boolean_result) constReturns FieldComparator::SAME if boolean_result is true and FieldComparator::DIFFERENT otherwise. enum SimpleFieldComparator::FloatComparison {\n  EXACT,\n  APPROXIMATE\n}\nEXACTFloats and doubles are compared exactly. APPROXIMATEFloats and doubles are compared using the MathUtil::AlmostEqual method or MathUtil::WithinFractionOrMargin method. void SimpleFieldComparator::set_treat_nan_as_equal(\n        bool treat_nan_as_equal)Set whether the FieldComparator shall treat floats or doubles that are both NaN as equal (treat_nan_as_equal = true) or as different (treat_nan_as_equal = false). Default is treating NaNs always as different. void SimpleFieldComparator::SetFractionAndMargin(\n        const FieldDescriptor * field,\n        double fraction,\n        double margin)Sets the fraction and margin for the float comparison of a given field. Uses MathUtil::WithinFractionOrMargin to compare the values.\nREQUIRES: field-\u003ecpp_type == FieldDescriptor::CPPTYPE_DOUBLE or field-\u003ecpp_type == FieldDescriptor::CPPTYPE_FLOAT REQUIRES: float_comparison_ == APPROXIMATE void SimpleFieldComparator::SetDefaultFractionAndMargin(\n        double fraction,\n        double margin)Sets the fraction and margin for the float comparison of all float and double fields, unless a field has been given a specific setting via SetFractionAndMargin() above. Uses MathUtil::WithinFractionOrMargin to compare the values.\nREQUIRES: float_comparison_ == APPROXIMATE protected ComparisonResult SimpleFieldComparator::SimpleCompare(\n        const Message \u0026 message_1,\n        const Message \u0026 message_2,\n        const FieldDescriptor * field,\n        int index_1,\n        int index_2,\n        const util::FieldContext * field_context)Returns the comparison result for the given field in two messages. This function is called directly by DefaultFieldComparator::Compare. Subclasses can call this function to compare fields they do not need to handle specially. protected bool SimpleFieldComparator::CompareWithDifferencer(\n        MessageDifferencer * differencer,\n        const Message \u0026 message1,\n        const Message \u0026 message2,\n        const util::FieldContext * field_context)Compare using the provided message_differencer. For example, a subclass can use this method to compare some field in a certain way using the same message_differencer instance and the field context. class DefaultFieldComparator: public SimpleFieldComparator#include \u003cgoogle/protobuf/util/field_comparator.h\u003e\nnamespace google::protobuf::util\nMembersvirtual ComparisonResultCompare(const Message \u0026 message_1, const Message \u0026 message_2, const FieldDescriptor * field, int index_1, int index_2, const util::FieldContext * field_context)Compares the values of a field in two protocol buffer messages. more... virtual ComparisonResult DefaultFieldComparator::Compare(\n        const Message \u0026 message_1,\n        const Message \u0026 message_2,\n        const FieldDescriptor * field,\n        int index_1,\n        int index_2,\n        const util::FieldContext * field_context)Compares the values of a field in two protocol buffer messages. Returns SAME or DIFFERENT for simple values, and SAME, DIFFERENT or RECURSE for submessages. Returning RECURSE for fields not being submessages is illegal. In case the given FieldDescriptor points to a repeated field, the indices need to be valid. Otherwise they should be ignored.\nFieldContext contains information about the specific instances of the fields being compared, versus FieldDescriptor which only contains general type information about the fields. ","categories":"","description":"","excerpt":"field_comparator.hfield_comparator.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.util.field_comparator/","tags":"","title":""},{"body":"field_mask_util.hfield_mask_util.h#include \u003cgoogle/protobuf/util/field_mask_util.h\u003e\nnamespace google::protobuf::util\nDefines utilities for the FieldMask well known type. Classes in this fileFieldMaskUtilFieldMaskUtil::MergeOptionsFieldMaskUtil::TrimOptionsclass FieldMaskUtil#include \u003cgoogle/protobuf/util/field_mask_util.h\u003e\nnamespace google::protobuf::util\nMembersstatic std::stringToString(const FieldMask \u0026 mask)Converts FieldMask to/from string, formatted by separating each path with a comma (e.g., \"foo_bar,baz.quz\"). static voidFromString(StringPiece str, FieldMask * out)template static voidFromFieldNumbers(const std::vector\u003c int64_t \u003e \u0026 field_numbers, FieldMask * out)Populates the FieldMask with the paths corresponding to the fields with the given numbers, after checking that all field numbers are valid. static boolToJsonString(const FieldMask \u0026 mask, std::string * out)Converts FieldMask to/from string, formatted according to proto3 JSON spec for FieldMask (e.g., \"fooBar,baz.quz\"). more...static boolFromJsonString(StringPiece str, FieldMask * out)static boolGetFieldDescriptors(const Descriptor * descriptor, StringPiece path, std::vector\u003c const FieldDescriptor * \u003e * field_descriptors)Get the descriptors of the fields which the given path from the message descriptor traverses, if field_descriptors is not null. more...template static boolIsValidPath(StringPiece path)Checks whether the given path is valid for type T. template static boolIsValidFieldMask(const FieldMask \u0026 mask)Checks whether the given FieldMask is valid for type T. template static voidAddPathToFieldMask(StringPiece path, FieldMask * mask)Adds a path to FieldMask after checking whether the given path is valid. more...template static FieldMaskGetFieldMaskForAllFields()Creates a FieldMask with all fields of type T. more...template static voidGetFieldMaskForAllFields(FieldMask * out)static voidGetFieldMaskForAllFields(const Descriptor * descriptor, FieldMask * out)This flavor takes the protobuf type descriptor as an argument. more...static voidToCanonicalForm(const FieldMask \u0026 mask, FieldMask * out)Converts a FieldMask to the canonical form. more...static voidUnion(const FieldMask \u0026 mask1, const FieldMask \u0026 mask2, FieldMask * out)Creates an union of two FieldMasks. static voidIntersect(const FieldMask \u0026 mask1, const FieldMask \u0026 mask2, FieldMask * out)Creates an intersection of two FieldMasks. template static voidSubtract(const FieldMask \u0026 mask1, const FieldMask \u0026 mask2, FieldMask * out)Subtracts mask2 from mask1 base of type T. static voidSubtract(const Descriptor * descriptor, const FieldMask \u0026 mask1, const FieldMask \u0026 mask2, FieldMask * out)This flavor takes the protobuf type descriptor as an argument. more...static boolIsPathInFieldMask(StringPiece path, const FieldMask \u0026 mask)Returns true if path is covered by the given FieldMask. more...static voidMergeMessageTo(const Message \u0026 source, const FieldMask \u0026 mask, const MergeOptions \u0026 options, Message * destination)Merges fields specified in a FieldMask into another message. static boolTrimMessage(const FieldMask \u0026 mask, Message * message)Removes from 'message' any field that is not represented in the given FieldMask. more...static boolTrimMessage(const FieldMask \u0026 mask, Message * message, const TrimOptions \u0026 options)Removes from 'message' any field that is not represented in the given FieldMask with customized TrimOptions. more... static bool FieldMaskUtil::ToJsonString(\n        const FieldMask \u0026 mask,\n        std::string * out)Converts FieldMask to/from string, formatted according to proto3 JSON spec for FieldMask (e.g., \"fooBar,baz.quz\"). If the field name is not style conforming (i.e., not snake_case when converted to string, or not camelCase when converted from string), the conversion will fail. static bool FieldMaskUtil::GetFieldDescriptors(\n        const Descriptor * descriptor,\n        StringPiece path,\n        std::vector\u003c const FieldDescriptor * \u003e * field_descriptors)Get the descriptors of the fields which the given path from the message descriptor traverses, if field_descriptors is not null. Return false if the path is not valid, and the content of field_descriptors is unspecified. template static void FieldMaskUtil::AddPathToFieldMask(\n        StringPiece path,\n        FieldMask * mask)Adds a path to FieldMask after checking whether the given path is valid. This method check-fails if the path is not a valid path for type T. template static FieldMask FieldMaskUtil::GetFieldMaskForAllFields()Creates a FieldMask with all fields of type T. This FieldMask only contains fields of T but not any sub-message fields. static void FieldMaskUtil::GetFieldMaskForAllFields(\n        const Descriptor * descriptor,\n        FieldMask * out)This flavor takes the protobuf type descriptor as an argument. Useful when the type is not known at compile time. static void FieldMaskUtil::ToCanonicalForm(\n        const FieldMask \u0026 mask,\n        FieldMask * out)Converts a FieldMask to the canonical form. It will: 1. Remove paths that are covered by another path. For example, \"foo.bar\" is covered by \"foo\" and will be removed if \"foo\" is also in the FieldMask. 2. Sort all paths in alphabetical order. static void FieldMaskUtil::Subtract(\n        const Descriptor * descriptor,\n        const FieldMask \u0026 mask1,\n        const FieldMask \u0026 mask2,\n        FieldMask * out)This flavor takes the protobuf type descriptor as an argument. Useful when the type is not known at compile time. static bool FieldMaskUtil::IsPathInFieldMask(\n        StringPiece path,\n        const FieldMask \u0026 mask)Returns true if path is covered by the given FieldMask. Note that path \"foo.bar\" covers all paths like \"foo.bar.baz\", \"foo.bar.quz.x\", etc. Also note that parent paths are not covered by explicit child path, i.e. \"foo.bar\" does NOT cover \"foo\", even if \"bar\" is the only child. static bool FieldMaskUtil::TrimMessage(\n        const FieldMask \u0026 mask,\n        Message * message)Removes from 'message' any field that is not represented in the given FieldMask. If the FieldMask is empty, does nothing. Returns true if the message is modified. static bool FieldMaskUtil::TrimMessage(\n        const FieldMask \u0026 mask,\n        Message * message,\n        const TrimOptions \u0026 options)Removes from 'message' any field that is not represented in the given FieldMask with customized TrimOptions. If the FieldMask is empty, does nothing. Returns true if the message is modified. class FieldMaskUtil::MergeOptions#include \u003cgoogle/protobuf/util/field_mask_util.h\u003e\nnamespace google::protobuf::util\nMembersMergeOptions()voidset_replace_message_fields(bool value)When merging message fields, the default behavior is to merge the content of two message fields together. more...boolreplace_message_fields() constvoidset_replace_repeated_fields(bool value)The default merging behavior will append entries from the source repeated field to the destination repeated field. more...boolreplace_repeated_fields() const void MergeOptions::set_replace_message_fields(\n        bool value)When merging message fields, the default behavior is to merge the content of two message fields together. If you instead want to use the field from the source message to replace the corresponding field in the destination message, set this flag to true. When this flag is set, specified submessage fields that are missing in source will be cleared in destination. void MergeOptions::set_replace_repeated_fields(\n        bool value)The default merging behavior will append entries from the source repeated field to the destination repeated field. If you only want to keep the entries from the source repeated field, set this flag to true. class FieldMaskUtil::TrimOptions#include \u003cgoogle/protobuf/util/field_mask_util.h\u003e\nnamespace google::protobuf::util\nMembersTrimOptions()voidset_keep_required_fields(bool value)When trimming message fields, the default behavior is to trim required fields of the present message if they are not specified in the field mask. more...boolkeep_required_fields() const void TrimOptions::set_keep_required_fields(\n        bool value)When trimming message fields, the default behavior is to trim required fields of the present message if they are not specified in the field mask. If you instead want to keep required fields of the present message even they are not specified in the field mask, set this flag to true. ","categories":"","description":"","excerpt":"field_mask_util.hfield_mask_util.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.util.field_mask_util/","tags":"","title":""},{"body":"json_util.hjson_util.h#include \u003cgoogle/protobuf/util/json_util.h\u003e\nnamespace google::protobuf::util\nUtility functions to convert between protobuf binary format and proto3 JSON format. Classes in this fileJsonParseOptionsJsonPrintOptionsFile MembersThese definitions are not part of any class.typedefJsonPrintOptions JsonOptionsDEPRECATED. Use JsonPrintOptions instead. util::StatusMessageToJsonString(const Message \u0026 message, std::string * output, const JsonOptions \u0026 options)Converts from protobuf message to JSON and appends it to |output|. more...util::StatusMessageToJsonString(const Message \u0026 message, std::string * output)util::StatusJsonStringToMessage(StringPiece input, Message * message, const JsonParseOptions \u0026 options)Converts from JSON to protobuf message. more...util::StatusJsonStringToMessage(StringPiece input, Message * message)util::StatusBinaryToJsonStream(TypeResolver * resolver, const std::string \u0026 type_url, io::ZeroCopyInputStream * binary_input, io::ZeroCopyOutputStream * json_output, const JsonPrintOptions \u0026 options)Converts protobuf binary data to JSON. more...util::StatusBinaryToJsonStream(TypeResolver * resolver, const std::string \u0026 type_url, io::ZeroCopyInputStream * binary_input, io::ZeroCopyOutputStream * json_output)util::StatusBinaryToJsonString(TypeResolver * resolver, const std::string \u0026 type_url, const std::string \u0026 binary_input, std::string * json_output, const JsonPrintOptions \u0026 options)util::StatusBinaryToJsonString(TypeResolver * resolver, const std::string \u0026 type_url, const std::string \u0026 binary_input, std::string * json_output)util::StatusJsonToBinaryStream(TypeResolver * resolver, const std::string \u0026 type_url, io::ZeroCopyInputStream * json_input, io::ZeroCopyOutputStream * binary_output, const JsonParseOptions \u0026 options)Converts JSON data to protobuf binary format. more...util::StatusJsonToBinaryStream(TypeResolver * resolver, const std::string \u0026 type_url, io::ZeroCopyInputStream * json_input, io::ZeroCopyOutputStream * binary_output)util::StatusJsonToBinaryString(TypeResolver * resolver, const std::string \u0026 type_url, StringPiece json_input, std::string * binary_output, const JsonParseOptions \u0026 options)util::StatusJsonToBinaryString(TypeResolver * resolver, const std::string \u0026 type_url, StringPiece json_input, std::string * binary_output) util::Status util::MessageToJsonString(\n        const Message \u0026 message,\n        std::string * output,\n        const JsonOptions \u0026 options)Converts from protobuf message to JSON and appends it to |output|. This is a simple wrapper of BinaryToJsonString(). It will use the DescriptorPool of the passed-in message to resolve Any types. util::Status util::JsonStringToMessage(\n        StringPiece input,\n        Message * message,\n        const JsonParseOptions \u0026 options)Converts from JSON to protobuf message. This is a simple wrapper of JsonStringToBinary(). It will use the DescriptorPool of the passed-in message to resolve Any types. util::Status util::BinaryToJsonStream(\n        TypeResolver * resolver,\n        const std::string \u0026 type_url,\n        io::ZeroCopyInputStream * binary_input,\n        io::ZeroCopyOutputStream * json_output,\n        const JsonPrintOptions \u0026 options)Converts protobuf binary data to JSON. The conversion will fail if: 1. TypeResolver fails to resolve a type. 2. input is not valid protobuf wire format, or conflicts with the type information returned by TypeResolver. Note that unknown fields will be discarded silently. util::Status util::JsonToBinaryStream(\n        TypeResolver * resolver,\n        const std::string \u0026 type_url,\n        io::ZeroCopyInputStream * json_input,\n        io::ZeroCopyOutputStream * binary_output,\n        const JsonParseOptions \u0026 options)Converts JSON data to protobuf binary format. The conversion will fail if: 1. TypeResolver fails to resolve a type. 2. input is not valid JSON format, or conflicts with the type information returned by TypeResolver. struct JsonParseOptions#include \u003cgoogle/protobuf/util/json_util.h\u003e\nnamespace google::protobuf::util\nMembersboolignore_unknown_fieldsWhether to ignore unknown JSON fields during parsing. boolcase_insensitive_enum_parsingIf true, when a lowercase enum value fails to parse, try convert it to UPPER_CASE and see if it matches a valid enum. more...JsonParseOptions() bool JsonParseOptions::case_insensitive_enum_parsingIf true, when a lowercase enum value fails to parse, try convert it to UPPER_CASE and see if it matches a valid enum. WARNING: This option exists only to preserve legacy behavior. Avoid using this option. If your enum needs to support different casing, consider using allow_alias instead. struct JsonPrintOptions#include \u003cgoogle/protobuf/util/json_util.h\u003e\nnamespace google::protobuf::util\nMembersbooladd_whitespaceWhether to add spaces, line breaks and indentation to make the JSON output easy to read. boolalways_print_primitive_fieldsWhether to always print primitive fields. more...boolalways_print_enums_as_intsWhether to always print enums as ints. more...boolpreserve_proto_field_namesWhether to preserve proto field names. JsonPrintOptions() bool JsonPrintOptions::always_print_primitive_fieldsWhether to always print primitive fields. By default proto3 primitive fields with default values will be omitted in JSON output. For example, an int32 field set to 0 will be omitted. Set this flag to true will override the default behavior and print primitive fields regardless of their values. bool JsonPrintOptions::always_print_enums_as_intsWhether to always print enums as ints. By default they are rendered as strings. ","categories":"","description":"","excerpt":"json_util.hjson_util.h#include \u003cgoogle/protobuf/util/json_util.h\u003e …","ref":"/reference/cpp/api-docs/google.protobuf.util.json_util/","tags":"","title":""},{"body":"message_differencer.hmessage_differencer.h#include \u003cgoogle/protobuf/util/message_differencer.h\u003e\nnamespace google::protobuf::util\nThis file defines static methods and classes for comparing Protocol Messages. Aug. 2008: Added Unknown Fields Comparison for messages. Aug. 2009: Added different options to compare repeated fields. Apr. 2010: Moved field comparison to FieldComparator Sep. 2020: Added option to output map keys in path Classes in this fileMessageDifferencerA basic differencer that can be used to determine the differences between two specified Protocol Messages. MessageDifferencer::IgnoreCriteriaAbstract base class from which all IgnoreCriteria derive. MessageDifferencer::MapKeyComparatorMapKeyComparator is used to determine if two elements have the same key when comparing elements of a repeated field as a map. MessageDifferencer::ReporterAbstract base class from which all MessageDifferencer reporters derive. MessageDifferencer::SpecificFieldIdentifies an individual field in a message instance. MessageDifferencer::StreamReporterAn implementation of the MessageDifferencer Reporter that outputs any differences found in human-readable form to the supplied ZeroCopyOutputStream or Printer. MessageDifferencer::UnpackAnyFieldClass for processing Any deserialization. FieldContextThis class provides extra information to the FieldComparator::Compare function. File MembersThese definitions are not part of any class.typedefstd::vector\u003c const FieldDescriptor * \u003e FieldDescriptorArrayDefines a collection of field descriptors. more... typedef util::FieldDescriptorArrayDefines a collection of field descriptors. In case of internal google codebase we are using absl::FixedArray instead of vector. It significantly speeds up proto comparison (by ~30%) by reducing the number of malloc/free operations class MessageDifferencer#include \u003cgoogle/protobuf/util/message_differencer.h\u003e\nnamespace google::protobuf::util\nA basic differencer that can be used to determine the differences between two specified Protocol Messages. If any differences are found, the Compare method will return false, and any differencer reporter specified via ReportDifferencesTo will have its reporting methods called (see below for implementation of the report). Based off of the original ProtocolDifferencer implementation in //net/proto/protocol-differencer.h (Thanks Todd!).\nMessageDifferencer REQUIRES that compared messages be the same type, defined as messages that share the same descriptor. If not, the behavior of this class is undefined.\nPeople disagree on what MessageDifferencer should do when asked to compare messages with different descriptors. Some people think it should always return false. Others expect it to try to look for similar fields and compare them anyway – especially if the descriptors happen to be identical. If we chose either of these behaviors, some set of people would find it surprising, and could end up writing code expecting the other behavior without realizing their error. Therefore, we forbid that usage.\nThis class is implemented based on the proto2 reflection. The performance should be good enough for normal usages. However, for places where the performance is extremely sensitive, there are several alternatives:\nComparing serialized string Downside: false negatives (there are messages that are the same but their serialized strings are different). Equals code generator by compiler plugin (net/proto2/contrib/equals_plugin) Downside: more generated code; maintenance overhead for the additional rule (must be in sync with the original proto_library). Note on handling of google.protobuf.Any: MessageDifferencer automatically unpacks Any::value into a Message and compares its individual fields. Messages encoded in a repeated Any cannot be compared using TreatAsMap.\nNote on thread-safety: MessageDifferencer is not thread-safe. You need to guard it with a lock to use the same MessageDifferencer instance from multiple threads. Note that it's fine to call static comparison methods (like MessageDifferencer::Equals) concurrently, but it's not recommended for performance critical code as it leads to extra allocations. MembersenumMessageFieldComparison more...enumScope more...enumFloatComparisonDEPRECATED. Use FieldComparator::FloatComparison instead. more...enumRepeatedFieldComparison more...DefaultFieldComparator *default_implFieldComparator *basestatic boolEquals(const Message \u0026 message1, const Message \u0026 message2)Determines whether the supplied messages are equal. more...static boolEquivalent(const Message \u0026 message1, const Message \u0026 message2)Determines whether the supplied messages are equivalent. more...static boolApproximatelyEquals(const Message \u0026 message1, const Message \u0026 message2)Determines whether the supplied messages are approximately equal. more...static boolApproximatelyEquivalent(const Message \u0026 message1, const Message \u0026 message2)Determines whether the supplied messages are approximately equivalent. more...explicit MessageDifferencer()To add a Reporter, construct default here, then use ReportDifferencesTo or ReportDifferencesToString. ~MessageDifferencer()voidTreatAsSet(const FieldDescriptor * field)The elements of the given repeated field will be treated as a set for diffing purposes, so different orderings of the same elements will be considered equal. more...voidTreatAsSmartSet(const FieldDescriptor * field)voidTreatAsList(const FieldDescriptor * field)The elements of the given repeated field will be treated as a list for diffing purposes, so different orderings of the same elements will NOT be considered equal. more...voidTreatAsSmartList(const FieldDescriptor * field)Note that the complexity is similar to treating as SET. voidTreatAsMap(const FieldDescriptor * field, const FieldDescriptor * key)The elements of the given repeated field will be treated as a map for diffing purposes, with |key| being the map key. more...voidTreatAsMapWithMultipleFieldsAsKey(const FieldDescriptor * field, const std::vector\u003c const FieldDescriptor * \u003e \u0026 key_fields)Same as TreatAsMap except that this method will use multiple fields as the key in comparison. more...voidTreatAsMapWithMultipleFieldPathsAsKey(const FieldDescriptor * field, const std::vector\u003c std::vector\u003c const FieldDescriptor * \u003e \u003e \u0026 key_field_paths)Same as TreatAsMapWithMultipleFieldsAsKey, except that each of the field do not necessarily need to be a direct subfield. more...voidTreatAsMapUsingKeyComparator(const FieldDescriptor * field, const MapKeyComparator * key_comparator)Uses a custom MapKeyComparator to determine if two elements have the same key when comparing a repeated field as a map. more...MapKeyComparator *CreateMultipleFieldsMapKeyComparator(const std::vector\u003c std::vector\u003c const FieldDescriptor * \u003e \u003e \u0026 key_field_paths)Initiates and returns a new instance of MultipleFieldsMapKeyComparator. voidAddIgnoreCriteria(IgnoreCriteria * ignore_criteria)Add a custom ignore criteria that is evaluated in addition to the ignored fields added with IgnoreField. more...voidIgnoreField(const FieldDescriptor * field)Indicates that any field with the given descriptor should be ignored for the purposes of comparing two messages. more...voidset_field_comparator(FieldComparator * comparator)Sets the field comparator used to determine differences between protocol buffer fields. more...voidSetFractionAndMargin(const FieldDescriptor * field, double fraction, double margin)DEPRECATED. more...voidset_message_field_comparison(MessageFieldComparison comparison)Sets the type of comparison (as defined in the MessageFieldComparison enumeration above) that is used by this differencer when determining how to compare fields in messages. voidset_report_matches(bool report_matches)Tells the differencer whether or not to report matches. more...voidset_report_moves(bool report_moves)Tells the differencer whether or not to report moves (in a set or map repeated field). more...voidset_report_ignores(bool report_ignores)Tells the differencer whether or not to report ignored values. more...voidset_scope(Scope scope)Sets the scope of the comparison (as defined in the Scope enumeration above) that is used by this differencer when determining which fields to compare between the messages. Scopescope()Returns the current scope used by this differencer. voidset_float_comparison(FloatComparison comparison)DEPRECATED. more...voidset_repeated_field_comparison(RepeatedFieldComparison comparison)Sets the type of comparison for repeated field (as defined in the RepeatedFieldComparison enumeration above) that is used by this differencer when compare repeated fields in messages. RepeatedFieldComparisonrepeated_field_comparison()Returns the current repeated field comparison used by this differencer. boolCompare(const Message \u0026 message1, const Message \u0026 message2)Compares the two specified messages, returning true if they are the same, false otherwise. more...boolCompareWithFields(const Message \u0026 message1, const Message \u0026 message2, const std::vector\u003c const FieldDescriptor * \u003e \u0026 message1_fields, const std::vector\u003c const FieldDescriptor * \u003e \u0026 message2_fields)Same as above, except comparing only the list of fields specified by the two vectors of FieldDescriptors. voidReportDifferencesToString(std::string * output)Automatically creates a reporter that will output the differences found (if any) to the specified output string pointer. more...voidReportDifferencesTo(Reporter * reporter)Tells the MessageDifferencer to report differences via the specified reporter. more... enum MessageDifferencer::MessageFieldComparison {\n  EQUAL,\n  EQUIVALENT\n}\nEQUALFields must be present in both messages for the messages to be considered the same. EQUIVALENTFields with default values are considered set for comparison purposes even if not explicitly set in the messages themselves. Unknown fields are ignored. enum MessageDifferencer::Scope {\n  FULL,\n  PARTIAL\n}\nFULLAll fields of both messages are considered in the comparison. PARTIALOnly fields present in the first message are considered; fields set only in the second message will be skipped during comparison. enum MessageDifferencer::FloatComparison {\n  EXACT,\n  APPROXIMATE\n}DEPRECATED. Use FieldComparator::FloatComparison instead. EXACTFloats and doubles are compared exactly. APPROXIMATEFloats and doubles are compared using the MathUtil::AlmostEquals method. enum MessageDifferencer::RepeatedFieldComparison {\n  AS_LIST,\n  AS_SET,\n  AS_SMART_LIST,\n  AS_SMART_SET\n}\nAS_LISTRepeated fields are compared in order. Differing values at the same index are reported using ReportModified(). If the repeated fields have different numbers of elements, the unpaired elements are reported using ReportAdded() or ReportDeleted(). AS_SETTreat all the repeated fields as sets. See TreatAsSet(), as below. AS_SMART_LISTSimilar to AS_SET, but preserve the order and find the longest matching sequence from the first matching element. To use an optimal solution, call SetMatchIndicesForSmartListCallback() to pass it in. AS_SMART_SETSimilar to AS_SET, but match elements with fewest diffs. static bool MessageDifferencer::Equals(\n        const Message \u0026 message1,\n        const Message \u0026 message2)Determines whether the supplied messages are equal. Equality is defined as all fields within the two messages being set to the same value. Primitive fields and strings are compared by value while embedded messages/groups are compared as if via a recursive call. Use Compare() with IgnoreField() if some fields should be ignored in the comparison. Use Compare() with TreatAsSet() if there are repeated fields where ordering does not matter.\nThis method REQUIRES that the two messages have the same Descriptor (message1.GetDescriptor() == message2.GetDescriptor()). static bool MessageDifferencer::Equivalent(\n        const Message \u0026 message1,\n        const Message \u0026 message2)Determines whether the supplied messages are equivalent. Equivalency is defined as all fields within the two messages having the same value. This differs from the Equals method above in that fields with default values are considered set to said value automatically. For details on how default values are defined for each field type, see: ","categories":"","description":"","excerpt":"message_differencer.hmessage_differencer.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.util.message_differencer/","tags":"","title":""},{"body":"time_util.htime_util.h#include \u003cgoogle/protobuf/util/time_util.h\u003e\nnamespace google::protobuf::util\nDefines utilities for the Timestamp and Duration well known types. Classes in this fileTimeUtilUtility functions for Timestamp and Duration. class TimeUtil#include \u003cgoogle/protobuf/util/time_util.h\u003e\nnamespace google::protobuf::util\nUtility functions for Timestamp and Duration. Membersconst int64_tkTimestampMinSeconds = = -62135596800LLThe min/max Timestamp/Duration values we support. more...const int64_tkTimestampMaxSeconds = = 253402300799LLFor \"9999-12-31T23:59:59.999999999Z\". const int64_tkDurationMinSeconds = = -315576000000LLconst int64_tkDurationMaxSeconds = = 315576000000LLstatic std::stringToString(const Timestamp \u0026 timestamp)Converts Timestamp to/from RFC 3339 date string format. more...static boolFromString(const std::string \u0026 value, Timestamp * timestamp)static std::stringToString(const Duration \u0026 duration)Converts Duration to/from string format. more...static boolFromString(const std::string \u0026 value, Duration * timestamp)static TimestampGetCurrentTime()Gets the current UTC time. static TimestampGetEpoch()Returns the Time representing \"1970-01-01 00:00:00\". static DurationNanosecondsToDuration(int64_t nanos)Converts between Duration and integer types. more...static DurationMicrosecondsToDuration(int64_t micros)static DurationMillisecondsToDuration(int64_t millis)static DurationSecondsToDuration(int64_t seconds)static DurationMinutesToDuration(int64_t minutes)static DurationHoursToDuration(int64_t hours)static int64_tDurationToNanoseconds(const Duration \u0026 duration)Result will be truncated towards zero. more...static int64_tDurationToMicroseconds(const Duration \u0026 duration)static int64_tDurationToMilliseconds(const Duration \u0026 duration)static int64_tDurationToSeconds(const Duration \u0026 duration)static int64_tDurationToMinutes(const Duration \u0026 duration)static int64_tDurationToHours(const Duration \u0026 duration)static TimestampNanosecondsToTimestamp(int64_t nanos)Creates Timestamp from integer types. more...static TimestampMicrosecondsToTimestamp(int64_t micros)static TimestampMillisecondsToTimestamp(int64_t millis)static TimestampSecondsToTimestamp(int64_t seconds)static int64_tTimestampToNanoseconds(const Timestamp \u0026 timestamp)Result will be truncated down to the nearest integer value. more...static int64_tTimestampToMicroseconds(const Timestamp \u0026 timestamp)static int64_tTimestampToMilliseconds(const Timestamp \u0026 timestamp)static int64_tTimestampToSeconds(const Timestamp \u0026 timestamp)static TimestampTimeTToTimestamp(time_t value)Conversion to/from other time/date types. more...static time_tTimestampToTimeT(const Timestamp \u0026 value)static TimestampTimevalToTimestamp(const timeval \u0026 value)Conversion to/from timeval. static timevalTimestampToTimeval(const Timestamp \u0026 value)static DurationTimevalToDuration(const timeval \u0026 value)static timevalDurationToTimeval(const Duration \u0026 value) const int64_t TimeUtil::kTimestampMinSeconds = = -62135596800LLThe min/max Timestamp/Duration values we support. For \"0001-01-01T00:00:00Z\". static std::string TimeUtil::ToString(\n        const Timestamp \u0026 timestamp)Converts Timestamp to/from RFC 3339 date string format. Generated output will always be Z-normalized and uses 3, 6 or 9 fractional digits as required to represent the exact time. When parsing, any fractional digits (or none) and any offset are accepted as long as they fit into nano-seconds precision. Note that Timestamp can only represent time from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. Converting a Timestamp outside of this range is undefined behavior. See Example of generated format: \"1972-01-01T10:00:20.021Z\" Example of accepted format: \"1972-01-01T10:00:20.021-05:00\" static std::string TimeUtil::ToString(\n        const Duration \u0026 duration)Converts Duration to/from string format. The string format will contains 3, 6, or 9 fractional digits depending on the precision required to represent the exact Duration value. For example: \"1s\", \"1.010s\", \"1.000000100s\", \"-3.100s\" The range that can be represented by Duration is from -315,576,000,000 to +315,576,000,000 inclusive (in seconds). static Duration TimeUtil::NanosecondsToDuration(\n        int64_t nanos)Converts between Duration and integer types. The behavior is undefined if the input value is not in the valid range of Duration. static int64_t TimeUtil::DurationToNanoseconds(\n        const Duration \u0026 duration)Result will be truncated towards zero. For example, \"-1.5s\" will be truncated to \"-1s\", and \"1.5s\" to \"1s\" when converting to seconds. It's undefined behavior if the input duration is not valid or the result exceeds the range of int64. A duration is not valid if it's not in the valid range of Duration, or have an invalid nanos value (i.e., larger than 999999999, less than -999999999, or have a different sign from the seconds part). static Timestamp TimeUtil::NanosecondsToTimestamp(\n        int64_t nanos)Creates Timestamp from integer types. The integer value indicates the time elapsed from Epoch time. The behavior is undefined if the input value is not in the valid range of Timestamp. static int64_t TimeUtil::TimestampToNanoseconds(\n        const Timestamp \u0026 timestamp)Result will be truncated down to the nearest integer value. For example, with \"1969-12-31T23:59:59.9Z\", TimestampToMilliseconds() returns -100 and TimestampToSeconds() returns -1. It's undefined behavior if the input Timestamp is not valid (i.e., its seconds part or nanos part does not fall in the valid range) or the return value doesn't fit into int64. static Timestamp TimeUtil::TimeTToTimestamp(\n        time_t value)Conversion to/from other time/date types. Note that these types may have a different precision and time range from Timestamp/Duration. When converting to a lower precision type, the value will be truncated to the nearest value that can be represented. If the value is out of the range of the result type, the return value is undefined.\nConversion to/from time_t ","categories":"","description":"","excerpt":"time_util.htime_util.h#include \u003cgoogle/protobuf/util/time_util.h\u003e …","ref":"/reference/cpp/api-docs/google.protobuf.util.time_util/","tags":"","title":""},{"body":"type_resolver.htype_resolver.h#include \u003cgoogle/protobuf/util/type_resolver.h\u003e\nnamespace google::protobuf::util\nDefines a TypeResolver for the Any message. Classes in this fileTypeResolverAbstract interface for a type resolver. class TypeResolver#include \u003cgoogle/protobuf/util/type_resolver.h\u003e\nnamespace google::protobuf::util\nAbstract interface for a type resolver. Implementations of this interface must be thread-safe. MembersTypeResolver()virtual ~TypeResolver()virtual util::StatusResolveMessageType(const std::string \u0026 type_url, google::protobuf::Type * message_type) = 0Resolves a type url for a message type. virtual util::StatusResolveEnumType(const std::string \u0026 type_url, google::protobuf::Enum * enum_type) = 0Resolves a type url for an enum type. ","categories":"","description":"","excerpt":"type_resolver.htype_resolver.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.util.type_resolver/","tags":"","title":""},{"body":"type_resolver_util.htype_resolver_util.h#include \u003cgoogle/protobuf/util/type_resolver_util.h\u003e\nnamespace google::protobuf::util\nDefines utilities for the TypeResolver. Classes in this fileFile MembersThese definitions are not part of any class.TypeResolver *NewTypeResolverForDescriptorPool(const std::string \u0026 url_prefix, const DescriptorPool * pool)Creates a TypeResolver that serves type information in the given descriptor pool. more... TypeResolver * util::NewTypeResolverForDescriptorPool(\n        const std::string \u0026 url_prefix,\n        const DescriptorPool * pool)Creates a TypeResolver that serves type information in the given descriptor pool. Caller takes ownership of the returned TypeResolver. ","categories":"","description":"","excerpt":"type_resolver_util.htype_resolver_util.h#include …","ref":"/reference/cpp/api-docs/google.protobuf.util.type_resolver_util/","tags":"","title":""},{"body":"Java Proto Names Immutable API Message Names The names for protos generated by the immutable API (java_proto_library BUILD target) are listed in the following table.\njava_api_version java_multiple_files java_alt_api_package java_package java_outer_classname Generated full message name 1 true Defined - $java_alt_api_package.$message 1 true Not defined Not defined com.google.protos.$package.proto2api.$message 1 true Not defined Defined $java_package.proto2api.$message 1 false Defined - Not defined $java_alt_api_package.$derived_outer_class.$message 1 false Defined - Defined $java_alt_api_package.$java_outer_classname.$message 1 false Not defined Not defined Not defined com.google.protos.$package.proto2api.$derived_outer_class.$message 1 false Not defined Not defined Defined com.google.protos.$package.proto2api.$java_outer_classname.$message 1 false Not defined Defined Not defined $java_package.proto2api.$derived_outer_class.$message 1 false Not defined Defined Defined $java_package.proto2api.$java_outer_classname.$message 2 true - Not defined - com.google.protos.$package.$message 2 true - Defined - $java_package.$message 2 false - Not defined Not defined com.google.protos.$package.$derived_outer_class.$message 2 false - Not defined Defined com.google.protos.$package.$java_outer_classname.$message 2 false - Defined Not defined $java_package.$derived_outer_class.$message 2 false - Defined Defined $java_package.$java_outer_classname.$message Legend\n- means either setting or not setting the option will not change the generated full message name.\n$message is the actual name of the proto message.\n$package is the name of the proto package. This is the name specified by the package directive in the proto file, which is usually at the top of the file.\n$derived_outer_class is a name generated from the proto file name. Generally it’s computed by removing punctuation from the file name and converting it to CamelCase. For example, if the proto is foo_bar.proto, the $derived_outer_class value is FooBar.\nIf the generated class name would be the same as one of the messages defined in the proto file, derived_outer_class has OuterClass appended to it. For example, if the proto is foo_bar.proto and contains a FooBar message, the $derived_outer_class value is FooBarOuterClass.\nAll other $names are the values of the corresponding proto2 file options defined in the proto file.\nThe recommended set of options is:\noption java_multiple_files = true; option java_outer_classname = \"{UpperCamelCaseFilename}Proto\"; Mutable API Message Names The names for protos generated by the mutable API are outlined in the following sections.\nNote Java mutable API names will be generated only when the java_mutable_proto_library target is built. Generated Proto API Version Warning Java proto1 is deprecated. Avoid any settings that will generate that version. java_api_version java_mutable_api java_enable_dual_generate_mutable_api API version - - true proto1, proto2 mutable 1 - false proto1 2 true false proto2 mutable 2 false false proto1 Proto2 Message Names java_api_version (java_multiple_files, java_multiple_files_mutable_package) java_package java_outer_classname java_alt_api_package Proto2 Mutable message name - (true, defined) - - - $java_multiple_files_mutable_package.$message 1 !(true, defined) Undefined Undefined Undefined com.google.protos.$package.proto2api.Mutable$Filename.$message 1 !(true, defined) Undefined Undefined Defined $java_alt_api_package.Mutable$Filename.$message 1 !(true, defined) Undefined Defined Undefined com.google.protos.$package.proto2api.Mutable$java_outer_classname.$message 1 !(true, defined) Undefined Defined Defined $java_alt_api_package.Mutable$java_outer_classname.$message 1 !(true, defined) Defined Undefined Undefined $java_package.proto2api.Mutable$Filename.$message 1 !(true, defined) Defined Undefined Defined $java_alt_api_package.Mutable$Filename.$message 1 !(true, defined) Defined Defined Undefined $java_package.proto2api.Mutable$java_outer_classname.$message 1 !(true, defined) Defined Defined Defined $java_alt_api_package.Mutable$java_outer_classname.$message 2 !(true, defined) Undefined Undefined - com.google.protos.$package.Mutable$Filename.$message 2 !(true, defined) Undefined Defined - com.google.protos.$package..Mutable$java_outer_classname.$message 2 !(true, defined) Defined Undefined - $java_package.Mutable$Filename.$message 2 !(true, defined) Defined Defined - $java_package.Mutable$java_outer_classname.$message Legend\n- means either setting or not setting the option will not change the generated full message name. $message is the actual name of the proto message. All other $names are the values of the corresponding proto2 file options defined in the proto file. Proto1 Message Names Warning Java proto1 is deprecated. The following table is provided for informational purposes only. java_api_version java_multiple_files java_package java_outer_classname java_alt_api_package Proto1 message name 1 true Undefined - - com.google.protos.$package.$message 1 true Defined - - $java_package.$message 1 false Undefined Defined - com.google.protos.$package.$java_outer_class.$message 1 false Undefined Undefined - com.google.protos.$package.$message 1 false Defined Defined - $java_package.$java_outer_class.$message 1 false Defined Undefined - $java_package.$message 2 true Undefined - Undefined com.google.protos.$package.proto1api.$message 2 true Defined - Undefined $java_package.proto1api.$message 2 false Undefined Defined Undefined com.google.protos.$package.proto1api.$java_outer_class.$message 2 false Undefined Undefined Undefined com.google.protos.$package.proto1api.$message 2 false Defined Defined Undefined $java_package.proto1api.$java_outer_class.$message 2 false Defined Undefined Undefined $java_package.proto1api.$message 2 true Undefined - Defined com.google.protos.$package.$java_alt_api_package.$message 2 true Defined - Defined $java_package.$java_alt_api_package.$message 2 false Undefined Defined Defined com.google.protos.$package.$java_alt_api_package.$java_outer_class.$message 2 false Undefined Undefined Defined com.google.protos.$package.$java_alt_api_package.$message 2 false Defined Defined Defined $java_package.$java_alt_api_package.$java_outer_class.$message 2 false Defined Undefined Defined $java_package.$java_alt_api_package.$message Legend\n- means either setting or not setting the option will not change the generated full message name. $message is the actual name of the proto message. All other $names are the values of the corresponding proto2 file options defined in the proto file. ","categories":"","description":"","excerpt":"Java Proto Names Immutable API Message Names The names for protos …","ref":"/reference/java/java-proto-names/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/DslList\nDslList [JVM] Content fun \u003cE\u003e DslList(delegate: List\u003cE\u003e)\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/DslList\nDslList …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/-dsl-list/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList\nDslList [JVM] class DslList\u003cE, P : DslProxy\u003econstructor(delegate: List\u003cE\u003e) : List\u003cE\u003e\nA simple wrapper around a List with an extra generic parameter that can be used to disambiguate extension methods.\nThis class is used by Kotlin protocol buffer extensions, and its constructor is public only because generated message code is in a different compilation unit. Others should not use this class directly in any way. Constructors Name Summary DslList [JVM] fun \u003cE\u003e DslList(delegate: List\u003cE\u003e) Functions Name Summary contains [JVM] Content open operator override fun contains(element: E): Boolean containsAll [JVM] Content open override fun containsAll(elements: Collection\u003cE\u003e): Boolean equals [JVM] Content open operator override fun equals(other: Any?): Boolean forEach [JVM] Content open fun forEach(p0: Consumer\u003cin E\u003e) get [JVM] Content open operator override fun get(index: Int): E hashCode [JVM] Content open override fun hashCode(): Int indexOf [JVM] Content open override fun indexOf(element: E): Int isEmpty [JVM] Content open override fun isEmpty(): Boolean iterator [JVM] Content open operator override fun iterator(): Iterator\u003cE\u003e lastIndexOf [JVM] Content open override fun lastIndexOf(element: E): Int listIterator [JVM] Content open override fun listIterator(): ListIterator\u003cE\u003e open override fun listIterator(index: Int): ListIterator\u003cE\u003e parallelStream [JVM] Content open fun parallelStream(): Stream\u003cE\u003e spliterator [JVM] Content open override fun spliterator(): Spliterator\u003cE\u003e stream [JVM] Content open fun stream(): Stream\u003cE\u003e subList [JVM] Content open override fun subList(fromIndex: Int, toIndex: Int): List\u003cE\u003e toArray [JVM] Content open fun \u003cT : Any\u003e toArray(p0: IntFunction\u003cArray\u003cT»)~~~~: Array\u003cT\u003e toString [JVM] Content open override fun toString(): String Properties Name Summary size [JVM] open override val size: Int ","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList\nDslList [JVM] …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/equals\nequals [JVM] Content open operator override fun equals(other: Any?): Boolean\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/equals\nequals …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/equals/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/hashCode\nhashCode [JVM] Content open override fun hashCode(): Int\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/hashCode\nhashCode …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/hash-code/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/iterator\niterator [JVM] Content open operator override fun iterator(): Iterator\u003cE\u003e\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/iterator\niterator …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/iterator/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/listIterator\nlistIterator [JVM] Content open override fun listIterator(): ListIterator\u003cE\u003e open override fun listIterator(index: Int): ListIterator\u003cE\u003e\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/listIterator …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/list-iterator/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/toString\ntoString [JVM] Content open override fun toString(): String\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslList/toString\ntoString …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-list/to-string/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/DslMap\nDslMap [JVM] Content fun \u003cK, V\u003e DslMap(delegate: Map\u003cK, V\u003e)\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/DslMap\nDslMap …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/-dsl-map/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap\nDslMap [JVM] class DslMap\u003cK, V, P : DslProxy\u003econstructor(delegate: Map\u003cK, V\u003e) : Map\u003cK, V\u003e\nA simple wrapper around a Map with an extra generic parameter that can be used to disambiguate extension methods.\nThis class is used by Kotlin protocol buffer extensions, and its constructor is public only because generated message code is in a different compilation unit. Others should not use this class directly in any way. Constructors Name Summary [DslMap]) [JVM] fun \u003cK, V\u003e DslMap(delegate: Map\u003cK, V\u003e) Functions Name Summary containsKey [JVM] Content open override fun containsKey(key: K): Boolean containsValue [JVM] Content open override fun containsValue(value: V): Boolean equals [JVM] Content open operator override fun equals(other: Any?): Boolean forEach [JVM] Content open fun forEach(p0: BiConsumer\u003cin K, in V\u003e) get [JVM] Content open operator override fun get(key: K): V? getOrDefault [JVM] Content open fun getOrDefault(key: K, defaultValue: V): V hashCode [JVM] Content open override fun hashCode(): Int isEmpty [JVM] Content open override fun isEmpty(): Boolean toString [JVM] Content open override fun toString(): String Properties Name Summary entries [JVM] open override val entries: Set\u003cMap.Entry\u003cK, V» keys [JVM] open override val keys: Set\u003cK\u003e size [JVM] open override val size: Int values [JVM] open override val values: Collection\u003cV\u003e ","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap\nDslMap [JVM] class …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/entries\nentries [JVM] Content open override val entries: Set\u003cMap.Entry\u003cK, V»\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/entries\nentries …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/entries/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/equals\nequals [JVM] Content open operator override fun equals(other: Any?): Boolean\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/equals\nequals …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/equals/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/hashCode\nhashCode [JVM] Content open override fun hashCode(): Int\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/hashCode\nhashCode …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/hash-code/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/keys\nkeys [JVM] Content open override val keys: Set\u003cK\u003e\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/keys\nkeys [JVM] …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/keys/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/toString\ntoString [JVM] Content open override fun toString(): String\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/toString\ntoString …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/to-string/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/values\nvalues [JVM] Content open override val values: Collection\u003cV\u003e\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslMap/values\nvalues …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-map/values/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/DslProxy\nDslProxy [JVM] abstract class DslProxy\nA type meaningful only for its existence, never intended to be instantiated. For example, a DslList\u003cInt, FooProxy\u003e can be given different extension methods than a DslList\u003cInt, BarProxy\u003e.\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/DslProxy\nDslProxy [JVM] …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-dsl-proxy/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/ExtensionList\nExtensionList [JVM] Content fun \u003cE, M : MessageLite\u003e ExtensionList(extension: ExtensionLite\u003cM, List\u003cE», delegate: List\u003cE\u003e)\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/ExtensionLi …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/-extension-list/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList\nExtensionList [JVM] class ExtensionList\u003cE, M : MessageLite\u003econstructor(extension: ExtensionLite\u003cM, List\u003cE», delegate: List\u003cE\u003e) : List\u003cE\u003e\nImplementation for ExtensionList and ExtensionListLite. Like DslList, represents an unmodifiable view of a repeated proto field – in this case, an extension field – but supports querying the extension.\nConstructors Name Summary ExtensionList [JVM] fun \u003cE, M : MessageLite\u003e ExtensionList(extension: ExtensionLite\u003cM, List\u003cE\u003e\u003e, delegate: List\u003cE\u003e) Functions Name Summary contains [JVM] Content open operator override fun contains(element: E): Boolean containsAll [JVM] Content open override fun containsAll(elements: Collection\u003cE\u003e): Boolean equals [JVM] Content open operator override fun equals(other: Any?): Boolean forEach [JVM] Content open fun forEach(p0: Consumer\u003cin E\u003e) get [JVM] Content open operator override fun get(index: Int): E hashCode [JVM] Content open override fun hashCode(): Int indexOf [JVM] Content open override fun indexOf(element: E): Int isEmpty [JVM] Content open override fun isEmpty(): Boolean iterator [JVM] Content open operator override fun iterator(): Iterator\u003cE\u003e lastIndexOf [JVM] Content open override fun lastIndexOf(element: E): Int listIterator [JVM] Content open override fun listIterator(): ListIterator\u003cE\u003e open override fun listIterator(index: Int): ListIterator\u003cE\u003e parallelStream [JVM] Content open fun parallelStream(): Stream\u003cE\u003e spliterator [JVM] Content open override fun spliterator(): Spliterator\u003cE\u003e stream [JVM] Content open fun stream(): Stream\u003cE\u003e subList [JVM] Content open override fun subList(fromIndex: Int, toIndex: Int): List\u003cE\u003e toArray [JVM] Content open fun \u003cT : Any\u003e toArray(p0: IntFunction\u003cArray\u003cT»)~~~~: Array\u003cT\u003e toString [JVM] Content open override fun toString(): String Properties Name Summary extension [JVM] val extension: ExtensionLite\u003cM, List\u003cE» size [JVM] open override val size: Int ","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/equals\nequals [JVM] Content open operator override fun equals(other: Any?): Boolean\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/equals …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/equals/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/extension\nextension [JVM] Content val extension: ExtensionLite\u003cM, List\u003cE»\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/extension …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/extension/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/hashCode\nhashCode [JVM] Content open override fun hashCode(): Int\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/hashCode …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/hash-code/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/iterator\niterator [JVM] Content open operator override fun iterator(): Iterator\u003cE\u003e\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/iterator …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/iterator/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/listIterator\nlistIterator [JVM] Content open override fun listIterator(): ListIterator\u003cE\u003e open override fun listIterator(index: Int): ListIterator\u003cE\u003e\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/listIterato …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/list-iterator/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/toString\ntoString [JVM] Content open override fun toString(): String\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/ExtensionList/toString …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-extension-list/to-string/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/OnlyForUseByGeneratedProtoCode/OnlyForUseByGeneratedProtoCode\nOnlyForUseByGeneratedProtoCode [JVM] Content fun OnlyForUseByGeneratedProtoCode()\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/OnlyForUseByGeneratedProt …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-only-for-use-by-generated-proto-code/-only-for-use-by-generated-proto-code/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/OnlyForUseByGeneratedProtoCode\nOnlyForUseByGeneratedProtoCode [JVM] @Target(allowedTargets = [AnnotationTarget.CONSTRUCTOR, AnnotationTarget.ANNOTATION_CLASS])\nannotation class OnlyForUseByGeneratedProtoCode\nOpt-in annotation to make it difficult to accidentally use APIs only intended for use by proto generated code. See https://kotlinlang.org/docs/reference/opt-in-requirements.html for details on how this API works.\nConstructors Name Summary OnlyForUseByGeneratedProtoCode [JVM] fun OnlyForUseByGeneratedProtoCode() ","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/OnlyForUseByGeneratedProt …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-only-for-use-by-generated-proto-code/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/ProtoDslMarker/ProtoDslMarker\nProtoDslMarker [JVM] Content fun ProtoDslMarker()\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/ProtoDslMarker/ProtoDslMa …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-proto-dsl-marker/-proto-dsl-marker/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/ProtoDslMarker\nProtoDslMarker [JVM] @DslMarker() @Target(allowedTargets = [AnnotationTarget.CLASS])\nannotation class ProtoDslMarker\nIndicates an API that is part of a DSL to generate protocol buffer messages.\nConstructors Name Summary ProtoDslMarker [JVM] fun ProtoDslMarker() ","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/ProtoDslMarker …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/-proto-dsl-marker/","tags":"","title":""},{"body":"Package com.google.protobuf.kotlin //protobuf-kotlin/com.google.protobuf.kotlin\nTypes Name Summary DslList [JVM] Content class DslList\u003cE, P : DslProxy\u003econstructor(delegate: List\u003cE\u003e) : List\u003cE\u003e A simple wrapper around a List with an extra generic parameter that can be used to disambiguate extension methods. DslMap [JVM] Content class DslMap\u003cK, V, P : DslProxy\u003econstructor(delegate: Map\u003cK, V\u003e) : Map\u003cK, V\u003e A simple wrapper around a Map with an extra generic parameter that can be used to disambiguate extension methods. DslProxy [JVM] Content abstract class DslProxy A type meaningful only for its existence, never intended to be instantiated. ExtensionList [JVM] Content class ExtensionList\u003cE, M : MessageLite\u003econstructor(extension: ExtensionLite\u003cM, List\u003cE», delegate: List\u003cE\u003e) : List\u003cE\u003e Implementation for ExtensionList and ExtensionListLite. OnlyForUseByGeneratedProtoCode [JVM] Content @Target(allowedTargets = [AnnotationTarget.CONSTRUCTOR, AnnotationTarget.ANNOTATION_CLASS]) annotation class OnlyForUseByGeneratedProtoCode Opt-in annotation to make it difficult to accidentally use APIs only intended for use by proto generated code. ProtoDslMarker [JVM] Content @DslMarker() @Target(allowedTargets = [AnnotationTarget.CLASS]) annotation class ProtoDslMarker Indicates an API that is part of a DSL to generate protocol buffer messages. Functions Name Summary contains [JVM] Content operator fun \u003cM : GeneratedMessageV3.ExtendableMessage\u003cM\u003e, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder\u003cM» MorBT.contains(extension: ExtensionLite\u003cM, *\u003e): Boolean Returns true if the specified extension is set on this builder. get [JVM] Content operator fun \u003cM : GeneratedMessageV3.ExtendableMessage\u003cM\u003e, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder\u003cM\u003e, T : Any\u003e MorBT.get(extension: ExtensionLite\u003cM, T\u003e): T Gets the current value of the proto extension. [JVM] Content operator fun ByteString.get(index: Int): Byte Gets the byte at index. isA [JVM] Content inline fun \u003cT : Message\u003e Any.isA(): Boolean Returns true if this com.google.protobuf.Any contains a message of type T. plus [JVM] Content operator fun ByteString.plus(other: ByteString): ByteString Concatenates the given ByteString to this one. set [JVM] Content operator fun \u003cM : GeneratedMessageV3.ExtendableMessage\u003cM\u003e, B : GeneratedMessageV3.ExtendableBuilder\u003cM, B\u003e, T : Any\u003e B.set(extension: ExtensionLite\u003cM, T\u003e, value: T) Sets the current value of the proto extension in this builder. toByteString [JVM] Content fun ByteBuffer.toByteString(): ByteString Copies the remaining bytes from this ByteBuffer to a ByteString. [JVM] Content fun ByteArray.toByteString(): ByteString Returns a copy of this ByteArray as an immutable ByteString. toByteStringUtf8 [JVM] Content fun String.toByteStringUtf8(): ByteString Encodes this String into a sequence of UTF-8 bytes and returns the result as a ByteString. unpack [JVM] Content inline fun \u003cT : Message\u003e Any.unpack(): T Returns the message of type T encoded in this com.google.protobuf.Any. ","categories":"","description":"","excerpt":"Package com.google.protobuf.kotlin …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/contains\ncontains [JVM] Content operator fun \u003cM : GeneratedMessageV3.ExtendableMessage\u003cM\u003e, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder\u003cM» MorBT.contains(extension: ExtensionLite\u003cM, *\u003e): Boolean\nReturns true if the specified extension is set on this builder.\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/contains\ncontains [JVM] …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/contains/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/get\nget [JVM] Content operator fun ByteString.get(index: Int): Byte\nGets the byte at index.\n[JVM] Content operator fun \u003cM : GeneratedMessageV3.ExtendableMessage\u003cM\u003e, MorBT : GeneratedMessageV3.ExtendableMessageOrBuilder\u003cM\u003e, T : Any\u003e MorBT.get(extension: ExtensionLite\u003cM, T\u003e): T\nGets the current value of the proto extension.\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/get\nget [JVM] Content …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/get/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/isA\nisA [JVM] Content inline fun \u003cT : Message\u003e Any.isA(): Boolean\nReturns true if this com.google.protobuf.Any contains a message of type T.\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/isA\nisA [JVM] Content …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/is-a/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/plus\nplus [JVM] Content operator fun ByteString.plus(other: ByteString): ByteString \\\nConcatenates the given ByteString to this one.\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/plus\nplus [JVM] Content …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/plus/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/set\nset [JVM] Content operator fun \u003cM : GeneratedMessageV3.ExtendableMessage\u003cM\u003e, B : GeneratedMessageV3.ExtendableBuilder\u003cM, B\u003e, T : Any\u003e B.set(extension: ExtensionLite\u003cM, T\u003e, value: T)\nSets the current value of the proto extension in this builder.\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/set\nset [JVM] Content …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/set/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/toByteStringUtf8\ntoByteStringUtf8 [JVM] Content fun String.toByteStringUtf8(): ByteString\nEncodes this String into a sequence of UTF-8 bytes and returns the result as a ByteString.\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/toByteStringUtf8 …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string-utf8/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/toByteString\ntoByteString [JVM] Content fun ByteArray.toByteString(): ByteString\nReturns a copy of this ByteArray as an immutable ByteString.\n[JVM] Content fun ByteBuffer.toByteString(): ByteString\nCopies the remaining bytes from this ByteBuffer to a ByteString.\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/toByteString\ntoByteString …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/to-byte-string/","tags":"","title":""},{"body":"//protobuf-kotlin/com.google.protobuf.kotlin/unpack\nunpack [JVM] Content inline fun \u003cT : Message\u003e Any.unpack(): T\nReturns the message of type T encoded in this com.google.protobuf.Any.\nThrows | | ——————————————————————————————————————————- | — InvalidProtocolBufferException | if this com.google.protobuf.Any does not contain a T message.\n","categories":"","description":"","excerpt":"//protobuf-kotlin/com.google.protobuf.kotlin/unpack\nunpack [JVM] …","ref":"/reference/kotlin/api-docs/protobuf-kotlin/com.google.protobuf.kotlin/unpack/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"}]