<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.114.1"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Protocol Buffers Documentation</title><meta name=description content="zero_copy_stream.hzero_copy_stream.h#include &amp;lt;google/protobuf/io/zero_copy_stream.h&amp;gt;
namespace google::protobuf::io
This file contains the ZeroCopyInputStream and ZeroCopyOutputStream interfaces, which represent abstract I/O streams to and from which protocol buffers can be read and written. For a few simple implementations of these interfaces, see zero_copy_stream_impl.h.
These interfaces are different from classic I/O streams in that they try to minimize the amount of data copying that needs to be done. To accomplish this, responsibility for allocating buffers is moved to the stream object, rather than being the responsibility of the caller."><meta property="og:title" content><meta property="og:description" content="zero_copy_stream.hzero_copy_stream.h#include <google/protobuf/io/zero_copy_stream.h>
namespace google::protobuf::io
This file contains the ZeroCopyInputStream and ZeroCopyOutputStream interfaces, which represent abstract I/O streams to and from which protocol buffers can be read and written. For a few simple implementations of these interfaces, see zero_copy_stream_impl.h.
These interfaces are different from classic I/O streams in that they try to minimize the amount of data copying that needs to be done. To accomplish this, responsibility for allocating buffers is moved to the stream object, rather than being the responsibility of the caller."><meta property="og:type" content="article"><meta property="og:url" content="https://protobuf.dev/reference/cpp/api-docs/google.protobuf.io.zero_copy_stream/"><meta property="article:section" content="reference"><meta itemprop=name content><meta itemprop=description content="zero_copy_stream.hzero_copy_stream.h#include <google/protobuf/io/zero_copy_stream.h>
namespace google::protobuf::io
This file contains the ZeroCopyInputStream and ZeroCopyOutputStream interfaces, which represent abstract I/O streams to and from which protocol buffers can be read and written. For a few simple implementations of these interfaces, see zero_copy_stream_impl.h.
These interfaces are different from classic I/O streams in that they try to minimize the amount of data copying that needs to be done. To accomplish this, responsibility for allocating buffers is moved to the stream object, rather than being the responsibility of the caller."><meta itemprop=wordCount content="1251"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="zero_copy_stream.hzero_copy_stream.h#include <google/protobuf/io/zero_copy_stream.h>
namespace google::protobuf::io
This file contains the ZeroCopyInputStream and ZeroCopyOutputStream interfaces, which represent abstract I/O streams to and from which protocol buffers can be read and written. For a few simple implementations of these interfaces, see zero_copy_stream_impl.h.
These interfaces are different from classic I/O streams in that they try to minimize the amount of data copying that needs to be done. To accomplish this, responsibility for allocating buffers is moved to the stream object, rather than being the responsibility of the caller."><link rel=preload href=/scss/main.min.43ad6541a45f31cd03dd1066a29ba2595ef582b492c6241a2288367893840e77.css as=style><link href=/scss/main.min.43ad6541a45f31cd03dd1066a29ba2595ef582b492c6241a2288367893840e77.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5L8P8GRN4Y"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5L8P8GRN4Y")}</script></head><body class=td-page><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>Protocol Buffers Documentation</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"></ul></div><div class="navbar-nav d-none d-lg-block"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off></div></div></nav></header><div class="container-fluid td-default td-outer"><main role=main class=td-main><html devsite><head><title>zero_copy_stream.h</title><meta name=project_path value=/protocol-buffers/_project.yaml><meta name=book_path value=/protocol-buffers/_book.yaml></head><body><h1>zero_copy_stream.h</h1><p><code>#include &lt;google/protobuf/io/zero_copy_stream.h><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>This file contains the <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a> and <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a> interfaces, which represent abstract I/O streams to and from which protocol buffers can be read and written.</p><p>For a few simple implementations of these interfaces, see <a href=google.protobuf.io.zero_copy_stream_impl>zero_copy_stream_impl.h</a>.</p><p>These interfaces are different from classic I/O streams in that they try to minimize the amount of data copying that needs to be done. To accomplish this, responsibility for allocating buffers is moved to the stream object, rather than being the responsibility of the caller. So, the stream can return a buffer which actually points directly into the final data structure where the bytes are to be stored, and the caller can interact directly with that buffer, eliminating an intermediate copy operation.</p><p>As an example, consider the common case in which you are reading bytes from an array that is already in memory (or perhaps an mmap()ed file). With classic I/O streams, you would do something like:</p><pre>char buffer[[]BUFFER_SIZE];
input-&gt;Read(buffer, BUFFER_SIZE);
DoSomething(buffer, BUFFER_SIZE);</pre><p>Then, the stream basically just calls memcpy() to copy the data from the array into your buffer. With a <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a>, you would do this instead:</p><pre>const void* buffer;
int size;
input-&gt;Next(&amp;buffer, &amp;size);
DoSomething(buffer, size);</pre><p>Here, no copy is performed. The input stream returns a pointer directly into the backing array, and the caller ends up reading directly from it.</p><p>If you want to be able to read the old-fashion way, you can create a <a href=google.protobuf.io.coded_stream#CodedInputStream>CodedInputStream</a> or <a href=google.protobuf.io.coded_stream#CodedOutputStream>CodedOutputStream</a> wrapping these objects and use their ReadRaw()/WriteRaw() methods. These will, of course, add a copy step, but Coded*Stream will handle buffering so at least it will be reasonably efficient.</p><p><a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream>ZeroCopyInputStream</a> example:</p><pre>// Read in a file and print its contents to stdout.
int fd = open("myfile", O_RDONLY);
ZeroCopyInputStream* input = new FileInputStream(fd);
<p>const void* buffer;
int size;
while (input-&gt;Next(&amp;buffer, &amp;size)) {
cout.write(buffer, size);
}</p>
<p>delete input;
close(fd);</pre></p><p><a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream>ZeroCopyOutputStream</a> example:</p><pre>// Copy the contents of "infile" to "outfile", using plain read() for
// "infile" but a ZeroCopyOutputStream for "outfile".
int infd = open("infile", O_RDONLY);
int outfd = open("outfile", O_WRONLY);
ZeroCopyOutputStream* output = new FileOutputStream(outfd);
<p>void* buffer;
int size;
while (output-&gt;Next(&amp;buffer, &amp;size)) {
int bytes = read(infd, buffer, size);
if (bytes &lt; size) {
// Reached EOF.
output-&gt;BackUp(size - bytes);
break;
}
}</p>
<p>delete output;
close(infd);
close(outfd);</pre></p><table width=100%><tr><th colspan=2><h3 style=margin-top:4px>Classes in this file</h3></th></tr><tr><td><div><code><a href=#ZeroCopyInputStream>ZeroCopyInputStream</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Abstract interface similar to an input stream but designed to minimize copying.</div></td></tr><tr><td><div><code><a href=#ZeroCopyOutputStream>ZeroCopyOutputStream</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Abstract interface similar to an output stream but designed to minimize copying.</div></td></tr></table><h2 id=ZeroCopyInputStream>class ZeroCopyInputStream</h2><p><code>#include &lt;<a href=#>google/protobuf/io/zero_copy_stream.h</a>><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>Abstract interface similar to an input stream but designed to minimize copying.</p><p>Known subclasses:</p><ul><li><code><a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayInputStream>ArrayInputStream</a></code></li><li><code><a href=google.protobuf.io.zero_copy_stream_impl#ConcatenatingInputStream>ConcatenatingInputStream</a></code></li><li><code><a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingInputStreamAdaptor>CopyingInputStreamAdaptor</a></code></li><li><code><a href=google.protobuf.io.zero_copy_stream_impl#FileInputStream>FileInputStream</a></code></li><li><code><a href=google.protobuf.io.zero_copy_stream_impl#IstreamInputStream>IstreamInputStream</a></code></li><li><code><a href=google.protobuf.io.zero_copy_stream_impl_lite#LimitingInputStream>LimitingInputStream</a></code></li></ul><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=ZeroCopyInputStream.ZeroCopyInputStream><div style=padding-left:16px;text-indent:-16px><code><b>ZeroCopyInputStream</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual</code></td><td style=border-left-width:0 id=ZeroCopyInputStream.~ZeroCopyInputStream><div style=padding-left:16px;text-indent:-16px><code><b>~ZeroCopyInputStream</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=ZeroCopyInputStream.Next><div style=padding-left:16px;text-indent:-16px><code><b>Next</b>(const void ** data, int * size) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Obtains a chunk of data from the stream. <a href=#ZeroCopyInputStream.Next.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=ZeroCopyInputStream.BackUp><div style=padding-left:16px;text-indent:-16px><code><b>BackUp</b>(int count) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Backs up a number of bytes, so that the next call to <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.Next>Next()</a> returns data again that was already returned by the last call to <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.Next>Next()</a>. <a href=#ZeroCopyInputStream.BackUp.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=ZeroCopyInputStream.Skip><div style=padding-left:16px;text-indent:-16px><code><b>Skip</b>(int count) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Skips a number of bytes. <a href=#ZeroCopyInputStream.Skip.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual int64_t</code></td><td style=border-left-width:0 id=ZeroCopyInputStream.ByteCount><div style=padding-left:16px;text-indent:-16px><code><b>ByteCount</b>() const = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Returns the total number of bytes read since this object was created.</div></td></tr></table><hr><h3 id=ZeroCopyInputStream.Next.details><code>virtual bool ZeroCopyInputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size) = 0</code></h3><div style=margin-left:16px><p>Obtains a chunk of data from the stream.</p><p>Preconditions:</p><ul><li>"size" and "data" are not NULL.</li></ul><p>Postconditions:</p><ul><li>If the returned value is false, there is no more data to return or an error occurred. All errors are permanent.</li><li>Otherwise, "size" points to the actual number of bytes read and "data" points to a pointer to a buffer containing these bytes.</li><li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li><li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.Next>Next()</a> eventually yields a buffer with non-zero size.</li></ul></div><hr><h3 id=ZeroCopyInputStream.BackUp.details><code>virtual void ZeroCopyInputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count) = 0</code></h3><div style=margin-left:16px><p>Backs up a number of bytes, so that the next call to <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.Next>Next()</a> returns data again that was already returned by the last call to <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.Next>Next()</a>.</p><p>This is useful when writing procedures that are only supposed to read up to a certain point in the input, then return. If <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.Next>Next()</a> returns a buffer that goes beyond what you wanted to read, you can use <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.BackUp>BackUp()</a> to return to the point where you intended to finish.</p><p>Preconditions:</p><ul><li>The last method called must have been <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.Next>Next()</a>.</li><li>count must be less than or equal to the size of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.Next>Next()</a>.</li></ul><p>Postconditions:</p><ul><li>The last "count" bytes of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.Next>Next()</a> will be pushed back into the stream. Subsequent calls to <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.Next>Next()</a> will return the same data again before producing new data.</li></ul></div><hr><h3 id=ZeroCopyInputStream.Skip.details><code>virtual bool ZeroCopyInputStream::Skip(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count) = 0</code></h3><div style=margin-left:16px><p>Skips a number of bytes.</p><p>Returns false if the end of the stream is reached or some input error occurred. In the end-of-stream case, the stream is advanced to the end of the stream (so <a href=google.protobuf.io.zero_copy_stream#ZeroCopyInputStream.ByteCount>ByteCount()</a> will return the total size of the stream).</p></div><h2 id=ZeroCopyOutputStream>class ZeroCopyOutputStream</h2><p><code>#include &lt;<a href=#>google/protobuf/io/zero_copy_stream.h</a>><br>namespace <a href=#google.protobuf.io>google::protobuf::io</a></code></p><p>Abstract interface similar to an output stream but designed to minimize copying.</p><p>Known subclasses:</p><ul><li><code><a href=google.protobuf.io.zero_copy_stream_impl_lite#ArrayOutputStream>ArrayOutputStream</a></code></li><li><code><a href=google.protobuf.io.zero_copy_stream_impl_lite#CopyingOutputStreamAdaptor>CopyingOutputStreamAdaptor</a></code></li><li><code><a href=google.protobuf.io.zero_copy_stream_impl#OstreamOutputStream>OstreamOutputStream</a></code></li><li><code><a href=google.protobuf.io.zero_copy_stream_impl_lite#StringOutputStream>StringOutputStream</a></code></li></ul><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=ZeroCopyOutputStream.ZeroCopyOutputStream><div style=padding-left:16px;text-indent:-16px><code><b>ZeroCopyOutputStream</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual</code></td><td style=border-left-width:0 id=ZeroCopyOutputStream.~ZeroCopyOutputStream><div style=padding-left:16px;text-indent:-16px><code><b>~ZeroCopyOutputStream</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=ZeroCopyOutputStream.Next><div style=padding-left:16px;text-indent:-16px><code><b>Next</b>(void ** data, int * size) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Obtains a buffer into which data can be written. <a href=#ZeroCopyOutputStream.Next.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=ZeroCopyOutputStream.BackUp><div style=padding-left:16px;text-indent:-16px><code><b>BackUp</b>(int count) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Backs up a number of bytes, so that the end of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream.Next>Next()</a> is not actually written. <a href=#ZeroCopyOutputStream.BackUp.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual int64_t</code></td><td style=border-left-width:0 id=ZeroCopyOutputStream.ByteCount><div style=padding-left:16px;text-indent:-16px><code><b>ByteCount</b>() const = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Returns the total number of bytes written since this object was created.</div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=ZeroCopyOutputStream.WriteAliasedRaw><div style=padding-left:16px;text-indent:-16px><code><b>WriteAliasedRaw</b>(const void * data, int size)</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Write a given chunk of data to the output. <a href=#ZeroCopyOutputStream.WriteAliasedRaw.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=ZeroCopyOutputStream.AllowsAliasing><div style=padding-left:16px;text-indent:-16px><code><b>AllowsAliasing</b>() const</code></div></td></tr></table><hr><h3 id=ZeroCopyOutputStream.Next.details><code>virtual bool ZeroCopyOutputStream::Next(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void ** data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int * size) = 0</code></h3><div style=margin-left:16px><p>Obtains a buffer into which data can be written.</p><p>Any data written into this buffer will eventually (maybe instantly, maybe later on) be written to the output.</p><p>Preconditions:</p><ul><li>"size" and "data" are not NULL.</li></ul><p>Postconditions:</p><ul><li>If the returned value is false, an error occurred. All errors are permanent.</li><li>Otherwise, "size" points to the actual number of bytes in the buffer and "data" points to the buffer.</li><li>Ownership of this buffer remains with the stream, and the buffer remains valid only until some other method of the stream is called or the stream is destroyed.</li><li>Any data which the caller stores in this buffer will eventually be written to the output (unless <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream.BackUp>BackUp()</a> is called).</li><li>It is legal for the returned buffer to have zero size, as long as repeatedly calling <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream.Next>Next()</a> eventually yields a buffer with non-zero size.</li></ul></div><hr><h3 id=ZeroCopyOutputStream.BackUp.details><code>virtual void ZeroCopyOutputStream::BackUp(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int count) = 0</code></h3><div style=margin-left:16px><p>Backs up a number of bytes, so that the end of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream.Next>Next()</a> is not actually written.</p><p>This is needed when you finish writing all the data you want to write, but the last buffer was bigger than you needed. You don't want to write a bunch of garbage after the end of your data, so you use <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream.BackUp>BackUp()</a> to back up.</p><p>Preconditions:</p><ul><li>The last method called must have been <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream.Next>Next()</a>.</li><li>count must be less than or equal to the size of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream.Next>Next()</a>.</li><li>The caller must not have written anything to the last "count" bytes of that buffer.</li></ul><p>Postconditions:</p><ul><li>The last "count" bytes of the last buffer returned by <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream.Next>Next()</a> will be ignored.</li></ul></div><hr><h3 id=ZeroCopyOutputStream.WriteAliasedRaw.details><code>virtual bool ZeroCopyOutputStream::WriteAliasedRaw(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void * data,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size)</code></h3><div style=margin-left:16px><p>Write a given chunk of data to the output.</p><p>Some output streams may implement this in a way that avoids copying. Check AllowsAliasing() before calling <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream.WriteAliasedRaw>WriteAliasedRaw()</a>. It will GOOGLE_CHECK fail if <a href=google.protobuf.io.zero_copy_stream#ZeroCopyOutputStream.WriteAliasedRaw>WriteAliasedRaw()</a> is called on a stream that does not allow aliasing.</p><p>NOTE: It is caller's responsibility to ensure that the chunk of memory remains live until all of the data has been consumed from the stream.</p></div></body></html></main><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank rel=noopener href=https://stackoverflow.com/questions/tagged/protocol-buffers aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/protocolbuffers/protobuf aria-label=GitHub><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list"><a class=text-white target=_blank rel=noopener href=https://groups.google.com/g/protobuf aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2023 Google LLC All Rights Reserved</small>
<small class=ml-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></small>
<span class=text-white>Hosted by GitHub Pages.</span> <a href=https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement target=_blank>GitHub Privacy Statement</a></div></div></div></footer></div><script src=/js/main.min.9bf72cb065abb58e9dd4b5b0081420fe52b7f1d05088aa753cd0a5cff0f04feb.js integrity="sha256-m/cssGWrtY6d1LWwCBQg/lK38dBQiKp1PNClz/DwT+s=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>