<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.115.0"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Protocol Buffers Documentation</title><meta name=description content="service.hservice.h#include &amp;lt;google/protobuf/service.h&amp;gt;
namespace google::protobuf
DEPRECATED: This module declares the abstract interfaces underlying proto2 RPC services. These are intended to be independent of any particular RPC implementation, so that proto2 services can be used on top of a variety of implementations. Starting with version 2.3.0, RPC implementations should not try to build on these, but should instead provide code generator plugins which generate code specific to the particular RPC implementation. This way the generated code can be more appropriate for the implementation in use and can avoid unnecessary layers of indirection."><meta property="og:title" content><meta property="og:description" content="service.hservice.h#include <google/protobuf/service.h>
namespace google::protobuf
DEPRECATED: This module declares the abstract interfaces underlying proto2 RPC services. These are intended to be independent of any particular RPC implementation, so that proto2 services can be used on top of a variety of implementations. Starting with version 2.3.0, RPC implementations should not try to build on these, but should instead provide code generator plugins which generate code specific to the particular RPC implementation. This way the generated code can be more appropriate for the implementation in use and can avoid unnecessary layers of indirection."><meta property="og:type" content="article"><meta property="og:url" content="https://protobuf.dev/reference/cpp/api-docs/google.protobuf.service/"><meta property="article:section" content="reference"><meta itemprop=name content><meta itemprop=description content="service.hservice.h#include <google/protobuf/service.h>
namespace google::protobuf
DEPRECATED: This module declares the abstract interfaces underlying proto2 RPC services. These are intended to be independent of any particular RPC implementation, so that proto2 services can be used on top of a variety of implementations. Starting with version 2.3.0, RPC implementations should not try to build on these, but should instead provide code generator plugins which generate code specific to the particular RPC implementation. This way the generated code can be more appropriate for the implementation in use and can avoid unnecessary layers of indirection."><meta itemprop=wordCount content="1570"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="service.hservice.h#include <google/protobuf/service.h>
namespace google::protobuf
DEPRECATED: This module declares the abstract interfaces underlying proto2 RPC services. These are intended to be independent of any particular RPC implementation, so that proto2 services can be used on top of a variety of implementations. Starting with version 2.3.0, RPC implementations should not try to build on these, but should instead provide code generator plugins which generate code specific to the particular RPC implementation. This way the generated code can be more appropriate for the implementation in use and can avoid unnecessary layers of indirection."><link rel=preload href=/scss/main.min.43ad6541a45f31cd03dd1066a29ba2595ef582b492c6241a2288367893840e77.css as=style><link href=/scss/main.min.43ad6541a45f31cd03dd1066a29ba2595ef582b492c6241a2288367893840e77.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5L8P8GRN4Y"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-5L8P8GRN4Y")}</script></head><body class=td-page><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>Protocol Buffers Documentation</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"></ul></div><div class="navbar-nav d-none d-lg-block"><div class=td-search><div class=td-search__icon></div><input type=search class="td-search__input form-control td-search-input" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off></div></div></nav></header><div class="container-fluid td-default td-outer"><main role=main class=td-main><html devsite><head><title>service.h</title><meta name=project_path value=/protocol-buffers/_project.yaml><meta name=book_path value=/protocol-buffers/_book.yaml></head><body><h1>service.h</h1><p><code>#include &lt;google/protobuf/service.h><br>namespace <a href=#google.protobuf>google::protobuf</a></code></p><p>DEPRECATED: This module declares the abstract interfaces underlying proto2 RPC services.</p><p>These are intended to be independent of any particular RPC implementation, so that proto2 services can be used on top of a variety of implementations. Starting with version 2.3.0, RPC implementations should not try to build on these, but should instead provide code generator plugins which generate code specific to the particular RPC implementation. This way the generated code can be more appropriate for the implementation in use and can avoid unnecessary layers of indirection.</p><p>When you use the protocol compiler to compile a service definition, it generates two classes: An abstract interface for the service (with methods matching the service definition) and a "stub" implementation. A stub is just a type-safe wrapper around an <a href=google.protobuf.service#RpcChannel>RpcChannel</a> which emulates a local implementation of the service.</p><p>For example, the service definition:</p><pre>service MyService {
  rpc Foo(MyRequest) returns(MyResponse);
}</pre><p>will generate abstract interface "MyService" and class "MyService::Stub". You could implement a MyService as follows:</p><pre>class MyServiceImpl : public MyService {
 public:
  MyServiceImpl() {}
  ~MyServiceImpl() {}
<p>// implements MyService &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
<p>void Foo(google::protobuf::RpcController* controller,
const MyRequest* request,
MyResponse* response,
Closure* done) {
// &hellip; read request and fill in response &hellip;
done-&gt;Run();
}
};</pre></p><p>You would then register an instance of MyServiceImpl with your RPC server implementation. (How to do that depends on the implementation.)</p><p>To call a remote MyServiceImpl, first you need an <a href=google.protobuf.service#RpcChannel>RpcChannel</a> connected to it. How to construct a channel depends, again, on your RPC implementation. Here we use a hypothetical "MyRpcChannel" as an example:</p><pre>MyRpcChannel channel("rpc:hostname:1234/myservice");
MyRpcController controller;
MyServiceImpl::Stub stub(&amp;channel);
FooRequest request;
FooResponse response;
<p>// &hellip; fill in request &hellip;</p>
<p>stub.Foo(&amp;controller, request, &amp;response, NewCallback(HandleResponse));</pre></p><p>On Thread-Safety:</p><p>Different RPC implementations may make different guarantees about what threads they may run callbacks on, and what threads the application is allowed to use to call the RPC system. Portable software should be ready for callbacks to be called on any thread, but should not try to call the RPC system from any thread except for the ones on which it received the callbacks. Realistically, though, simple software will probably want to use a single-threaded RPC system while high-end software will want to use multiple threads. RPC implementations should provide multiple choices.</p><table width=100%><tr><th colspan=2><h3 style=margin-top:4px>Classes in this file</h3></th></tr><tr><td><div><code><a href=#Service>Service</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Abstract base interface for protocol-buffer-based RPC services.</div></td></tr><tr><td><div><code><a href=#RpcController>RpcController</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>An <a href=google.protobuf.service#RpcController>RpcController</a> mediates a single method call.</div></td></tr><tr><td><div><code><a href=#RpcChannel>RpcChannel</a></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Abstract interface for an RPC channel.</div></td></tr></table><h2 id=Service>class Service</h2><p><code>#include &lt;<a href=#>google/protobuf/service.h</a>><br>namespace <a href=#google.protobuf>google::protobuf</a></code></p><p>Abstract base interface for protocol-buffer-based RPC services.</p><p>Services themselves are abstract interfaces (implemented either by servers or as stubs), but they subclass this base interface. The methods of this interface can be used to call the methods of the <a href=google.protobuf.service#Service>Service</a> without knowing its exact type at compile time (analogous to <a href=google.protobuf.message#Reflection>Reflection</a>).</p><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code>enum</code></td><td style=border-left-width:0 id=Service.ChannelOwnership><div style=padding-left:16px;text-indent:-16px><code><b>ChannelOwnership</b></code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>When constructing a stub, you may pass STUB_OWNS_CHANNEL as the second parameter to the constructor to tell it to delete its <a href=google.protobuf.service#RpcChannel>RpcChannel</a> when destroyed. <a href=#Service.ChannelOwnership.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=Service.Service><div style=padding-left:16px;text-indent:-16px><code><b>Service</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual</code></td><td style=border-left-width:0 id=Service.~Service><div style=padding-left:16px;text-indent:-16px><code><b>~Service</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual const <a href=google.protobuf.descriptor#ServiceDescriptor>ServiceDescriptor</a> *</code></td><td style=border-left-width:0 id=Service.GetDescriptor><div style=padding-left:16px;text-indent:-16px><code><b>GetDescriptor</b>() = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Get the <a href=google.protobuf.descriptor#ServiceDescriptor>ServiceDescriptor</a> describing this service and its methods.</div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=Service.CallMethod><div style=padding-left:16px;text-indent:-16px><code><b>CallMethod</b>(const <a href=google.protobuf.descriptor#MethodDescriptor>MethodDescriptor</a> * method, <a href=google.protobuf.service#RpcController>RpcController</a> * controller, const <a href=google.protobuf.message#Message>Message</a> * request, <a href=google.protobuf.message#Message>Message</a> * response, Closure * done) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Call a method of the service specified by <a href=google.protobuf.descriptor#MethodDescriptor>MethodDescriptor</a>. <a href=#Service.CallMethod.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual const <a href=google.protobuf.message#Message>Message</a> &</code></td><td style=border-left-width:0 id=Service.GetRequestPrototype><div style=padding-left:16px;text-indent:-16px><code><b>GetRequestPrototype</b>(const <a href=google.protobuf.descriptor#MethodDescriptor>MethodDescriptor</a> * method) const = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px><a href=google.protobuf.service#Service.CallMethod>CallMethod()</a> requires that the request and response passed in are of a particular subclass of <a href=google.protobuf.message#Message>Message</a>. <a href=#Service.GetRequestPrototype.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual const <a href=google.protobuf.message#Message>Message</a> &</code></td><td style=border-left-width:0 id=Service.GetResponsePrototype><div style=padding-left:16px;text-indent:-16px><code><b>GetResponsePrototype</b>(const <a href=google.protobuf.descriptor#MethodDescriptor>MethodDescriptor</a> * method) const = 0</code></div></td></tr></table><hr><h3 id=Service.ChannelOwnership.details><code>enum Service::ChannelOwnership {<br>&nbsp;&nbsp;STUB_OWNS_CHANNEL,<br>&nbsp;&nbsp;STUB_DOESNT_OWN_CHANNEL<br>}</code></h3><div style=margin-left:16px><p>When constructing a stub, you may pass STUB_OWNS_CHANNEL as the second parameter to the constructor to tell it to delete its <a href=google.protobuf.service#RpcChannel>RpcChannel</a> when destroyed.</p><table><tr><td>STUB_OWNS_CHANNEL</td><td></td></tr><tr><td>STUB_DOESNT_OWN_CHANNEL</td><td></td></tr></table></div><hr><h3 id=Service.CallMethod.details><code>virtual void Service::CallMethod(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const <a href=google.protobuf.descriptor#MethodDescriptor>MethodDescriptor</a> * method,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=google.protobuf.service#RpcController>RpcController</a> * controller,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const <a href=google.protobuf.message#Message>Message</a> * request,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=google.protobuf.message#Message>Message</a> * response,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closure * done) = 0</code></h3><div style=margin-left:16px><p>Call a method of the service specified by <a href=google.protobuf.descriptor#MethodDescriptor>MethodDescriptor</a>.</p><p>This is normally implemented as a simple switch() that calls the standard definitions of the service's methods.</p><p>Preconditions:</p><ul><li>method->service() == <a href=google.protobuf.service#Service.GetDescriptor>GetDescriptor()</a></li><li>request and response are of the exact same classes as the objects returned by GetRequestPrototype(method) and GetResponsePrototype(method).</li><li>After the call has started, the request must not be modified and the response must not be accessed at all until "done" is called.</li><li>"controller" is of the correct type for the RPC implementation being used by this <a href=google.protobuf.service#Service>Service</a>. For stubs, the "correct type" depends on the <a href=google.protobuf.service#RpcChannel>RpcChannel</a> which the stub is using. Server-side <a href=google.protobuf.service#Service>Service</a> implementations are expected to accept whatever type of <a href=google.protobuf.service#RpcController>RpcController</a> the server-side RPC implementation uses.</li></ul><p>Postconditions:</p><ul><li>"done" will be called when the method is complete. This may be before <a href=google.protobuf.service#Service.CallMethod>CallMethod()</a> returns or it may be at some point in the future.</li><li>If the RPC succeeded, "response" contains the response returned by the server.</li><li>If the RPC failed, "response"'s contents are undefined. The <a href=google.protobuf.service#RpcController>RpcController</a> can be queried to determine if an error occurred and possibly to get more information about the error.</li></ul></div><hr><h3 id=Service.GetRequestPrototype.details><code>virtual const <a href=google.protobuf.message#Message>Message</a> & Service::GetRequestPrototype(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const <a href=google.protobuf.descriptor#MethodDescriptor>MethodDescriptor</a> * method) const = 0</code></h3><div style=margin-left:16px><p><a href=google.protobuf.service#Service.CallMethod>CallMethod()</a> requires that the request and response passed in are of a particular subclass of <a href=google.protobuf.message#Message>Message</a>.</p><p><a href=google.protobuf.service#Service.GetRequestPrototype>GetRequestPrototype()</a> and GetResponsePrototype() get the default instances of these required types. You can then call <a href=google.protobuf.message#Message.New>Message::New()</a> on these instances to construct mutable objects which you can then pass to <a href=google.protobuf.service#Service.CallMethod>CallMethod()</a>.</p><p>Example:</p><pre>const MethodDescriptor* method =
  service-&gt;GetDescriptor()-&gt;FindMethodByName("Foo");
Message* request  = stub-&gt;GetRequestPrototype (method)-&gt;New();
Message* response = stub-&gt;GetResponsePrototype(method)-&gt;New();
request-&gt;ParseFromString(input);
service-&gt;CallMethod(method, *request, response, callback);</pre></div><h2 id=RpcController>class RpcController</h2><p><code>#include &lt;<a href=#>google/protobuf/service.h</a>><br>namespace <a href=#google.protobuf>google::protobuf</a></code></p><p>An <a href=google.protobuf.service#RpcController>RpcController</a> mediates a single method call.</p><p>The primary purpose of the controller is to provide a way to manipulate settings specific to the RPC implementation and to find out about RPC-level errors.</p><p>The methods provided by the <a href=google.protobuf.service#RpcController>RpcController</a> interface are intended to be a "least common denominator" set of features which we expect all implementations to support. Specific implementations may provide more advanced features (e.g. deadline propagation).</p><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=RpcController.RpcController><div style=padding-left:16px;text-indent:-16px><code><b>RpcController</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual</code></td><td style=border-left-width:0 id=RpcController.~RpcController><div style=padding-left:16px;text-indent:-16px><code><b>~RpcController</b>()</code></div></td></tr><tr><th colspan=2><h3 style=margin-top:4px;margin-bottom:4px>Client-side methods</h3><div style=font-style:italic;font-weight:400>These calls may be made from the client side only. Their results are undefined on the server side (may crash).</div></th></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=RpcController.Reset><div style=padding-left:16px;text-indent:-16px><code><b>Reset</b>() = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Resets the <a href=google.protobuf.service#RpcController>RpcController</a> to its initial state so that it may be reused in a new call. <a href=#RpcController.Reset.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=RpcController.Failed><div style=padding-left:16px;text-indent:-16px><code><b>Failed</b>() const = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>After a call has finished, returns true if the call failed. <a href=#RpcController.Failed.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual std::string</code></td><td style=border-left-width:0 id=RpcController.ErrorText><div style=padding-left:16px;text-indent:-16px><code><b>ErrorText</b>() const = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>If <a href=google.protobuf.service#RpcController.Failed>Failed()</a> is true, returns a human-readable description of the error.</div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=RpcController.StartCancel><div style=padding-left:16px;text-indent:-16px><code><b>StartCancel</b>() = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Advises the RPC system that the caller desires that the RPC call be canceled. <a href=#RpcController.StartCancel.details>more...</a></div></td></tr><tr><th colspan=2><h3 style=margin-top:4px;margin-bottom:4px>Server-side methods</h3><div style=font-style:italic;font-weight:400><p>These calls may be made from the server side only.</p><p>Their results are undefined on the client side (may crash).</p></div></th></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=RpcController.SetFailed><div style=padding-left:16px;text-indent:-16px><code><b>SetFailed</b>(const std::string & reason) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Causes <a href=google.protobuf.service#RpcController.Failed>Failed()</a> to return true on the client side. <a href=#RpcController.SetFailed.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual bool</code></td><td style=border-left-width:0 id=RpcController.IsCanceled><div style=padding-left:16px;text-indent:-16px><code><b>IsCanceled</b>() const = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>If true, indicates that the client canceled the RPC, so the server may as well give up on replying to it. <a href=#RpcController.IsCanceled.details>more...</a></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=RpcController.NotifyOnCancel><div style=padding-left:16px;text-indent:-16px><code><b>NotifyOnCancel</b>(Closure * callback) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Asks that the given callback be called when the RPC is canceled. <a href=#RpcController.NotifyOnCancel.details>more...</a></div></td></tr></table><hr><h3 id=RpcController.Reset.details><code>virtual void RpcController::Reset() = 0</code></h3><div style=margin-left:16px><p>Resets the <a href=google.protobuf.service#RpcController>RpcController</a> to its initial state so that it may be reused in a new call.</p><p>Must not be called while an RPC is in progress.</p></div><hr><h3 id=RpcController.Failed.details><code>virtual bool RpcController::Failed() const = 0</code></h3><div style=margin-left:16px><p>After a call has finished, returns true if the call failed.</p><p>The possible reasons for failure depend on the RPC implementation. <a href=google.protobuf.service#RpcController.Failed>Failed()</a> must not be called before a call has finished. If <a href=google.protobuf.service#RpcController.Failed>Failed()</a> returns true, the contents of the response message are undefined.</p></div><hr><h3 id=RpcController.StartCancel.details><code>virtual void RpcController::StartCancel() = 0</code></h3><div style=margin-left:16px><p>Advises the RPC system that the caller desires that the RPC call be canceled.</p><p>The RPC system may cancel it immediately, may wait awhile and then cancel it, or may not even cancel the call at all. If the call is canceled, the "done" callback will still be called and the <a href=google.protobuf.service#RpcController>RpcController</a> will indicate that the call failed at that time.</p></div><hr><h3 id=RpcController.SetFailed.details><code>virtual void RpcController::SetFailed(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::string & reason) = 0</code></h3><div style=margin-left:16px><p>Causes <a href=google.protobuf.service#RpcController.Failed>Failed()</a> to return true on the client side.</p><p>"reason" will be incorporated into the message returned by <a href=google.protobuf.service#RpcController.ErrorText>ErrorText()</a>. If you find you need to return machine-readable information about failures, you should incorporate it into your response protocol buffer and should NOT call <a href=google.protobuf.service#RpcController.SetFailed>SetFailed()</a>.</p></div><hr><h3 id=RpcController.IsCanceled.details><code>virtual bool RpcController::IsCanceled() const = 0</code></h3><div style=margin-left:16px><p>If true, indicates that the client canceled the RPC, so the server may as well give up on replying to it.</p><p>The server should still call the final "done" callback.</p></div><hr><h3 id=RpcController.NotifyOnCancel.details><code>virtual void RpcController::NotifyOnCancel(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closure * callback) = 0</code></h3><div style=margin-left:16px><p>Asks that the given callback be called when the RPC is canceled.</p><p>The callback will always be called exactly once. If the RPC completes without being canceled, the callback will be called after completion. If the RPC has already been canceled when <a href=google.protobuf.service#RpcController.NotifyOnCancel>NotifyOnCancel()</a> is called, the callback will be called immediately.</p><p><a href=google.protobuf.service#RpcController.NotifyOnCancel>NotifyOnCancel()</a> must be called no more than once per request.</p></div><h2 id=RpcChannel>class RpcChannel</h2><p><code>#include &lt;<a href=#>google/protobuf/service.h</a>><br>namespace <a href=#google.protobuf>google::protobuf</a></code></p><p>Abstract interface for an RPC channel.</p><p>An <a href=google.protobuf.service#RpcChannel>RpcChannel</a> represents a communication line to a <a href=google.protobuf.service#Service>Service</a> which can be used to call that <a href=google.protobuf.service#Service>Service</a>'s methods. The <a href=google.protobuf.service#Service>Service</a> may be running on another machine. Normally, you should not call an <a href=google.protobuf.service#RpcChannel>RpcChannel</a> directly, but instead construct a stub <a href=google.protobuf.service#Service>Service</a> wrapping it. Example:</p><pre>RpcChannel* channel = new MyRpcChannel("remotehost.example.com:1234");
MyService* service = new MyService::Stub(channel);
service-&gt;MyMethod(request, &amp;response, callback);</pre><table><tr><th colspan=2><h3 style=margin-top:4px>Members</h3></th></tr><tr><td style=border-right-width:0;text-align:right><code></code></td><td style=border-left-width:0 id=RpcChannel.RpcChannel><div style=padding-left:16px;text-indent:-16px><code><b>RpcChannel</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual</code></td><td style=border-left-width:0 id=RpcChannel.~RpcChannel><div style=padding-left:16px;text-indent:-16px><code><b>~RpcChannel</b>()</code></div></td></tr><tr><td style=border-right-width:0;text-align:right><code>virtual void</code></td><td style=border-left-width:0 id=RpcChannel.CallMethod><div style=padding-left:16px;text-indent:-16px><code><b>CallMethod</b>(const <a href=google.protobuf.descriptor#MethodDescriptor>MethodDescriptor</a> * method, <a href=google.protobuf.service#RpcController>RpcController</a> * controller, const <a href=google.protobuf.message#Message>Message</a> * request, <a href=google.protobuf.message#Message>Message</a> * response, Closure * done) = 0</code></div><div style=font-style:italic;margin-top:4px;margin-left:16px>Call the given method of the remote service. <a href=#RpcChannel.CallMethod.details>more...</a></div></td></tr></table><hr><h3 id=RpcChannel.CallMethod.details><code>virtual void RpcChannel::CallMethod(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const <a href=google.protobuf.descriptor#MethodDescriptor>MethodDescriptor</a> * method,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=google.protobuf.service#RpcController>RpcController</a> * controller,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const <a href=google.protobuf.message#Message>Message</a> * request,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=google.protobuf.message#Message>Message</a> * response,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closure * done) = 0</code></h3><div style=margin-left:16px><p>Call the given method of the remote service.</p><p>The signature of this procedure looks the same as <a href=google.protobuf.service#Service.CallMethod>Service::CallMethod()</a>, but the requirements are less strict in one important way: the request and response objects need not be of any specific class as long as their descriptors are method->input_type() and method->output_type().</p></div></body></html></main><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank rel=noopener href=https://stackoverflow.com/questions/tagged/protocol-buffers aria-label="Stack Overflow"><i class="fab fa-stack-overflow"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel=noopener href=https://github.com/protocolbuffers/protobuf aria-label=GitHub><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Developer mailing list" aria-label="Developer mailing list"><a class=text-white target=_blank rel=noopener href=https://groups.google.com/g/protobuf aria-label="Developer mailing list"><i class="fa fa-envelope"></i></a></li></ul><script type=text/javascript id=cookiebanner src=https://cdn.jsdelivr.net/gh/dobarkod/cookie-banner@1.2.2/dist/cookiebanner.min.js data-height=50px data-message="Protobuf.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic." data-bg=#ffb data-fg=#000 data-position=bottom data-padding="10px 16px" data-close-text="OK, got it" data-font-size=18px data-moreinfo=https://policies.google.com/technologies/cookies></script></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2023 Google LLC All Rights Reserved</small>
<small class=ml-1><a href=https://policies.google.com/privacy target=_blank rel=noopener>Privacy Policy</a></small>
<span class=text-white>Hosted by GitHub Pages.</span> <a href=https://docs.github.com/en/site-policy/privacy-policies/github-privacy-statement target=_blank>GitHub Privacy Statement</a></div></div></div></footer></div><script src=/js/main.min.9bf72cb065abb58e9dd4b5b0081420fe52b7f1d05088aa753cd0a5cff0f04feb.js integrity="sha256-m/cssGWrtY6d1LWwCBQg/lK38dBQiKp1PNClz/DwT+s=" crossorigin=anonymous></script>
<script src=/js/tabpane-persist.js></script></body></html>